<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yuan]]></title>
  <subtitle><![CDATA[一点一滴，技术积累]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://luoyuan800.github.io//"/>
  <updated>2015-10-28T07:06:02.415Z</updated>
  <id>http://luoyuan800.github.io//</id>
  
  <author>
    <name><![CDATA[Luo Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android自动更新推送的实现]]></title>
    <link href="http://luoyuan800.github.io/2015/10/28/android_auto_update/"/>
    <id>http://luoyuan800.github.io/2015/10/28/android_auto_update/</id>
    <published>2015-10-28T03:39:21.000Z</published>
    <updated>2015-10-28T07:06:02.415Z</updated>
    <content type="html"><![CDATA[<p>当发布了一个Android app之后，我们最需要使用的功能就是如何实现当有更新的是推送给用户。<br><a id="more"></a></p>
<h2 id="实现思路">实现思路</h2><ol>
<li>首先是要申请一个可以直接访问的网盘放置你的更新文件</li>
<li>放置一个文件，里面注明更新后的版本号</li>
<li>在app的代码中每次启动的时候去下载那个标识有版本号的文件，然后匹配当前app的版本和，如果不一致，提示用户更新。</li>
</ol>
<h2 id="代码相关">代码相关</h2><h3 id="读取网络文件">读取网络文件</h3><p>首先是如何下载网络上文件。 Android不允许在UI主线程进行网络访问的操作，所以我们需要构建一个线程，无论是用<code>new Thread</code>还是用<code>handler.put(Runnable)</code> 都是可以的，在线程的run方法中进行网络访问或者下载：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> checkUpdate() {
    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
        <span class="keyword">public</span> <span class="keyword">void</span> run() {
            <span class="keyword">try</span> {
                PackageInfo pInfo = getPackageManager().getPackageInfo(
                        getPackageName(), <span class="number">0</span>);<span class="comment">//获取当前的版本信息</span>
                currentVersion = pInfo.versionName.<span class="built_in">trim</span>();
                <span class="comment">// 构造URL</span>
                URL url = <span class="keyword">new</span> URL(VERSION_CHECK_URL);
                <span class="comment">// 打开连接</span>
                URLConnection con = url.openConnection();
                <span class="comment">//获得文件的长度</span>
                <span class="built_in">int</span> contentLength = con.getContentLength();
                <span class="comment">// 输入流</span>
                InputStream is = con.getInputStream();
                <span class="keyword">BufferedReader</span> br = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(is));

                <span class="built_in">int</span> curVersionCode = pInfo.versionCode;
                updateVersion = br.readLine().replace((<span class="built_in">char</span>) <span class="number">65279</span>, <span class="string">' '</span>).<span class="built_in">trim</span>();
                <span class="comment">//请注意这一行，只是为了防止网络上的文件使用了win的带BOM的编码文本，BOM文本第一行开头会有一个特殊的字符。</span>

                <span class="keyword">if</span> (updateVersion.equalsIgnoreCase(currentVersion)) {
                    <span class="comment">//不需要升级通知</span>
                } <span class="keyword">else</span> {
                    <span class="keyword">String</span> info = br.readLine();
                    versionUpdateInfo = <span class="keyword">new</span> StringBuilder(<span class="string">"新版本:"</span> + updateVersion);
                    <span class="keyword">while</span> (info != <span class="keyword">null</span> &amp;&amp; !info.isEmpty()) {
                    <span class="comment">//获取升级信息，你可以在升级的文本里面第一行写上版本号，第二行开始写上升级的详细信息。</span>
                        versionUpdateInfo.<span class="built_in">append</span>(<span class="string">"\n"</span>).<span class="built_in">append</span>(info);
                        info = br.readLine();
                    }
                   <span class="comment">//弹出一个窗口，提示用户可以进行升级</span>
                }
                br.close();
            } <span class="keyword">catch</span> (Exception e) {
                e.printStackTrace();
            }
        }
    }).start();
}
</code></pre><h3 id="下载更新包">下载更新包</h3><p> 下载升级包并且保存到本地SD卡，首先必须要设置SD卡的权限，这里不在赘述。以下代码是下载安装包并且保存到本地SD卡：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> downloadPAK(Handler handler) {
    <span class="keyword">try</span> {
        <span class="comment">// 构造URL</span>
        URL url = <span class="keyword">new</span> URL(PACKAGE_DOWNLOAD_URL);
        <span class="comment">// 打开连接</span>
        URLConnection con = url.openConnection();
        <span class="comment">//获得文件的长度</span>
        <span class="keyword">int</span> contentLength = con.getContentLength();

        <span class="comment">// 输入流</span>
        InputStream is = con.getInputStream();
        BufferedInputStream br = <span class="keyword">new</span> BufferedInputStream(is);
        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];
        <span class="keyword">int</span> len;
        <span class="comment">// 输出的文件流</span>
        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(APK_PATH + <span class="string">"/appName.apk"</span>);
        <span class="keyword">if</span> (<span class="keyword">file</span>.exists()) {
            <span class="keyword">file</span>.<span class="keyword">delete</span>();
        }
        <span class="keyword">File</span> path = <span class="keyword">new</span> <span class="keyword">File</span>(APK_PATH);
        <span class="keyword">if</span> (!path.exists()) {
            path.mkdirs();
        }
        <span class="keyword">file</span>.createNewFile();
        OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">file</span>);
        <span class="comment">// 开始读取</span>
        <span class="keyword">int</span> alreadySize = <span class="number">0</span>;
        <span class="keyword">while</span> ((len = is.<span class="keyword">read</span>(data)) != -<span class="number">1</span>) {
            os.<span class="keyword">write</span>(data, <span class="number">0</span>, len);
        }
        os.flush();
        os.close();
        br.close();
        <span class="comment">//通知用户下载成功</span>
        <span class="keyword">return</span> <span class="keyword">true</span>;
    } <span class="keyword">catch</span> (Exception e) {
        e.printStackTrace();
        Log.e(TAG, <span class="string">"DownloadUpdate"</span>, e);
    }
       <span class="comment">//通知用户下载失败</span>
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><h3 id="自动安装APK">自动安装APK</h3><p>下载完成后我们要弹出安装提示给用户，并且保证安装能够完成：</p>
<pre><code><span class="keyword">private</span> void installAPK() {
    <span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>(<span class="type">Intent</span>.ACTION_VIEW);
    <span class="type">intent</span>.setDataAndType(Uri.fromFile(new <span class="keyword">File</span>(APK_PATH + <span class="string">"/appName.apk"</span>)),
            <span class="string">"application/vnd.android.package-archive"</span>);
    <span class="type">intent</span>.addFlags(<span class="type">Intent</span>.FLAG_ACTIVITY_NEW_TASK);//必须要加上这一句话才能保证安装完成后不会跳出到主界面
    context.startActivity(<span class="type">intent</span>);
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>当发布了一个Android app之后，我们最需要使用的功能就是如何实现当有更新的是推送给用户。<br>]]>
    
    </summary>
    
      <category term="编程-Android" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识Android]]></title>
    <link href="http://luoyuan800.github.io/2015/10/28/start_android/"/>
    <id>http://luoyuan800.github.io/2015/10/28/start_android/</id>
    <published>2015-10-28T00:39:21.000Z</published>
    <updated>2015-10-28T07:30:56.942Z</updated>
    <content type="html"><![CDATA[<p>以下是一些零散初级的Android相关知识。<br><a id="more"></a></p>
<h2 id="界面类">界面类</h2><p>展示在屏幕上的东西。在安卓中的基类为Activity。所有界面都是需要实现这个接口，并且实现相应的onCreate方法。</p>
<h2 id="布局">布局</h2><p>android中界面类是布局是分来来设定的，布局可以在一个放到res/layout文件夹中的xml文件来描述。布局文件的标识是一个整型的id：R.layout.id。需要在一个Activity的onCreate方法中使用setContentView方法将对应的布局文件绑定到这个Activity中。</p>
<h2 id="Local_String">Local String</h2><p>在界面中暂时的静态文字（不会动态改变的文字）是可以抽取到一个放置在res/value文件夹中的strings.xml中定义，可以在布局描述文件中使用id号来引用这个文字。</p>
<h2 id="主文件">主文件</h2><p>Android中的主文件，也就是Android程序的入口文件不是java类，而是AndroidManifest.xml文件，该文件中会描述到这个Android程序支持的版本，程序具有的手机操作权限。同时，如果我们定义了一个Activity类，那么需要将这个类名在Androidmanifest.xml中用<activity>标签声明一次，在程序运行的过程中才可以使用到这个界面。在文件中的<uses-sdk android:minsdkversion="11">标签限制了当前android项目开发中能够使用的功能的最低版本，而且也限制了生成的程序能够安装的最低版本。</uses-sdk></activity></p>
<h2 id="控件">控件</h2><p>Android中能显示给用户看的界面上基本元素就是控件，能够使用的控件对象在android.widget包内。可以在布局文件中通过和控件同名的标签来引用控件与定义控件属性。</p>
<h2 id="Activity切换">Activity切换</h2><p>从一个Activity切换到另外一个activity有两种场景：<br>需要使用到Intent主动设置切换的目的界面，然后调用startActivity（Intent）生成目的界面的实例。<br>当前界面被结束的时候，比如按下了手机的后退键，会被动的切换到上一个界面，如果没有上级界面就会退出程序。因为Intent是构建是需要制定源界面实例和目的界面类，所以可以实现后退的功能。<br>Activity的界面切换效果展示，默认的界面切换是直接展示下一个界面，我们可以设定界面切换动画，从而使得切换过程更加频繁。动画效果是用一个xml文件来描述，并且必须被放置在res/anim文件夹内。可以在发生界面切换的地方调用overridePendingTransition(进入的动画id, 退出的动画id)来设置切换动画。会发生界面切换地方包括：</p>
<p>1.调用了startActivity方法之后;</p>
<ol>
<li>在Activity的finished方法中调用了super.finished()之后。</li>
</ol>
<h2 id="ListView">ListView</h2><p>在Android中如果你需要展示一个列表，并且希望可以产生列表项的点击动作，那么可以选择一个ListView。可以在一个layout的xml文件中定义ListView。同时定义list_item的xml文件。最简便的而且推荐的方法是，是实现一个继承自ListActivity的类，那么这个Activity就实现了ListView的功能了，我们只需要定义一个List Item的layout文件就可以展示列表数据了。<br>ListView中要展示的数据是通过Adapter类来传入的，要展示到ListView中的数据组需要先放置到Adapter中，然后将Adapter设置给ListView实例。<br>ListView并不是直接使用Adapter的数据去构建直接的Item来展示数据，而是在Adapter中有getView的方法，这个方法会返回某个Item的展示View实例。一般情况下我们需要自己构建一个Adapter类的子类复写getView方法来设定用什么样的格式展示数据。<br>网络上说的很多的View缓存技术，就是对应大量List数据的展示并不是每一个Item都创建一个ItemView，而是将一个屏幕显示数量的View缓存起来，每次滚动ListView的时候，都是更新View，而不是重新创建，这样可以节省系统资源。这个功能就是通过Adapter的getView方法来实现的。</p>
<h2 id="R">R</h2><p>在Android的项目代码编写中，R这个静态常量是可以引用到我们定义在layout、value、anim…等文件夹中的XML资源的。<br>注意的是android.R引用到的是Android本身内置的资源。</p>
<h2 id="res文件夹">res文件夹</h2><p>res文件夹内的文件不能用数字命名</p>
<h3 id="anim">anim</h3><p>这个文件夹下放置动画效果的文件，如果你的项目中没有这个文件夹，可以手动创建。</p>
<h3 id="drawable">drawable</h3><p>这个文件夹内放置图片文件</p>
<h2 id="安装Android开发IDE_Android_Studio">安装Android开发IDE Android Studio</h2><ol>
<li><p>因为google被墙，所以我们需要在host文件中增加（HOSTS文件位置：C:\Windows\system32\drivers\etc\hosts）：</p>
<p> 74.125.237.1 dl-ssl.google.com</p>
</li>
<li><p>在Android Studio的安装文件BIN文件夹里打找到“idea.properties”，最后一行添加：<code>disable.android.first.run=true</code></p>
</li>
</ol>
<h2 id="启动Android虚拟机失败">启动Android虚拟机失败</h2><p>如果提示 Failed to obtain GLES 1.x extensions string!<br>有可能是因为远程操作电脑导致的这个问题,解决办法是打开虚拟机的配置，去掉Use Host GPU前面的√</p>
<h2 id="Android_开发过程中遇到的异常信息">Android 开发过程中遇到的异常信息</h2><h3 id="android-os-NetworkOnMainThreadException">android.os.NetworkOnMainThreadException</h3><p>Android4.0之后开始不允许在主线程内访问网络，所以只需要使用一个子线程去访问网络，并且使用消息机制返回网络访问的结果就可以避开这个异常了。</p>
<h3 id="ndroid-view-WindowLeaked">ndroid.view.WindowLeaked</h3><p>按字面了解，Window Leaked大概就是说一个窗体泄漏了，也就是我们常说的内存泄漏，为什么窗体会泄漏呢？产生原因：<br>我们知道Android的每一个Activity都有个WindowManager窗体管理器，同样，构建在某个Activity之上的对话框、PopupWindow也有相应的WindowManager窗体管理器。因为对话框、PopupWindown不能脱离Activity而单独存在着，所以当某个Dialog或者某个PopupWindow正在显示的时候我们去finish()了承载该Dialog(或PopupWindow)的Activity时，就会抛Window Leaked异常了，因为这个Dialog(或PopupWindow)的WindowManager已经没有谁可以附属了，所以它的窗体管理器已经泄漏了。<br>解决方法是关闭(finish)某个Activity前，要确保附属在上面的Dialog或PopupWindow已经关闭(dismiss)了。</p>
<h3 id="Android_showDialog时报错">Android showDialog时报错</h3><p>错误信息是<code>requestFeature() must be called before adding content</code></p>
<p>出现此问题是由于dialog.show()之前调用了dialog.setContentView()或者dialog.getwindow()等，正确的应该是dialog.show()之后调用dialog.setContentView()</p>
<h3 id="Service_Intent_must_be_explicit">Service Intent must be explicit</h3><p>android5.0 api=21以上要求启动service要设置packagename。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下是一些零散初级的Android相关知识。<br>]]>
    
    </summary>
    
      <category term="编程-Android" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于snmp4j发送 V3 trap]]></title>
    <link href="http://luoyuan800.github.io/2015/10/09/snmp4j-trap-v3/"/>
    <id>http://luoyuan800.github.io/2015/10/09/snmp4j-trap-v3/</id>
    <published>2015-10-09T08:10:14.000Z</published>
    <updated>2015-10-09T08:49:22.095Z</updated>
    <content type="html"><![CDATA[<p>基于snmp4j收集数据或者发送v1版本的trap比较简单，可以自己动手网上搜索，这里展示下如何发送v3的trap（因为网络上搜索不到）<br><a id="more"></a></p>
<h2 id="SNMP4J版本要求">SNMP4J版本要求</h2><p>snmp4j 2.2.2及以上的版本都会支持使用snmp v3</p>
<h2 id="发送SNMP_v3_Trap的代码">发送SNMP v3 Trap的代码</h2><pre><code><span class="preprocessor"><span class="keyword">import</span> org.snmp4j.PDU;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.ScopedPDU;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.Snmp;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.TransportMapping;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.UserTarget;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.mp.MPv3;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.mp.SnmpConstants;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.SecurityLevel;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.SecurityModels;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.SecurityProtocols;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.USM;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.UsmUser;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.UsmUserEntry;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.Address;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.GenericAddress;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.OID;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.OctetString;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.VariableBinding;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.transport.DefaultUdpTransportMapping;</span>

<span class="preprocessor"><span class="keyword">import</span> java.io.IOException;</span>

<span class="comment">/**
* 本类用于发送v3 Trap信息
*
* @author luoyuan
*/</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnmpSendV3Trap</span> </span>{

<span class="keyword">private</span> Snmp snmp = <span class="literal">null</span>;

<span class="keyword">private</span> Address targetAddress = <span class="literal">null</span>;

<span class="keyword">public</span> SnmpSendV3Trap(String target, int port) throws IOException {
    <span class="comment">//配置EngineID</span>
    OctetString localEngineID = <span class="keyword">new</span> OctetString(MPv3.createLocalEngineID());
    <span class="comment">// 设置目的地的IP和端口</span>
    targetAddress = GenericAddress.parse(String.format(<span class="string">"udp:%s/%s"</span>, target, port));
    TransportMapping transport = <span class="keyword">new</span> DefaultUdpTransportMapping();
    <span class="comment">//配置USM，传入 engine id</span>
    USM usm = <span class="keyword">new</span> USM(SecurityProtocols.getInstance(), localEngineID, <span class="number">0</span>);
    <span class="comment">//添加Usm user， 这里的配置的user， 目标接收端也正确认证才可以接受到这个trap</span>
    <span class="comment">//这里创建User的是全部使用null是表示使用NOAUTH_NOPRIV的模式发送trap</span>
    <span class="comment">//具体的Auth模式可以参考收集snmp数据，是一样配置的。</span>
    usm.updateUser(<span class="keyword">new</span> UsmUserEntry(<span class="keyword">new</span> OctetString(<span class="string">"luo"</span>), <span class="keyword">new</span> UsmUser(<span class="keyword">new</span> OctetString(<span class="string">"luo"</span>),
            <span class="literal">null</span>,
            <span class="literal">null</span>,
            <span class="literal">null</span>,
            <span class="literal">null</span>)));
    <span class="comment">//添加USM到Security Models中</span>
    SecurityModels.getInstance().addSecurityModel(usm);
    <span class="comment">//构建SNMP对象， 并且添加v3模式到其中</span>
    snmp = <span class="keyword">new</span> Snmp(transport);
    snmp.getMessageDispatcher().addMessageProcessingModel(<span class="keyword">new</span> MPv3(usm));
    transport.listen();

}

<span class="comment">/**
 * 向管理进程发送Trap报文
 *
 * @throws IOException
 */</span>
<span class="keyword">public</span> <span class="keyword">void</span> sendPDU() throws IOException {

    <span class="comment">// 设置 target, v3trap 一定要使用UserTarget</span>
    UserTarget target = <span class="keyword">new</span> UserTarget();
    target.setAddress(targetAddress);
    target.setVersion(SnmpConstants.version3);
    <span class="comment">//设置用户认证信息</span>
    target.setSecurityLevel(SecurityLevel.NOAUTH_NOPRIV);
    target.setSecurityName(<span class="keyword">new</span> OctetString(<span class="string">"luo"</span>));

    <span class="comment">// 创建 PDU, 注意这里要使用ScopedPDU</span>
    ScopedPDU pdu = <span class="keyword">new</span> ScopedPDU();
    pdu.add(<span class="keyword">new</span> VariableBinding(<span class="keyword">new</span> OID(<span class="string">".1.3.6.1.2.4407.11.1.1.1.1"</span>),
            <span class="keyword">new</span> OctetString(<span class="string">"SnmpTrap"</span>)));
    pdu.add(<span class="keyword">new</span> VariableBinding(<span class="keyword">new</span> OID(<span class="string">".1.3.6.1.2.4407.11.1.1.1.2"</span>),
            <span class="keyword">new</span> OctetString(<span class="string">"v3"</span>)));
    pdu.setType(PDU.TRAP);

    <span class="comment">// 发送trap</span>
    snmp.send(pdu, target);
}

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
    <span class="keyword">try</span> {
        SnmpSendV3Trap trapSender = <span class="keyword">new</span> SnmpSendV3Trap(<span class="string">"10.154.10.11"</span>, <span class="number">162</span>);
        trapSender.sendPDU();
    } <span class="keyword">catch</span> (IOException e) {
        e.printStackTrace();
    }
}
}
</code></pre><h2 id="接收_v3_trap_的代码">接收 v3 trap 的代码</h2><pre><code><span class="preprocessor"><span class="keyword">import</span> org.snmp4j.CommandResponder;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.CommandResponderEvent;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.MessageDispatcherImpl;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.Snmp;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.TransportMapping;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.mp.MPv3;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.SecurityModels;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.SecurityProtocols;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.USM;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.UsmUser;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.UsmUserEntry;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.Address;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.GenericAddress;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.OctetString;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.TcpAddress;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.UdpAddress;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.VariableBinding;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.transport.DefaultTcpTransportMapping;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.transport.DefaultUdpTransportMapping;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.util.MultiThreadedMessageDispatcher;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.util.ThreadPool;</span>
<span class="preprocessor"><span class="keyword">import</span> java.io.IOException;</span>
<span class="preprocessor"><span class="keyword">import</span> java.util.Vector;</span>

<span class="comment">/**
 * 本类用于监听发送到本机的Trap信息
 *
 * @author luoyuan
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalTrapReceiver</span> <span class="keyword">implements</span> <span class="title">CommandResponder</span> </span>{

    <span class="keyword">private</span> MultiThreadedMessageDispatcher dispatcher;
    <span class="keyword">private</span> Snmp snmp = <span class="literal">null</span>;

    <span class="keyword">private</span> LocalTrapReceiver() throws IOException {
        dispatcher = <span class="keyword">new</span> MultiThreadedMessageDispatcher(ThreadPool.create(<span class="string">"snmp trap"</span>, <span class="number">2</span>),
                <span class="keyword">new</span> MessageDispatcherImpl());
        Address listenUdpAddress = GenericAddress.parse(<span class="string">"udp:0.0.0.0/162"</span>); <span class="comment">// udp监听端口</span>
        Address listenTCPAddress = GenericAddress.parse(<span class="string">"tcp:0.0.0.0/162"</span>); <span class="comment">// tcp监听端口</span>
        TransportMapping transport;
        <span class="comment">// 对TCP与UDP协议进行处理</span>
        DefaultUdpTransportMapping udpTransport = <span class="keyword">new</span> DefaultUdpTransportMapping(
                (UdpAddress) listenUdpAddress);
        DefaultTcpTransportMapping tcpTransport = <span class="keyword">new</span> DefaultTcpTransportMapping(
                (TcpAddress) listenTCPAddress);

        snmp = <span class="keyword">new</span> Snmp(dispatcher, udpTransport);
        snmp.addTransportMapping(tcpTransport);

        <span class="comment">//配置engine</span>
        OctetString localEngineID = <span class="keyword">new</span> OctetString(MPv3.createLocalEngineID());
        <span class="comment">//配置USM 和user，需要和发送trap的配置一样才可以成功接收trap</span>
        USM usm = <span class="keyword">new</span> USM(SecurityProtocols.getInstance(), localEngineID, <span class="number">0</span>);
        usm.updateUser(<span class="keyword">new</span> UsmUserEntry(<span class="keyword">new</span> OctetString(<span class="string">"luo"</span>), <span class="keyword">new</span> UsmUser(<span class="keyword">new</span> OctetString(<span class="string">"luo"</span>),
                <span class="literal">null</span>,
                <span class="literal">null</span>,
                <span class="literal">null</span>,
                <span class="literal">null</span>)));
        SecurityModels.getInstance().addSecurityModel(usm);
        snmp.getMessageDispatcher().addMessageProcessingModel(<span class="keyword">new</span> MPv3(usm));
        snmp.listen();
    }


    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="keyword">try</span> {
            snmp.addCommandResponder(<span class="keyword">this</span>);
            System.out.println(<span class="string">"开始监听Trap信息!"</span>);
        } <span class="keyword">catch</span> (Exception ex) {
            ex.printStackTrace();
        }
    }

    <span class="comment">/**
     * 当接收到trap时，会自动进入这个方法
     *
     * @param respEvnt
     */</span>
    <span class="keyword">public</span> <span class="keyword">void</span> processPdu(CommandResponderEvent respEvnt) {
        <span class="comment">// 解析Response并且直接打印出来</span>
        <span class="keyword">if</span> (respEvnt != <span class="literal">null</span> &amp;&amp; respEvnt.getPDU() != <span class="literal">null</span>) {
            System.out.println(<span class="string">"security name = "</span> + <span class="keyword">new</span> OctetString(respEvnt.getSecurityName()));
            Vector&lt;? <span class="keyword">extends</span> VariableBinding&gt; recVBs = respEvnt.getPDU().getVariableBindings();
            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; recVBs.size(); i++) {
                VariableBinding recVB = recVBs.elementAt(i);
                System.out.println(recVB.getOid() + <span class="string">" : "</span> + recVB.getVariable());
            }
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws IOException {
        LocalTrapReceiver localTrapReceiver = <span class="keyword">new</span> LocalTrapReceiver();
        localTrapReceiver.run();
    }

}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>基于snmp4j收集数据或者发送v1版本的trap比较简单，可以自己动手网上搜索，这里展示下如何发送v3的trap（因为网络上搜索不到）<br>]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[启用WinRm]]></title>
    <link href="http://luoyuan800.github.io/2015/09/22/WinRm/"/>
    <id>http://luoyuan800.github.io/2015/09/22/WinRm/</id>
    <published>2015-09-22T06:45:50.000Z</published>
    <updated>2015-09-23T01:54:11.487Z</updated>
    <content type="html"><![CDATA[<p>如何在Windows上配置启用WinRm<a id="more"></a></p>
<h2 id="在windows_server_system上配置WinRm">在windows server system上配置WinRm</h2><ol>
<li>使用Administrator账号登陆目标机器（不是Administrator用户组，而是Administrator账号）。</li>
<li>使用命令<code>winrm enumerate winrm/config/listener</code>查看WinRm在当前的机器上是否因配置过。</li>
<li>如果没有返回消息，就表明WinRm没有成功配置。</li>
<li>执行 <code>winrm quickconfig</code> 初始化WinRm</li>
<li>执行命令<code>winrm set winrm/config/service/auth @{Basic=&quot;true&quot;}</code> 配置登陆方式</li>
<li>执行 <code>winrm set winrm/config/service @{AllowUnencrypted=&quot;true&quot;}</code> 配置加密方式</li>
<li>执行 <code>winrm enumerate winrm/config/listener</code> 查看WinR是否成功配置</li>
<li>如果发现还是不能执行WinRm命令的话，打开端口http和https<ol>
<li><code>winrm quickconfig -transport:https</code></li>
<li><code>winrm quickconfig -transport:http</code></li>
</ol>
</li>
<li>如果发现以上命令执行不成功，那么尝试参考下面的步骤： 更换登陆方式为negotiate</li>
</ol>
<h2 id="WinRm_登陆方式设置">WinRm 登陆方式设置</h2><h3 id="默认的WinRm登陆是使用Basic的，但是Basic模式下是不能修改WinRm的配置，只能读取数据。如果需要修改配置，首先我们需要配置登陆模式为negotiate。">默认的WinRm登陆是使用Basic的，但是Basic模式下是不能修改WinRm的配置，只能读取数据。如果需要修改配置，首先我们需要配置登陆模式为negotiate。</h3><ol>
<li>首先需要打开注册表<code>regedit</code></li>
<li>找到注册表<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WSMAN\Service</code></li>
<li>修改键 <code>auth-negotiate</code> 为 1， <code>suth-basic</code> 为 0</li>
<li>重启系统</li>
</ol>
<h3 id="如果需要切换回Basic的登陆方式">如果需要切换回Basic的登陆方式</h3><ol>
<li>首先在Negotiate模式下执行<code>winrm set winrm/config/service/auth @{Basic=&quot;true&quot;}</code></li>
<li>然后再执行<code>winrm set winrm/config/service/auth @{Negotiate=&quot;false&quot;}</code></li>
</ol>
<h2 id="WinRm的用户组设置">WinRm的用户组设置</h2><ol>
<li>设定WinR用户组，我们可以指定特定的用户组具有访问WinRm的权限<ol>
<li>命令行执行lusrmgr.msc</li>
<li>在弹出窗口中选择users，然后选择你要给予权限的用户，点击右键选择properties</li>
<li>选择Member of的选项卡，在其中添加当前用户到某个指定用户组</li>
</ol>
</li>
<li>配置用户组权限<ol>
<li>有些情况下用户组权限是不能访问WinRm的，所以需要修改用户组的权限</li>
<li>执行命令<code>winrm set winrm/config/service @{RootSDDL=&quot;O:NSG:BAD:P(A;;GA;;;BA)(A;;GA;;;S-1-5-32-558)S:P(AU;FA;GA;;;WD)(AU;SA;GWGX;;;WD)&quot;}</code></li>
<li>这个命令是个SID为<code>S-1-5-32-558</code> 的用户组添加WinRm的控制权限</li>
</ol>
</li>
<li>还需要给将这个用户组添加到指定Namespace中<ol>
<li>命令行执行<code>wmimgmt.msc</code></li>
<li>弹出窗口中在 WMI Control上点击右键选择properties</li>
<li>选择Security 选项卡</li>
<li>找到root/cimv2, root, root/mscluster(这个是cluster环境下才有的）</li>
<li>分别选择namespaces 然后选择Security之后添加用户组到里面，并且要给予全部的权限（全部打勾）</li>
</ol>
</li>
<li>用户组额外的权限设置<ol>
<li>如果某些WinRm查询接口无法获得数据，可能是因为权限导致的</li>
<li>使用<code>sc sdshow SCMANAGER</code> 查看当前的权限</li>
<li>使用<code>sc sdset SCMANAGER D:(A;;CCLCRPRC;;;用户组SID)(A;;CC;;;AU)(A;;CCLCRPRC;;;IU)(A;;CCLCRPRC;;;SU)(A;;CCLCRPWPRC;;;SY)(A;;KA;;;BA)S:(AU;FA;KA;;;WD)(AU;OIIOFA;GA;;;WD)</code> 使得用户组获得权限</li>
<li>参考资料：<a href="http://blogs.msmvps.com/erikr/2007/09/26/set-permissions-on-a-specific-service-windows" target="_blank" rel="external">http://blogs.msmvps.com/erikr/2007/09/26/set-permissions-on-a-specific-service-windows</a>, and <a href="http://www.netid.washington.edu/documentation/domains/sddl.aspx" target="_blank" rel="external">http://www.netid.washington.edu/documentation/domains/sddl.aspx</a>.</li>
</ol>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>如何在Windows上配置启用WinRm]]>
    
    </summary>
    
      <category term="编程-网络协议" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM 启动参数设置]]></title>
    <link href="http://luoyuan800.github.io/2015/07/24/jvm-argument/"/>
    <id>http://luoyuan800.github.io/2015/07/24/jvm-argument/</id>
    <published>2015-07-24T08:57:43.000Z</published>
    <updated>2015-07-23T09:32:43.389Z</updated>
    <content type="html"><![CDATA[<p>JVM可以在启动的时候进行配置，大部分时候要进行调节的参数是为了优化运行效率，提升GC机制的执行效率。<br><a id="more"></a></p>
<h2 id="启用参数示例">启用参数示例</h2><pre><code>JAVA_OPTS="-server -XX:+UseParNewGC -Xms1024m -Xmx2048m 
    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxNewSize=</span><span class="number">128</span>m -<span class="constant">XX</span><span class="symbol">:NewSize=</span><span class="number">128</span>m -<span class="constant">XX</span><span class="symbol">:PermSize=</span><span class="number">96</span>m 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxPermSize=</span><span class="number">128</span>m -<span class="constant">XX</span><span class="symbol">:+UseConcMarkSweepGC</span> 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:+CMSPermGenSweepingEnabled</span> -<span class="symbol">verbose:</span>gc 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGCDetails</span> -<span class="constant">XX</span><span class="symbol">:+PrintGCTimeStamps</span> 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:CMSInitiatingOccupancyFraction=</span><span class="number">1</span> -<span class="constant">XX</span><span class="symbol">:+CMSIncrementalMode</span>
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxTenuringThreshold=</span><span class="number">0</span> -<span class="constant">XX</span><span class="symbol">:SurvivorRatio=</span><span class="number">20000</span> 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseCMSCompactAtFullCollection</span> 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:CMSFullGCsBeforeCompaction=</span><span class="number">0</span>  
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:CMSIncrementalDutyCycleMin=</span><span class="number">10</span> -<span class="constant">XX</span><span class="symbol">:CMSIncrementalDutyCycle=</span><span class="number">30</span> 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:CMSMarkStackSize=</span><span class="number">8</span>M -<span class="constant">XX</span><span class="symbol">:CMSMarkStackSizeMax=</span><span class="number">32</span>M<span class="string">"</span></span>
</code></pre><h2 id="参数说明">参数说明</h2><h3 id="-server">-server</h3><p>一定要作为第一个参数，在多个CPU时提升性能（大概就是把JVM做为服务器使用）</p>
<h3 id="-Xmx1280m">-Xmx1280m</h3><p>设置JVM最大可用内存为1280m。最大可设为3550m。具体应用可适当调整。</p>
<h3 id="-Xms1280m">-Xms1280m</h3><p>设置JVM初始内存为1280m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p>
<h3 id="-Xmn480m">-Xmn480m</h3><p>设置年轻代大小为480m。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p>
<h3 id="-Xss256k">-Xss256k</h3><p>设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
<h3 id="-XX:PermSize=64m">-XX:PermSize=64m</h3><p>指定 jvm 中 Perm Generation 的最小值。 这个参数需要看你的实际情况。可以通过jmap 命令看看到底需要多少。</p>
<h3 id="-XX:MaxPermSize=128m">-XX:MaxPermSize=128m</h3><p>指定 Perm Generation 的最大值</p>
<h3 id="-XX:+UseConcMarkSweepGC">-XX:+UseConcMarkSweepGC</h3><p>设置并发收集器</p>
<h3 id="-XX:ParallelGCThreads=8">-XX:ParallelGCThreads=8</h3><p>配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p>
<h3 id="-XX:CMSFullGCsBeforeCompaction=0">-XX:CMSFullGCsBeforeCompaction=0</h3><p>由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</p>
<h3 id="-XX:+UseCMSCompactAtFullCollection">-XX:+UseCMSCompactAtFullCollection</h3><p>打开对年老代的压缩。可能会影响性能，但是可以消除碎片。</p>
<h3 id="-XX:SurvivorRatio=8">-XX:SurvivorRatio=8</h3><p>每个survivor space 和 eden之间的比例。</p>
<h3 id="-XX:MaxTenuringThreshold=7">-XX:MaxTenuringThreshold=7</h3><p>设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。</p>
<h3 id="-XX:GCTimeRatio=19">-XX:GCTimeRatio=19</h3><p>设置垃圾回收时间占程序运行时间的百分比，公式为1/(1+n)。</p>
<h3 id="-Xnoclassgc">-Xnoclassgc</h3><p>禁用类垃圾回收，性能会有一定提高。</p>
<h3 id="-XX:+DisableExplicitGC">-XX:+DisableExplicitGC</h3><p>当此参数打开时，在程序中调用System.gc()将会不起作用。默认是off。</p>
<h3 id="-XX:+UseParNewGC">-XX:+UseParNewGC</h3><p>设置年轻代为并行收集。可与CMS收集同时使用。</p>
<h3 id="-XX:-CMSParallelRemarkEnabled">-XX:-CMSParallelRemarkEnabled</h3><p>在使用 UseParNewGC 的情况下 , 尽量减少 mark 的时间。</p>
<h3 id="-XX:CMSInitiatingOccupancyFraction=70">-XX:CMSInitiatingOccupancyFraction=70</h3><p>指示在 old generation 在使用了 70% 的比例后 , 启动 concurrent collector。</p>
<h3 id="-XX:SoftRefLRUPolicyMSPerMB=0">-XX:SoftRefLRUPolicyMSPerMB=0</h3><p>每兆堆空闲空间中SoftReference的存活时间。</p>
<h3 id="-verbose">-verbose</h3><p>显示垃圾收集信息</p>
<h3 id="-Xloggc:gc-log">-Xloggc:gc.log</h3><p>指定垃圾收集日志文件（记录垃圾回收的日志）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JVM可以在启动的时候进行配置，大部分时候要进行调节的参数是为了优化运行效率，提升GC机制的执行效率。<br>]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM 垃圾回收器]]></title>
    <link href="http://luoyuan800.github.io/2015/07/23/jvm-gc/"/>
    <id>http://luoyuan800.github.io/2015/07/23/jvm-gc/</id>
    <published>2015-07-23T08:57:43.000Z</published>
    <updated>2015-07-23T08:58:31.538Z</updated>
    <content type="html"><![CDATA[<p>简单列举了JVM中使用的集中垃圾收集器<a id="more"></a></p>
<h2 id="新生代收集器">新生代收集器</h2><h3 id="Serial">Serial</h3><p>Serial收集器的机制被称为“Stop the word”。它属于单线程收集器，进行垃圾收集GC的时候会暂停所有的用户线程，采用复制算法进行GC。<br>这个收集器适用于Client端，因为它对于小内存的收集来说尤为高效，停顿时间也比较短。</p>
<h3 id="ParNew">ParNew</h3><p>ParNew收集器同样是使用“Stop the word”机制。但是它是多线程的。如果是运行在多cpu的服务器上的时候，首选这种收集器。</p>
<h3 id="Parallel_Scavenger">Parallel Scavenger</h3><p>这是一个吞吐量优先的垃圾收集器，采用多线程机制。</p>
<h2 id="年老代收集器">年老代收集器</h2><h3 id="Serial_Old">Serial Old</h3><p>和Serial相对应，是年老代收集器，使用单线程的和标记-整理算法进行垃圾回收。</p>
<h3 id="Parallel_Old">Parallel Old</h3><p>是Parallel Scavenge收集器的年老代版本。使用多线程和标记-整理算法，主要是服务端模式下和Parallel Scavenge收集器组合使用。</p>
<h3 id="CMS（Current_Mark_Sweep)">CMS（Current Mark Sweep)</h3><p>CMS是对年老带的进行对象回收，这是一个额外的回收管理机制，基于标记-清除算法实现。它的特点是JVM的停顿时间较短（普通的年老代回收机制就有较长时间的JVM响应停顿），因此CMS主要可以应用于对响应时间有较高要求的服务器上。由于收集完成后会产生碎片，所以要开启 <code>-XXUseCMSCompactAtFullCollection</code>开关参数，表示在Full GC之后，要进行一次碎片整理。开启CMS需要使用额外的参数启用它 ：在启动JVM参数加上<code>-XX:+UseConcMarkSweepGC</code>。</p>
<h4 id="CMS的运作阶段">CMS的运作阶段</h4><p><img src="http://7xk7ce.com1.z0.glb.clouddn.com/cms.png" alt=""></p>
<ul>
<li>初始标记 ：在这个阶段，需要虚拟机停顿正在执行的任务，Stop The Word。这个过程从垃圾回收的”根对象”开始，只扫描到能够和”根对象”直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。</li>
<li>并发标记 ：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。</li>
<li>并发预清理 ：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段”重新标记”的工作，因为下一个阶段会Stop The World。</li>
<li>重新标记 ：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从”根对象”开始向下追溯，并处理对象关联。</li>
<li>并发清理 ：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。</li>
<li>并发重置 ：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。</li>
</ul>
<h3 id="G1(Garbage_First)">G1(Garbage First)</h3><p>G1将整个JAVA堆（包括新生代、老年代）划分为多个固定大小的独立区域，并跟踪垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，有限回收垃圾最多的区域。 它是基于标记-整理算法实现的，并且具有非常准确的控制停顿。</p>
<h2 id="各个收集器的可用组合">各个收集器的可用组合</h2><p>图例表示了各个收集器组合可能性，如果两个收集器之间存在连线，表明他们可以一起组合使用。<br><img src="http://7xk7ce.com1.z0.glb.clouddn.com/relationship.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>简单列举了JVM中使用的集中垃圾收集器]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Java进行文本加密]]></title>
    <link href="http://luoyuan800.github.io/2015/07/22/java-encode/"/>
    <id>http://luoyuan800.github.io/2015/07/22/java-encode/</id>
    <published>2015-07-22T07:58:00.000Z</published>
    <updated>2015-07-22T08:07:29.252Z</updated>
    <content type="html"><![CDATA[<p>通用的加密模式可以分为对称加密、不对称加密、单向加密（不可逆加密）。偶然想要查询下如何在java中进行文本加密，网上搜索到的都是大篇幅介绍加密原理，如何使用却都是一句话带过，真真是看着就烦。所以本文不涉及加密原理和概念，只是列举了如何使用java进行加密的例子，作为参考使用。<a id="more"></a></p>
<h2 id="MD5">MD5</h2><p>不可逆加密指的是使用MD5或者SHA进行加密，其本质是抽取特征码，抽取出来的密文是不可逆向解密回原来的文本的。这种方式大多用于密码的存储——只在数据库中存储抽取的特征码，而不存储原来的密码。</p>
<pre><code>MessageDigest md5 = MessageDigest.getInstance<span class="params">(<span class="string">"MD5"</span>)</span>;
BASE64Encoder base64Encoder = new BASE64Encoder<span class="params">()</span>;
String info = base64Encoder.encode<span class="params">(md5.digest<span class="params">(<span class="string">"luoyuan"</span>.getBytes<span class="params">(<span class="string">"utf-8"</span>)</span>)</span>)</span>;
System.out.println<span class="params">(info)</span>;
</code></pre><p>其中<code>getInstance(String)</code>的取值是限定的，如果传入的不是以下的字符串之一，就会抛出<code>NoSuchAlgorithmException</code></p>
<ul>
<li>MD5</li>
<li>MD2</li>
<li>SHA-1</li>
<li>SHA-256</li>
<li>SHA-384</li>
<li>SHA-512</li>
</ul>
<h2 id="AES">AES</h2><p>AES和DES的使用方式在Java中都差不多，所以不在此处提及DES的使用范例。<br>AES加密方式属于对称加密，加密和解密都需要使用一样的密钥。所以在加密时候使用的密钥要和密文一起发送。</p>
<h3 id="加密">加密</h3><pre><code>String mess = <span class="string">"luoyuan"</span>;
KeyGenerator keyGenerator = KeyGenerator.getInstance<span class="params">(<span class="string">"AES"</span>)</span>;<span class="comment">//获取一个AES相关的KeyGenerator</span>
keyGenerator.init<span class="params">(<span class="number">128</span>)</span>;<span class="comment">//指定生成密钥的长度为128</span>
SecretKey key = keyGenerator.generateKey<span class="params">()</span>;<span class="comment">//生成一个密钥</span>
Cipher cipher = Cipher.getInstance<span class="params">(<span class="string">"AES/ECB/PKCS5Padding"</span>)</span>;<span class="comment">//构建Cipher,设置模式，解密的时候也必须使用同样的模式</span>
cipher.init<span class="params">(Cipher.ENCRYPT_MODE, key)</span>;<span class="comment">//使用生成的密钥初始化</span>
byte[] encode = cipher.doFinal<span class="params">(mess.getBytes<span class="params">(<span class="string">"utf-8"</span>)</span>)</span>;<span class="comment">//执行加密过程</span>
System.out.println<span class="params">(Arrays.toString<span class="params">(encode)</span>)</span>;
</code></pre><h3 id="解密">解密</h3><pre><code>byte[] keyCode = <span class="decorator">{...}</span>;//加密过程生成的密钥的encoded
byte[] data = <span class="decorator">{...}</span>;//加密后的文本字节数组
<span class="type">SecretKey</span> key = new <span class="type">SecretKeySpec</span>(keyCode, <span class="string">"AES"</span>);//根据给出的密钥（字节数组）生成一个<span class="type">Key</span>对象
<span class="type">Cipher</span> cipher = <span class="type">Cipher</span>.getInstance(<span class="string">"AES/ECB/PKCS5Padding"</span>); //生成一个和加密时候使用的模式一样的<span class="type">Cipher</span>
cipher.init(<span class="type">Cipher</span>.<span class="type">DECRYPT_MODE</span>, key);
byte[] decode = cipher.doFinal(data);//执行解密步骤
<span class="type">System</span>.<span class="keyword">out</span>.println(new <span class="type">String</span>(decode));
</code></pre><h2 id="RSA">RSA</h2><p>RSA(DSA)加密属于非对称加密，加密解密过程会使用到不同的密钥——公钥和私钥。<br>如果使用公钥加密，那么解密可以使用私钥解密，如果使用私钥加密，则必须使用公钥进行解密。</p>
<h3 id="加密-1">加密</h3><pre><code>String msg = <span class="string">"Luoyuan"</span>;
KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance<span class="params">(<span class="string">"RSA"</span>)</span>;<span class="comment">//初始化一个KeyPairGenerator</span>
keyGenerator.initialize<span class="params">(<span class="number">1024</span>)</span>;<span class="comment">//设置密钥长度为1024</span>
KeyPair keyPair = keyGenerator.generateKeyPair<span class="params">()</span>;<span class="comment">//RSA加密需要生成相对应的公钥和私钥</span>
RSAPrivateKey privateKey = <span class="params">(RSAPrivateKey)</span> keyPair.getPrivate<span class="params">()</span>;<span class="comment">//获得私钥</span>
RSAPublicKey publicKey = <span class="params">(RSAPublicKey)</span> keyPair.getPublic<span class="params">()</span>;<span class="comment">//获得公钥</span>
Cipher cipher = Cipher.getInstance<span class="params">(<span class="string">"RSA"</span>)</span>;
cipher.init<span class="params">(Cipher.ENCRYPT_MODE, privateKey)</span>;<span class="comment">//使用私钥加密</span>
byte[] encode = cipher.doFinal<span class="params">(msg.getBytes<span class="params">(<span class="string">"utf-8"</span>)</span>)</span>;
System.out.println<span class="params">(Arrays.toString<span class="params">(encode)</span>)</span>;
</code></pre><h3 id="解密-1">解密</h3><pre><code>byte[] publicKeyCode = <span class="decorator">{...}</span>;
byte[] encode = <span class="decorator">{...}</span>;
<span class="type">Cipher</span> cipher = <span class="type">Cipher</span>.getInstance(<span class="string">"RSA"</span>);
<span class="type">RSAPublicKey</span> publicKey = new <span class="type">RSAPublicKeyImpl</span>(publicKeyCode);//根据公钥的encode构建公钥对象
cipher.init(<span class="type">Cipher</span>.<span class="type">DECRYPT_MODE</span>, publicKey);//使用公钥解密
byte[] decode = cipher.doFinal(encode);
<span class="type">System</span>.<span class="keyword">out</span>.println(new <span class="type">String</span>(decode));
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>通用的加密模式可以分为对称加密、不对称加密、单向加密（不可逆加密）。偶然想要查询下如何在java中进行文本加密，网上搜索到的都是大篇幅介绍加密原理，如何使用却都是一句话带过，真真是看着就烦。所以本文不涉及加密原理和概念，只是列举了如何使用java进行加密的例子，作为参考使用。]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则表达式进阶]]></title>
    <link href="http://luoyuan800.github.io/2015/07/15/java-regex/"/>
    <id>http://luoyuan800.github.io/2015/07/15/java-regex/</id>
    <published>2015-07-15T08:19:43.000Z</published>
    <updated>2015-07-23T06:21:35.351Z</updated>
    <content type="html"><![CDATA[<p>正则表达式的作用在我看来是：匹配、查找、替换三种。使用正则表达式也算是粗粗入门了，至少已经可以写一些简单的表达式来进行字符串的匹配了，而且也会从网络上拷贝别人的一些比较复杂的表达式……那么就学习一些进阶的东西吧。包括 捕获组和非捕获组，匹配模式解析。（本文中的正则表达式均是Java中可以使用的格式，<code>\\</code>表示普通正则表达式中的<code>\</code>）<a id="more"></a></p>
<h2 id="组的概念">组的概念</h2><p>首先了解正则表达式中组的概念，在正则表示中组的应用是非常广泛的，只是我们经常没有在意组的真正用法：抽取字符串。一般我们使用正则表达式都只是使用它的匹配功能，只需要验证目标文本是否符合要求。那么如果我们要应用到正则表达式的抽取字符串和替换的时候，组就可以提供我们正确的获得查找结果。<br>Java中组是使用()来表示，一个()表示一个组，在匹配过程中，是依次按照组进行文本匹配，当匹配到当前组之后，就会使用余下的文本来匹配下一个组。</p>
<h3 id="捕获组">捕获组</h3><p>顾名思义，捕获组就是会捕获我们需要匹配的字符串进而提供给我们抽取。<br>如果有一个正则表达<code>(\\w+)(\\d{3}).*</code>，那么这个表达式中包含3个捕获组，分别为代表整个表达式的组0：<code>\\w\\d{3}.*</code> 组1为<code>\\w+</code> 这里表示匹配一个或多个字符，组2为<code>\\d{3}</code>匹配正好3个数字字符。那么我们可以用这个表达式去抽取文本中的连续的三个数字。</p>
<h3 id="非捕获组">非捕获组</h3><p>以上提到的组都是属于捕获组，就是会匹配这个组的字符串，并且抽取到组中。Java中还有非捕获组的概念，即是一个非的概念。以 (<code>?</code>) 开头的组是纯的非捕获组，它不捕获文本，也不针对组合计进行计数。就是说，如果小括号中以?号开头，那么这个分组就不会抽取文本。Java中支持的非捕获组并不多（请忽略专业的概念术语）</p>
<ul>
<li><code>(?=X)</code>     X，通过零宽度的正 lookahead 即左侧匹配</li>
<li><code>(?!X)</code>     X，通过零宽度的负 lookahead 即左侧匹配 </li>
<li><code>(?&lt;=X)</code>     X，通过零宽度的正 lookbehind 即右侧匹配 </li>
<li><code>(?&lt;!X)</code>     X，通过零宽度的负 lookbehind 即右侧匹配 </li>
</ul>
<p>非捕获组中四个表达式的区别：</p>
<ul>
<li><code>(?=X )</code> 和<code>(?!X)</code>用于右侧匹配</li>
<li><code>(?&lt;=X)</code>和<code>(?&lt;!X)</code>用于左侧匹配</li>
</ul>
<p>被非捕获组匹配的到的字符串，最后是不会被抽取出来的。所以非捕获组是应用于更加精确的定位某段字符串而存在的。下面是几个非捕获组的范例<br>匹配用字符串： <code>abc12dd344oo</code></p>
<ul>
<li><code>(?&lt;=abc)(\\d+)</code> 匹配左侧为abc的数字串，分组为组(1) = 12</li>
<li><code>(?&lt;!abc)(\\d+)</code> 匹配左侧不是abc的数字串，分组为组（1） = 2 和 344. 注意这个正则表达式会导致匹配失控，因为可以匹配到的分组有两个。</li>
<li><code>(\\d+)(?=dd)</code> 匹配右侧为dd的数字串， 分组为组（1） = 12</li>
<li><code>(\\d+)(?!dd)</code> 匹配右侧不是dd的数字串， 分组为组（1） = 1 和344. 同样，这个表达式在Java中也是会失控。</li>
</ul>
<h3 id="Java中根据组来抽取字符串">Java中根据组来抽取字符串</h3><p>字符串的抽取需要用到java中的Pattern和Matcher来进行。</p>
<pre><code>Pattern pattern = Pattern.compile<span class="params">(“\\w+<span class="params">(\\d{<span class="number">3</span>})</span>.*”)</span>;
Matcher matcher = pattern.matcher<span class="params">(“aaaa123aaaa”)</span>;
<span class="keyword">if</span><span class="params">(matcher.find<span class="params">()</span>)</span>{
    String nums = matcher.group<span class="params">(<span class="number">1</span>)</span>;
}
</code></pre><p>其中<code>Matcher.group(int)</code>方法中传入的就是这个要查找的组的序号。如果传入的序号大于表达式中组的实际个数，那么会抛出异常。</p>
<h2 id="匹配模式">匹配模式</h2><p>在有了组的基本概念之后，再来讨论Java中的正则表达式在匹配中使用到的三种模式</p>
<h3 id="贪婪模式">贪婪模式</h3><p>没有加上其他模式标识的普通模式就是贪婪模式，在日常应用中我们最常用的模式就贪婪模式。贪婪模式总是尽可能的去匹配文本，以期望能够返回匹配成功。贪婪模式其实效率最为差的一种模式，因为在匹配过程中他首先从整个文本开始进行匹配，然后会大量的回溯文本，并且是一个一个字符进行回溯，越是长的文本，在贪婪模式下匹配效率越差。</p>
<h3 id="勉强模式">勉强模式</h3><p>与贪婪模式相反，该模式是从第一个字符开始向后进行匹配，只是匹配尽量少的文本，所以除非最差的情况下，该模式的匹配次数会比贪婪模式少。勉强模式的标识是在传统的贪婪模式的组表达式后面增加一个<code>?</code> 。</p>
<h3 id="占有模式">占有模式</h3><p>这种模式是Java特有的模式，它只会对整个文本匹配一次，不会回溯。这种模式的速度是最快的，因为只是匹配一次。Java编程思想中提到，这个模式可以防止正则表达式失控，也可以减少匹配过程中因为要保存回溯信息而占用的空间。占有模式的标识是在传统的贪婪模式组表达式后面增加一个<code>+</code> 。</p>
<h3 id="模式在文本匹配中的影响">模式在文本匹配中的影响</h3><p>对应同一个文本，不同的模式会返回不同的匹配结果.假定要分析的字符串是<code>xfooxxxxxxfoo</code>(来源网络）</p>
<ul>
<li>模式<code>.*foo</code> （贪婪模式）: 模式分为子模式<code>p1(.*)</code>和子模式<code>p2(foo)</code>两个部分. 其中p1中的量词匹配方式使用默认方式(贪婪型)。匹配开始时,吃入所有字符<code>xfooxxxxxx</code>去匹配子模式p1。匹配成功,但这样以来就没有了字符串去匹配子模式p2。本轮匹配失败；第二轮：减少p1部分的匹配量，吐出最后一个字符, 把字符串分割成<code>xfooxxxxxxfo</code>和<code>o</code>两个子字符串s1和s2。 s1匹配p1, 但s2不匹配p2。本轮匹配失败；第三轮，再次减少p1部分匹配量，吐出两个字符, 字符串被分割成<code>xfooxxxxxxfo</code>和<code>oo</code>两部分。结果同上。第四轮，再次减少p1匹配量, 字符串分割成<code>xfooxxxxxx</code>和<code>foo</code>两个部分, 这次s1/s2分别和p1/p2匹配。停止尝试,返回匹配成功。</li>
<li>模式<code>.*?foo</code> （勉强模式）: 最小匹配方式。第一次尝试匹配, p1由于是0或任意次，因此被忽略，用字符串去匹配p2,失败；第二次，读入第一个字符<code>x</code>, 尝试和p1匹配, 匹配成功; 字符串剩余部分<code>fooxxxxxxfoo</code>中前三个字符和p2也是匹配的. 因此, 停止尝试, 返回匹配成功。在这种模式下，如果对剩余字符串继续去寻找和模式相匹配的子字符串，还会找到字符串末尾的另一个<code>xfoo</code>，而在贪婪模式下，由于第一次匹配成功的子串就已经是所有字符，因此不存在第二个匹配子串。</li>
<li>模式<code>.*+foo</code> （占有模式）:匹配开始时读入所有字符串, 和p1匹配成功, 但没有剩余字符串去和p2匹配。因此, 匹配失败。返回。</li>
</ul>
<p>再看下面一个例子：贪婪模式与占有模式的比较</p>
<blockquote>
<p>正则：<code>\\w+[a-z]</code>与<code>\\w++[a-z]</code><br>目标串：<code>232hjdhfd7474$</code></p>
</blockquote>
<p>分析:</p>
<ul>
<li><code>\\w+[a-z]</code>：<code>\\w+</code>属于贪婪模式，会一次性吃掉它所能吃掉的所有的字符，也就是子串<code>232hjdhfd7474</code>，此时<code>[a-z]</code>不能够找到匹配了，故<code>\w+</code>匹配的串会吐出一个字符<code>4</code>，但此时还是得不到匹配。反复的这样吐出回退，直到吐出字符<code>d</code>时，此时<code>[a-z]</code>能够匹配h，所以这时正则表达式会返回一次成功的匹配结果，为<code>232hjdhfd</code></li>
<li><code>\\w++[a-z]</code>：<code>\\w++</code>属于侵占模式，它会一次性吃掉它所能够吃掉的所有字符，即子串<code>232hjdhfd7474</code>，而且不留给其他部分使用，故不会回退。此时<code>[a-z]</code>不能够找到匹配，所以此次匹配失败。在余下的子串中也找不到能匹配成功的子串。所以整个正则表达式是找不到匹配结果的！</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>正则表达式的作用在我看来是：匹配、查找、替换三种。使用正则表达式也算是粗粗入门了，至少已经可以写一些简单的表达式来进行字符串的匹配了，而且也会从网络上拷贝别人的一些比较复杂的表达式……那么就学习一些进阶的东西吧。包括 捕获组和非捕获组，匹配模式解析。（本文中的正则表达式均是Java中可以使用的格式，<code>\\</code>表示普通正则表达式中的<code>\</code>）]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux系统中的进程状态]]></title>
    <link href="http://luoyuan800.github.io/2015/07/11/Linux-progress-status/"/>
    <id>http://luoyuan800.github.io/2015/07/11/Linux-progress-status/</id>
    <published>2015-07-11T09:21:15.000Z</published>
    <updated>2015-07-10T09:27:04.348Z</updated>
    <content type="html"><![CDATA[<p>Linux系统进程状态注解<a id="more"></a></p>
<h2 id="Deep_Sleep">Deep Sleep</h2><p>D Uninterruptible sleep (usually IO)<br>不可中断的深度睡眠，一般由IO引起，同步IO在做读或写操作时，此进程不能做其它事情，只能等待，这时进程处于这种状态，如果程序采用异步IO，这种状态应该就很少见到了</p>
<h2 id="Running">Running</h2><p>R Running or runnable (on run queue)<br>进程处于运行或就绪状态</p>
<h2 id="Interrupt">Interrupt</h2><p>S Interruptible sleep (waiting for an event to complete)<br>可接收信号的睡眠状态，sleep函数可演示这种状态</p>
<h2 id="Stop">Stop</h2><p>T Stopped, either by a job control signal or because it is being traced.<br>被ctrl+z中断或被trace</p>
<h2 id="Paging">Paging</h2><p>W paging (not valid since the 2.6.xx kernel) </p>
<h2 id="Dead">Dead</h2><p>X dead (should never be seen)<br>进程已经完全死掉，不可能看见这种状态的</p>
<h2 id="Zombie">Zombie</h2><p>Z Defunct (“zombie”) process, terminated but not reaped by its parent.<br>进程已经终止，但是其父进程没有来及处理它，多进程写不好的话，这种状态是常见的</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Linux系统进程状态注解]]>
    
    </summary>
    
      <category term="编程-Linux" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux的分区]]></title>
    <link href="http://luoyuan800.github.io/2015/07/10/Linux-partition/"/>
    <id>http://luoyuan800.github.io/2015/07/10/Linux-partition/</id>
    <published>2015-07-10T08:47:16.000Z</published>
    <updated>2015-07-10T09:27:04.345Z</updated>
    <content type="html"><![CDATA[<p>简单了解Linux文件系统的管理（磁盘管理）。<a id="more"></a></p>
<h2 id="设备管理">设备管理</h2><p>在 Linux 中，每一个硬件设备都映射到一个系统的文件，对于硬盘、光驱等 IDE 或 SCSI 设备也不例外。Linux把各种 IDE 设备分配了一个由 hd 前缀组成的文件；而对于各种 SCSI 设备，则分配了一个由 sd 前缀组成的文件。<br>对于ide硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指ide硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“~”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个ide硬盘上的第三个主分区或扩展分区,hdb2表示为第二个ide硬盘上的第二个主分区或扩展分区。对于scsi硬盘则标识为“sdx~”，scsi硬盘是用“sd”来表示分区所在设备的类型的，其余则和ide硬盘的表示方法一样，不在多说。<br>例如，第一个 IDE 设备，Linux 就定义为 hda；第二个 IDE 设备就定义为 hdb；下面以此类推。而 SCSI 设备就应该是 sda、sdb、sdc 等。</p>
<h2 id="分区编号">分区编号</h2><p>要进行分区就必须针对每一个硬件设备进行操作，这就有可能是一块IDE硬盘或是一块SCSI硬盘。对于每一个硬盘（IDE 或 SCSI）设备，Linux 分配了一个 1 到 16 的序列号码，这就代表了这块硬盘上面的分区号码。</p>
<ul>
<li>例如，第一个 IDE 硬盘的第一个分区，在 Linux 下面映射的就是 hda1，第二个分区就称作是 hda2。</li>
<li>对于SCSI 硬盘则是 sda1、sdb1 等。</li>
</ul>
<h2 id="分区的作用">分区的作用</h2><p>在 Linux 中规定，每一个硬盘设备最多能有 4个主分区（其中包含扩展分区）构成，任何一个扩展分区都要占用一个主分区号码，也就是在一个硬盘中，主分区和扩展分区一共最多是 4 个。</p>
<blockquote>
<p>对于早期的 DOS 和 Windows（Windows 2000 以前的版本），系统只承认一个主分区，可以通过在扩展分区上增加逻辑盘符（逻辑分区&gt;&gt;的方法，进一步地细化分区。</p>
</blockquote>
<h3 id="主分区">主分区</h3><p>主分区的作用就是计算机用来进行启动操作系统的，因此每一个操作系统的启动，或者称作是引导程序，都应该存放在主分区上。这就是主分区和扩展分区及逻辑分区的最大区别。我们在指定安装引导 Linux 的 bootloader 的时候，都要指定在主分区上，就是最好的例证。<br>Linux 规定了主分区（或者扩展分区）占用 1 至 16 号码中的前 4 个号码。以第一个 IDE 硬盘为例说明，主分区（或者扩展分区）占用了 hda1、hda2、hda3、hda4，而逻辑分区占用了 hda5 到 hda16 等 12 个号码。因此，Linux 下面每一个硬盘总共最多有 16 个分区。</p>
<h3 id="扩展分区">扩展分区</h3><p>除了主分区占用的空间，余下的空间划分出来的分区都被称为扩展分区。</p>
<h3 id="逻辑分区">逻辑分区</h3><p>对于逻辑分区，Linux 规定它们必须建立在扩展分区上（在 DOS 和 Windows 系统上也是如此规定），而不是主分区上。因此，我们可以看到扩展分区能够提供更加灵活的分区模式，但不能用来作为 操作系统 的引导。 除去上面这些各种分区的差别，我们就可以简单地把它们一视同仁了。</p>
<h2 id="分区指标">分区指标　　</h2><p>对于每一个 Linux 分区来讲，分区的大小和分区的类型是最主要的指标。分区的类型规定了这个分区上面的文件系统的格式。<br>Linux 支持多种的文件系统格式，其中包含了我们熟悉的FAT32、FAT16、NTFS、HP-UX，以及各种 Linux 特有的 Linux Native和 Linux Swap分区类型。在 Linux 系统中，可以通过分区类型号码来区别这些不同类型的分区。可以参考我的另外一篇博文来了解Linux分区的类型（也可以称为文件系统类型）<a href="/2015/07/01/linux-filesystem-types/" title="Linux文件系统类型">Linux文件系统类型</a>。</p>
<h2 id="常用分区介绍">常用分区介绍</h2><ul>
<li>/boot分区，它包含了操作系统的内核和在启动系统过程中所要用到的文件，建这个 分区是有必要的，因为目前大多数的pc机要受到bios的限制,况且如果有了一个单独的/boot启动分区，即使主要的根分区出现了问题，计算机依然能够 启动。这个分区的大小约在50mb—100mb之间。但是如果想用lilo启动red hat linux系统的话，含有/boot的分区必须完全在柱面1023以下。又由于8gb后的数据lilo不能读取，所以red hat - linux要安装在8gb的区域以内。</li>
<li>/usr分区，是red hat linux系统存放软件的地方，如有可能应将最大空间分给它。</li>
<li>/home分区，是用户的home目录所在地，这个分区的大小取决于有多少用户。如 果是多用户共同使用一台电脑的话，这个分区是完全有必要的，况且根用户也可以很好地控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普 通用户访问哪些文件等。其实单用户也有建立这个分区的必要，因为没这个分区的话，那么你只能以根用户的身份登陆系统，这样做是危险的，因为根用户对系统有 绝对的使用权，可一旦你对系统进行了误操作，麻烦也就来了。</li>
<li>/var/log分区，是系统日志记录分区，如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，它们也不会影响到操作系统的主分区。</li>
<li>/tmp分区，用来存放临时文件。这对于多用户系统或者网络服务器来说是有必要的。 这样即使程序运行时生成大量的临时文件，或者用户对系统进行了错误的操作，文件系统的其它部分仍然是安全的。因为文件系统的这一部分仍然还承受着读写操 作，所以它通常会比其它的部分更快地发生问题。</li>
<li>/bin分区，存放标准系统实用程序。</li>
<li>/dev分区，存放设备文件。</li>
<li>/opt分区，存放可选的安装的软件。</li>
<li>/sbin分区，存放标准系统管理文件。</li>
</ul>
<p>上面介绍了几个常用的分区，一般来说我们需要一个swap分区，一个/boot分区，一个/usr分区，一个/home 分区，一个/var/log分区。当然这没有什么规定，完全是依照你个人来定的。但记住至少要有两个分区，一个swap分区，一个/分区。</p>
<h2 id="查看分区的常用命令">查看分区的常用命令</h2><h3 id="mount">mount</h3><p>mount命令用来查看那些已经分配了mountpoint的文件系统</p>
<pre><code>:~$ mount
/dev/sda1 on / <span class="keyword">type</span> ext4 (rw,errors=remount-ro,user_xattr)
<span class="keyword">proc</span> on /<span class="keyword">proc</span> <span class="keyword">type</span> <span class="keyword">proc</span> (rw,noexec,nosuid,nodev)
none on /sys <span class="keyword">type</span> sysfs (rw,noexec,nosuid,nodev)
none on /sys/fs/fuse/connections <span class="keyword">type</span> fusectl (rw)
none on /sys/kernel/debugtype debugfs (rw)
none on /sys/kernel/security <span class="keyword">type</span> securityfs (rw)
none on /dev <span class="keyword">type</span> devtmpfs (rw,mode=<span class="number">0755</span>)
none on /dev/pts <span class="keyword">type</span> devpts (rw,noexec,nosuid,gid=<span class="number">5</span>,mode=<span class="number">0620</span>)
none on /dev/shm <span class="keyword">type</span> tmpfs (rw,nosuid,nodev)
none on /<span class="keyword">var</span>/runtype tmpfs (rw,nosuid,mode=<span class="number">0755</span>)
none on /<span class="keyword">var</span>/lock <span class="keyword">type</span> tmpfs (rw,noexec,nosuid,nodev)
none on /lib/init/rw <span class="keyword">type</span> tmpfs (rw,nosuid,mode=<span class="number">0755</span>)
none on /<span class="keyword">var</span>/lib/ureadahead/debugfs <span class="keyword">type</span> debugfs (rw,relatime)
none on /<span class="keyword">proc</span>/fs/vmblock/mountPoint <span class="keyword">type</span> vmblock (rw)
binfmt_misc on /<span class="keyword">proc</span>/sys/fs/binfmt_misc <span class="keyword">type</span> binfmt_misc (rw,noexec,nosuid,nodev)
gvfs-fuse-daemon on /home/kysnail/.gvfs <span class="keyword">type</span> fuse.gvfs-fuse-daemon (rw,nosuid,nodev,user=kysnail)
</code></pre><h3 id="df">df</h3><p>df命令可以查看文件系统的分区大小， 使用-l参数可以只参看本地文件系统。</p>
<pre><code>:~$ df -lhT
文件系统      类型    容量  已用 可用 已用% 挂载点
/dev/sda1     ext4     19G   11G  <span class="number">7</span>.8G  <span class="number">57</span>% /
<span class="keyword">none</span>      devtmpfs    498M  248K  497M   <span class="number">1</span>% /dev
<span class="keyword">none</span>         tmpfs    502M  252K  501M   <span class="number">1</span>% /dev/shm
<span class="keyword">none</span>         tmpfs    502M   96K  502M   <span class="number">1</span>% /<span class="keyword">var</span>/run
<span class="keyword">none</span>         tmpfs    502M     <span class="number">0</span>  502M   <span class="number">0</span>% /<span class="keyword">var</span>/lock
<span class="keyword">none</span>         tmpfs    502M     <span class="number">0</span>  502M   <span class="number">0</span>% /lib/<span class="keyword">init</span>/rw
<span class="keyword">none</span>       debugfs     19G   11G  <span class="number">7</span>.8G  <span class="number">57</span>% /<span class="keyword">var</span>/lib/ureadahead/debugfs
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>简单了解Linux文件系统的管理（磁盘管理）。]]>
    
    </summary>
    
      <category term="编程-Linux" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown 语法说明]]></title>
    <link href="http://luoyuan800.github.io/2015/07/07/Markdown/"/>
    <id>http://luoyuan800.github.io/2015/07/07/Markdown/</id>
    <published>2015-07-07T02:51:34.000Z</published>
    <updated>2015-07-07T07:14:19.327Z</updated>
    <content type="html"><![CDATA[<p>Markdown是一种标记语言，主要用于网页上文本格式设置。它的使得我们可以使用普通的文本编辑器编辑网页文本。在页面显示用Markdown语法的文本，需要先转换为HTML格式再进行显示。Markdown使得普通文本和网页文本通过一种简单的格式关联了起来，文本编辑者不在需要了解复杂的HTML标签。同时，你也可以在Markdown格式的文本中使用HTML标签，这样可以补全一些Markdown语法不具备的功能，比如文字的显示颜色。<br>本文中不会对Markdown语法转换原理和转换后的HTML标签进行说明，只会列举Markdown的格式显示效果。<br><a id="more"></a></p>
<h2 id="我为什么要用Markdown">我为什么要用Markdown</h2><p>因为我搭建的博客支持使用Markdown来构建博文，并且Markdown作为一种标记语言学习简单，而且作为程序员，使用标记语言来写作会更加符合那种高逼格与众不同的形象~</p>
<h2 id="标题">标题</h2><p>Markdown中的标题使用<code>#</code>进行标识， Markdown支持六级标题，标题1可以作为文本题目的显示，标题2后会跟一个下划线（HEXO搭建的博客支持Markdown语法写的文本，并且会根据标题格式生成博文目录，不过只会支持从标题2开始的标题）。</p>
<pre><code><span class="preprocessor"># 标题1</span>
<span class="preprocessor">## 标题2</span>
<span class="preprocessor">### 标题3</span>
<span class="preprocessor">#### 标题4</span>
<span class="preprocessor">##### 标题5</span>
<span class="preprocessor">###### 标题6</span>
</code></pre><p>以上文本的显示效果为</p>
<p><img src="http://7xk7ce.com1.z0.glb.clouddn.com/head.png" alt=""></p>
<h2 id="文字格式">文字格式</h2><ul>
<li><p>斜体。<code>*斜体*</code> 显示为 <em>斜体</em></p>
</li>
<li><p>粗体。<code>**粗体**</code> 显示为 <strong>粗体</strong></p>
</li>
</ul>
<h2 id="文本块">文本块</h2><h3 id="引用文本块">引用文本块</h3><p>强调引用的文本格式是一个文本块，使用>开头的文本会被显示为文本块</p>
<pre><code>&gt;这是一个
&gt;引用的文本
</code></pre><p>会被显示为</p>
<blockquote>
<p>这是一个<br>引用的文本</p>
</blockquote>
<h3 id="代码块">代码块</h3><p>代码块有三种</p>
<ul>
<li><p>一种是插入到文本中的<code>这是一小节代码</code>，使用的格式为</p>
<pre><code><span class="escape">`这</span>是一小节代码`
</code></pre></li>
<li><p>一种是一整段的代码，这个整段代码的格式和特殊字符都会保留而不会被转换。每一行的文本前面增加缩进可以实现代码块的显示，可以缩进一个，也可以缩进两个。</p>
<pre><code><span class="variable">&lt;Tab缩进&gt;</span>public CmdLineDiskMetrics(AbstractUnixCollector execWrapper, LogService <span class="keyword">log</span>Service,
<span class="variable">&lt;Tab缩进&gt;</span>                          UnixAgentPropertyWrapper properties) {
<span class="variable">&lt;Tab缩进&gt;</span>mExecWrapper = execWrapper;
<span class="variable">&lt;Tab缩进&gt;</span>mLogger = <span class="keyword">log</span>Service.getLogger(CmdLineDiskMetrics.class);
<span class="variable">&lt;Tab缩进&gt;</span>mStringUtils = new StringUtils(<span class="keyword">log</span>Service, CmdLineDiskMetrics.class.getName());
<span class="variable">&lt;Tab缩进&gt;</span>mProperties = properties;
<span class="variable">&lt;Tab缩进&gt;</span>mIsDebugEnable = mLogger.getDebugLevel() &gt;= <span class="number">1</span>;
<span class="variable">&lt;Tab缩进&gt;</span>
<span class="variable">&lt;Tab缩进&gt;</span>mHostResolver = new HostNameResolver(<span class="keyword">log</span>Service, execWrapper.getServices().getResolverService());
<span class="variable">&lt;Tab缩进&gt;</span>}
</code></pre><p>会被显示成</p>
<pre><code>public <span class="type">CmdLineDiskMetrics</span>(<span class="type">AbstractUnixCollector</span> execWrapper, <span class="type">LogService</span> logService,
                      <span class="type">UnixAgentPropertyWrapper</span> properties) {
mExecWrapper = execWrapper;
mLogger = logService.getLogger(<span class="type">CmdLineDiskMetrics</span>.<span class="keyword">class</span>);
mStringUtils = <span class="keyword">new</span> <span class="type">StringUtils</span>(logService, <span class="type">CmdLineDiskMetrics</span>.<span class="keyword">class</span>.getName<span class="literal">()</span>);
mProperties = properties;
mIsDebugEnable = mLogger.getDebugLevel<span class="literal">()</span> &gt;= <span class="number">1</span>;

mHostResolver = <span class="keyword">new</span> <span class="type">HostNameResolver</span>(logService, execWrapper.getServices<span class="literal">()</span>.getResolverService<span class="literal">()</span>);
}
</code></pre></li>
<li><p>命令行格式的代码需要使用bash格式来显示，这样的格式会在每一条命令前面加上序号</p>
<p>  ````bash<br>  $ commond1<br>  $ commond2<br>  ````<br>会显示成</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ commond1</span><br><span class="line">$ commond2</span><br></pre></td></tr></table></figure>
<h2 id="表格">表格</h2><p>Markdown中使用形象的格式来表示表格（表格和上一个文本之间需要有一个空行分隔）</p>
<pre><code>|<span class="string">标题1</span>|<span class="string">标题2</span>|
|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">    #这一行是用来定义表格的对齐方式的        
</span>|<span class="string">第一格</span>|<span class="string">第二格</span>|
|<span class="string">第三格</span>|<span class="string">第四格</span>|
</code></pre><p>会显示一个如下的表格</p>
<table>
<thead>
<tr>
<th>标题1</th>
<th>标题2</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一格</td>
<td>第二格</td>
</tr>
<tr>
<td>第三格</td>
<td>第四格</td>
</tr>
</tbody>
</table>
<p>表格的对齐方式是通过表格标题下方的第二行|——|——-|来定义的</p>
<ul>
<li><code>----</code>表示左对齐</li>
<li><code>-----：</code>表示右对齐</li>
<li><code>：----：</code>表示居中对齐</li>
</ul>
<h2 id="超链接">超链接</h2><p>定义一个超链接使用一下格式</p>
<pre><code>[<span class="link_label">Yuan</span>](<span class="link_url">http://luoyuan800.github.io "Yuan-Blog"</span>)
</code></pre><p>[]内的是要显示的文本，而()的前半部分是连接的地址，后半部分则是鼠标移动到链接上面要显示的内容。<br>最后的显示结果为 <a href="http://luoyuan800.github.io" title="Yuan-Blog">Yuan</a></p>
<h2 id="图片">图片</h2><p>图片的格式和超链接是一样的，不同的地方是，在[]要留空，之后的()中只需要填入图片的网址即可</p>
<pre><code>!<span class="attr_selector">[]</span>(<span class="attribute">http</span>:<span class="comment">//7xk7ce.com1.z0.glb.clouddn.com/head.png)</span>
</code></pre><h2 id="特殊字符">特殊字符</h2><p>如果要正常显示特殊字符，需要在其前面使用<code>\</code>标识，这样的话特殊字符就不会被转换。特殊字符包括：</p>
<pre><code><span class="change">!</span>
`
&gt;
\
&lt;
[
]
(
)
*
<span class="addition">+</span>
<span class="deletion">-</span>
_
.
</code></pre><p>如果是要同时显示括号的话只需要在后一个括号前面加上<code>\</code> 如：</p>
<pre><code>(<span class="string">\)</span>  [<span class="string">\]</span> &lt;<span class="string">\&gt;</span> 
</code></pre><p>会显示成<br>() [] &lt;></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Markdown是一种标记语言，主要用于网页上文本格式设置。它的使得我们可以使用普通的文本编辑器编辑网页文本。在页面显示用Markdown语法的文本，需要先转换为HTML格式再进行显示。Markdown使得普通文本和网页文本通过一种简单的格式关联了起来，文本编辑者不在需要了解复杂的HTML标签。同时，你也可以在Markdown格式的文本中使用HTML标签，这样可以补全一些Markdown语法不具备的功能，比如文字的显示颜色。<br>本文中不会对Markdown语法转换原理和转换后的HTML标签进行说明，只会列举Markdown的格式显示效果。<br>]]>
    
    </summary>
    
      <category term="网站-语言" scheme="http://luoyuan800.github.io/categories/%E7%BD%91%E7%AB%99-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SNMP框架介绍（基于snmp4j）]]></title>
    <link href="http://luoyuan800.github.io/2015/07/06/SNMP-snmp4j/"/>
    <id>http://luoyuan800.github.io/2015/07/06/SNMP-snmp4j/</id>
    <published>2015-07-06T09:58:14.000Z</published>
    <updated>2015-07-10T01:31:41.012Z</updated>
    <content type="html"><![CDATA[<p>基于snmp4j实现的一个SNMP框架，目的是简化snmp的开发流程，只需要使用几个简单的类就可以实现通过snmp协议收集数据，也可以作为一个snmp4j的使用范例进行参考。基于Apache2.0协议开放源代码。<br><a id="more"></a></p>
<h2 id="项目介绍">项目介绍</h2><h3 id="源码地址">源码地址</h3><p><a href="https://github.com/luoyuan800/SNMP" target="_blank" rel="external">https://github.com/luoyuan800/SNMP</a></p>
<h3 id="jar包下载">jar包下载</h3><p>暂无，请下载源码后自行构建。</p>
<h3 id="Javadoc地址">Javadoc地址</h3><p><a href="http://luoyuan800.github.io/javadocs/snmp/">http://luoyuan800.github.io/javadocs/snmp/</a></p>
<h3 id="项目解析">项目解析</h3><pre><code>SNMPCore
    ├── build<span class="class">.gradle</span>
    └── src
        └── ly
            └── snmp
                └── core
                    │── model -----------------------------------------<span class="id">#A</span>
                    │── monitor ---------------------------------------<span class="id">#B</span>   
                    │── policy  ---------------------------------------<span class="id">#C</span>
                    │── sample ----------------------------------------<span class="id">#D</span>
                    │── service ---------------------------------------<span class="id">#E</span>
                    │── snmputil --------------------------------------<span class="id">#F</span>
                    └── tool ------------------------------------------<span class="id">#G</span>
SNMPUI ----------------------------------------------------------------#H
</code></pre><p>#A 基本的数据结构定义在这个包里面<br>#B OID集合定义在这个包里面， OID的集合是指要一起收集的一组OID，比如要收集CPU或者Network相关的数据，需要一组OID同时收集回来然后进行计算。<br>#C 对数据进行管理的策略定义（当整合数据库之后可以用，用来减少数据的存储量，目前暂未实现）<br>#D 范例代码<br>#E 管理类定义在这个包中，用来管理数据对象<br>#F SNMP的底层基本组件实现<br>#G 一些通用的工具类<br>#H 一个网页版的使用范例（构建中）</p>
<h3 id="构建jar包与javadoc">构建jar包与javadoc</h3><p>该项目使用gradle进行编译和构建，下载源代码之后需要先安装<a href="/2015/07/03/gradle/" title="Gradle使用入门">Gradle</a>，然后在项目的根目录下执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradle build</span><br><span class="line">gradle javaDoces</span><br></pre></td></tr></table></figure>
<p>生成的jar包存放在build/libs目录下<br>生成的javadoc存放在build/doces/javadoc目录下。</p>
<h2 id="如何使用">如何使用</h2><h3 id="开发环境构建">开发环境构建</h3><p>将构建好的SNMPCore-1.0.0.jar引入你的工程Class-path，就可以直接使用相关的代码了。</p>
<h3 id="初始化代码">初始化代码</h3><pre><code>SNMPParameter parameter = new SNMPParameter<span class="params">()</span>;<span class="comment">//初始化SNMP的参数</span>
parameter.setCommunity<span class="params">(<span class="string">"public"</span>)</span>;
parameter.setVersion<span class="params">(SNMPVersion.V1)</span>;
parameter.setPort<span class="params">(<span class="number">163</span>)</span>;
</code></pre><h3 id="构建监控对象">构建监控对象</h3><pre><code>Device device = new Device<span class="params">(<span class="string">"127.0.0.1"</span>)</span>;<span class="comment">//Device对象就是监控对象的一个实现</span>
Oid oid = new Oid<span class="params">(<span class="string">"1.3.6.1.2.1.2.1"</span>)</span>;<span class="comment">// 这里是构建需要收集数据的OID对象</span>
device.addOids<span class="params">(oid)</span>;
device.initDevice<span class="params">(parameter)</span>; <span class="comment">//使用init方法初始化这个监控对象</span>
</code></pre><h3 id="获取SNMP数据">获取SNMP数据</h3><pre><code>device.doCollection<span class="params">()</span>;<span class="comment">//调用这个方法之后就会触发SNMP的收集过程</span>
</code></pre><p>在<code>doCollection</code>方法执行完成后就可以从Device对象中读取采集回来的结果了</p>
<ul>
<li>如果是要获取特定OID对象的数值，收集结果完成之后，对应的OID对象中就会有收集回来的数值了，可以直接从OID通过<code>OID.getValue()</code>获取采集到的结果</li>
<li>如果是使用数据集合，也是可以直接从那个数据集合中直接获取到结果（参见范例）。</li>
</ul>
<h3 id="采集table_oid对象">采集table oid对象</h3><pre><code>TableOid table = new TableOid<span class="params">(<span class="string">"1.3.6.1.2.1.2.2"</span>, <span class="string">"1.3.6.1.2.1.2.2.1.2"</span>,<span class="string">"1.3.6.1.2.1.2.2.1.5"</span>,<span class="string">"1.3.6.1.2.1.2.2.1.3"</span>)</span>;
device.addOids<span class="params">(table)</span>;
device.doCollection<span class="params">()</span>;
<span class="keyword">for</span><span class="params">(TableColumnOid column : table.getColumns<span class="params">()</span>)</span>{
    <span class="keyword">for</span><span class="params">(String index : column.getIndex<span class="params">()</span>)</span>{
        System.out.println<span class="params">(column.getValue<span class="params">(index)</span>)</span>;
    }
}
</code></pre><p>因为table结构的特殊性，需要使用index来标识column中的一个单元格数据。所以在采集了table的数据之后，我们需要首先获取到colum（一行）的对象，然后根据这个对象中的index来获取具体单元格的数据。</p>
<h3 id="snmpv3数据采集">snmpv3数据采集</h3><pre><code>Device device = new Device<span class="params">(<span class="string">"127.0.0.1"</span>)</span>;
Oid oid = new Oid<span class="params">(<span class="string">"1.3.6.1.2.1.2.1"</span>)</span>;
device.addOids<span class="params">(oid)</span>;
SNMPParameter parameter = new SNMPParameter<span class="params">()</span>;
parameter.setUserName<span class="params">(<span class="string">"shaDes"</span>)</span>;
parameter.setVersion<span class="params">(SNMPVersion.V3)</span>;
parameter.setAuthentication<span class="params">(<span class="string">"1234567890"</span>)</span>;
parameter.setPrivacy<span class="params">(<span class="string">"1234567890"</span>)</span>;
parameter.setAuthProtocol<span class="params">(Protocol.AuthSHA)</span>;
parameter.setPrivacyProtocol<span class="params">(Protocol.PrivDES)</span>;
device.initDevice<span class="params">(parameter)</span>;
device.doCollection<span class="params">()</span>;
System.out.print<span class="params">(device.getOids<span class="params">()</span>)</span>;
</code></pre><h3 id="自定义采集Oid集合">自定义采集Oid集合</h3><p>有些监控数据的采集需要集合多个OID对象一起通过计算获取，那么我们可以使用数据集合对象<code>Monitor</code>来组织这些OID。在你的项目代码中实现一个<code>Monitor</code>的子类，然后其中实现计算过程，最后，对于最上层的用户来说可以完全屏蔽掉OID，只需要直接获取计算的结果展示就可以了。<br>内置实现了CPU, Memory, Network, Disk，SystemInfo可以直接使用或者作为实现其他集合的参考范例。当然，如果需要扩展内置的几个基本监控集合，可以实现相应集合的子类，从而实现扩展的目的。</p>
<pre><code>device.addMonitor(<span class="keyword">new</span> <span class="type">CPU</span><span class="literal">()</span>);
device.addMonitor(<span class="keyword">new</span> <span class="type">Disk</span><span class="literal">()</span>);
device.addMonitor(<span class="keyword">new</span> <span class="type">Memory</span><span class="literal">()</span>);
device.addMonitor(<span class="keyword">new</span> <span class="type">Network</span><span class="literal">()</span>);
device.addMonitor(<span class="keyword">new</span> <span class="type">SystemInfo</span><span class="literal">()</span>);
device.doCollection<span class="literal">()</span>;
<span class="type">CPU</span> cpu = device.getMonitor(<span class="type">CPU</span>.<span class="keyword">class</span>);
<span class="type">Memory</span> memory = device.getMonitor(<span class="type">Memory</span>.<span class="keyword">class</span>);
<span class="type">Disk</span> disk = device.getMonitor(<span class="type">Disk</span>.<span class="keyword">class</span>);
...
</code></pre><h2 id="一个简单的范例">一个简单的范例</h2><pre><code><span class="comment">/*
 * DeviceSample.java
 * Date: 5/21/2015
 * Time: 2:18 PM
 * 
 * Copyright 2015 luoyuan.
 * ALL RIGHTS RESERVED.
*/</span>

package ly.snmp.core.sample;

<span class="keyword">import</span> ly.snmp.core.model.Device;
<span class="keyword">import</span> ly.snmp.core.model.Oid;
<span class="keyword">import</span> ly.snmp.core.model.SNMPParameter;
<span class="keyword">import</span> ly.snmp.core.model.SNMPVersion;
<span class="keyword">import</span> ly.snmp.core.monitor.Memory;
<span class="keyword">import</span> ly.snmp.core.monitor.Monitor;

<span class="keyword">import</span> java.io.IOException;

<span class="comment">/**
 * This is a sample for how to use this snmp framework to collect snmp data
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">DeviceSample</span> </span>{
    public static final <span class="built_in">String</span> ip = <span class="string">"127.0.0.1"</span>;
    public static <span class="keyword">void</span> main(<span class="built_in">String</span>...args) throws IOException {
        Device device = <span class="keyword">new</span> Device(ip);
        SNMPParameter parameter = <span class="keyword">new</span> SNMPParameter();
        parameter.setVersion(SNMPVersion.V1);
        <span class="comment">//parameter.setPort(163);//Default is 163</span>
        parameter.setCommunity(<span class="string">"public"</span>);
        device.initDevice(parameter);
        <span class="comment">//Will collect memory data</span>
        Monitor monitor = <span class="keyword">new</span> Memory();
        device.addMonitor(monitor);
        <span class="comment">//Add special oid for collect</span>
        Oid oid = <span class="keyword">new</span> Oid(<span class="string">"1.3.6.1.2.1.1.1"</span>);
        device.addOids(oid);
        device.doCollection();
        <span class="comment">/*//Now we can get those snmp data from device
        Memory memory = device.getMonitor(Memory.class);
        System.out.println(memory.getTotalSize());
        System.out.println(memory.getUsed());
        System.out.println(oid.getValue());
        */</span>
    }
}
</code></pre><h2 id="谢谢使用">谢谢使用</h2><p>欢迎您的建议和修改</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>基于snmp4j实现的一个SNMP框架，目的是简化snmp的开发流程，只需要使用几个简单的类就可以实现通过snmp协议收集数据，也可以作为一个snmp4j的使用范例进行参考。基于Apache2.0协议开放源代码。<br>]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Log4J中的继承关系]]></title>
    <link href="http://luoyuan800.github.io/2015/07/06/Log4J-Inherit/"/>
    <id>http://luoyuan800.github.io/2015/07/06/Log4J-Inherit/</id>
    <published>2015-07-06T01:06:35.000Z</published>
    <updated>2015-07-06T01:30:42.264Z</updated>
    <content type="html"><![CDATA[<p>Java代码中可以通过继承关系来扩展类的功能，在Log4J也有类似的机制。<br><a id="more"></a></p>
<h2 id="Logger的理解">Logger的理解</h2><p>在log4j的使用中，我们是使用<code>Logger.getLogger(name)</code>来获取Logger实例，这里的Logger实例中的名字是有name来指定，这个那么就限定了我们这个logger会使用什么配置。个人的理解是，在log4j中的Logger的实例是根据名字来唯一存在的，一个名字只会存在一个Logger实例。大概可以这样理解，每一个<code>getLogger</code>返回的都是Logger的一个子类，这个子类是静态，每个子类之间是根据名字来区分的。</p>
<h2 id="继承关系">继承关系</h2><h3 id="父类">父类</h3><p>既然是继承，那么需要一个父类，Logger是不能直接实例化，而我们可以通过<code>Logger.getRootLogger()</code>方式来取一个名字标识为rootLogger的Logger子类，这个类我们可以看做其他Logger子类的父类，所有的Logger子类都会继承自它。</p>
<h3 id="用户自定义的Logger">用户自定义的Logger</h3><p>用户自定义的Logger其实际意义就是指定Log4J生成一个指定名称和配置的子类。<br>比如在<em>log4j.properties</em>文件中定义了这么一句</p>
<pre><code>log4j<span class="class">.logger</span><span class="class">.father</span>=DEBUG, fatherConfig
</code></pre><p>那么这句话的意思是说定义一个名字为father的logger类，在代码中可以通过<code>Logger.getLogger(“father”);</code> 来获取这个father对应Logger类。那如果我们需要定义一个这个father的子类就应该：</p>
<pre><code>log4j<span class="class">.logger</span><span class="class">.father</span><span class="class">.children</span>=INFO,childrenConfig
</code></pre><p>那么在定义上这个father.children就是一个子类，并且获取方式为：</p>
<pre><code><span class="tag">Logger</span><span class="class">.getLogger</span>(“<span class="tag">father</span><span class="class">.children</span>”);
</code></pre><h3 id="代码中直接定义子类">代码中直接定义子类</h3><p>即使没有在配置文件中显示的写出子类的定义，我们也可以在代码中通过名称来指定logger实例的继承关系：</p>
<pre><code><span class="tag">Logger</span><span class="class">.getLogger</span>(“<span class="tag">father</span><span class="class">.children</span><span class="class">.children</span>”);
</code></pre><p>上面这个语句就使得我们获得了一个继承自father.children的子类father.children.children。</p>
<h2 id="继承关系的用处">继承关系的用处</h2><p>继承的存在对我们最显著的影响是什么呢？</p>
<ul>
<li><p>个人理解是记录到子类上的log也会被父类接收！是的，正常情况，如果使用子类的实例记录一个log信息，那么这个子类的所有父类都会接收到log信息并且记录。如果我们把子类和父类的输出目的地都设置为一样，那么就会发现重复的log信息。<br>比如我们使用以下代码段，并且把<code>father，father.children</code>的输出<em>appender</em>都设置为控制台输出(org.apache.log4j.ConsoleAppender)</p>
<pre><code>Logger logger=Logger.getLogger(“father.children.children”)<span class="comment">;</span>
Logger.info(“这是一个子类的子类log信息”)<span class="comment">;</span>
</code></pre><p>我们可以在控制台看到3条log信息，分别是由<em>father.children.children、father.children、father</em>上log进行了输出。<br>这里要注意，father的级别被定义为DEBUG，但是我们输出的INFO信息页被father记录了，这个就表明了father接受到子类的log信息之后father的级别限定会被子类的覆盖掉。</p>
</li>
<li><p>其实我个人并不是很理解这个继承关系会给我们带来什么样的好处，或许是某些部分的信息我们希望不仅被自己的log记录，还希望能被其他的log接收到。另外一个好处就是我们使用名字限定的方式在代码中动态获得一个没有在配置文件中指定的logger实例的时候，这个logger会继承那个父类的log配置。</p>
</li>
</ul>
<h2 id="RootLogger">RootLogger</h2><p>还有需要注意的一点是，我们经常可以看到别人使用的配置文件里面会定义个：</p>
<pre><code>lo<span class="keyword">g4</span>j.rootLogger=DEBUG, appe<span class="label">nd1</span>, appe<span class="label">nd2</span>
</code></pre><ul>
<li>这里是对最高级的父类进行了<strong>rootLogger</strong>进行了配置限定，如果没有显式定义其他的Logger的话，那么所有代码中获取到的Logger实例都会继承这个配置。</li>
<li><p>如果同时定义了其他Logger，并且那个Logger有一个继承的子Logger，那么那个子类Logger的继承关系是：</p>
<pre><code>children-&gt; father -&gt;rootLogger
</code></pre></li>
<li><p>可以使用log4j.additivity.LOGNAME=false来屏蔽掉这种关系（注意LOGNAME是LOG的名称不是LOG的配置名）。</p>
</li>
</ul>
<h2 id="类实例Logger">类实例Logger</h2><p>我们经常使用的<code>Logg.getLoggger(class)</code>获取的Logger实例,如果需要配置这些Logger，在配置文件中定义其log规范使用class name来定位。</p>
<pre><code>Log4j<span class="class">.logger</span><span class="class">.className</span>= class_full_name
</code></pre><p>其含义就是使用class的全限定名来作为logger的名称，这样如果有需要的话我们可以对每个类都定义自己的log规范。<br>当然如果没有在配置文件里面配置这个全限定名字的logger，这个logger会继承rootLogger的配置，如果连rootLogger都没配置，那么log信息是无法被接收的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java代码中可以通过继承关系来扩展类的功能，在Log4J也有类似的机制。<br>]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gradle使用入门]]></title>
    <link href="http://luoyuan800.github.io/2015/07/03/gradle/"/>
    <id>http://luoyuan800.github.io/2015/07/03/gradle/</id>
    <published>2015-07-03T09:17:14.000Z</published>
    <updated>2015-07-10T01:28:53.589Z</updated>
    <content type="html"><![CDATA[<p>Gradle是一个基于Groovy实现的，类似于Ant工具的项目构建文件，其设计目标是用更简单的语法和方式来配置一个项目的构建，而不需要像Ant工具一样那么麻烦 。<a id="more"></a></p>
<h2 id="如何配置Gradle：">如何配置Gradle：</h2><ul>
<li>下载<a href="http://gradle.org/" target="_blank" rel="external">Gradle</a>解压到自定义文件夹</li>
<li>配置环境变量：GRADLE_HOME</li>
<li>添加%GRADLE_HOME%到Path中</li>
<li>测试 gradle -v 输出正常表示配置成功</li>
</ul>
<h2 id="用Gradle_打包项目">用Gradle 打包项目</h2><ul>
<li>构建 build.gradle 文件</li>
<li><p>一个简单的gradle build文件</p>
<pre><code>apply plugin: <span class="string">'java'</span>
version = <span class="string">'1.0.0'</span>

<span class="keyword">repositories</span> {
    mavenLocal()
    mavenCentral()
    maven{
        url <span class="string">"https://oosnmp.net/dist/release"</span>
    }
}

<span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="string">'org.snmp4j:snmp4j:2.3.3'</span>
}

jar {
    manifest{
    attributes <span class="string">'Title'</span>: <span class="string">'SNMPFramework'</span>, <span class="string">'Version'</span> : <span class="number">1.0</span>, <span class="string">'Author'</span>:<span class="string">'LuoYuan'</span>
}

metaInf {
    <span class="keyword">from</span>(<span class="string">'..'</span>) {
        <span class="keyword">include</span> <span class="string">'*.md'</span>
    }
    includeEmptyDirs = <span class="keyword">false</span>
    }
}

<span class="keyword">sourceSets</span>{
    main {
        java{
            srcDir <span class="string">'src'</span>
        }
    }
}

<span class="keyword">task</span> javaDoces(type: Javadoc){
    <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.allJava
}
</code></pre></li>
</ul>
<p>这个build文件表示这个项目的依赖关系，还有从什么地方获取依赖包。</p>
<p><strong>dependencies</strong> 标签定义编译代码的时候要依赖的jar包</p>
<p>Gradle会尝试从<strong>repositories</strong>获取依赖的jar包 ，然后放到user/.gradle的文件目录下缓存，下次build的时候直接从这个地方获取。</p>
<p><strong>task</strong> 标签定义一个新的task， 可以通过gradle <task\> 运行。</task\></p>
<p><strong>sourceSet</strong>标签指定项目的源代码结果，如果不配置的话会是用默认的结构 src/main/java作为源文件的存放位置。</p>
<p><strong>jar</strong> 标签定义执行build之后生成的jar包目录结构，可以配置jar包中manifest文件的内容。</p>
<p><strong>metaInf</strong> 标签定义在生产的jar包中 META-INF 目录要放入的文件。</p>
<h2 id="Gradle_构建war项目：">Gradle 构建war项目：</h2><h3 id="默认的项目结构：">默认的项目结构：</h3><pre><code>.
├── build<span class="class">.gradle</span>
└── src
    └── main
        ├── java
        │   └── com
        │       └── todo
        │           └── ToDoServlet<span class="class">.java</span>
        │                   
        └── webapp-------------------------------------------------<span class="id">#A</span>
            ├── WEB-INF
            │   └── web.xml----------------------------------------<span class="id">#B</span>
            ├── css------------------------------------------------<span class="id">#C</span>
            │   ├── base<span class="class">.css</span>
            │   └── bg<span class="class">.png</span>
            └── jsp------------------------------------------------<span class="id">#D</span>
                ├── index<span class="class">.jsp</span>
                └── todo-list.jsp
</code></pre><p>#A Web源文件默认目录</p>
<p>#B Web应用描述符文件</p>
<p>#C 存储描述如何展现HTML元素的样式单文件的目录</p>
<p>#D 存放JSP形式的动态脚本化视图组件</p>
<h3 id="一个简单脚本示例：">一个简单脚本示例：</h3><pre><code><span class="tag">apply</span> <span class="rule"><span class="attribute">plugin</span>:<span class="value"> <span class="string">'war'</span>
version = <span class="string">'1.0.0'</span>
apply plugin: <span class="string">'jetty'</span>
httpPort = <span class="number">8888</span>
repositories {
    <span class="function">mavenLocal</span>()
    <span class="function">mavenCentral</span>()
}

war {
    manifest{
        attributes <span class="string">'Title'</span>: <span class="string">'SNMPFrameworkUI'</span>, <span class="string">'Version'</span> : <span class="number">1.0</span>, <span class="string">'Author'</span>:<span class="string">'LuoYuan'</span>
    }
    metaInf {
        <span class="function">from</span>(<span class="string">'.'</span>) {
            include <span class="string">'**/*.md'</span>
        }
        includeEmptyDirs = false
    }
}</span></span>
</code></pre><h3 id="标签含义介绍">标签含义介绍</h3><p><strong>apply plugin:’jetty’</strong> 指定是用jetty作为运行war的容器，当运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle jettyRun</span><br></pre></td></tr></table></figure></p>
<p>可以启动jetty 然后自动部署当前的war包进行测试。</p>
<p><strong>httpPort</strong> 这个属性指定jetty运行的时候使用的端口，默认为8080。</p>
<h2 id="使用gradle关联本地的jar包">使用gradle关联本地的jar包</h2><ul>
<li><p>首先定义repositories</p>
<pre><code><span class="xml">repositories </span><span class="expression">{
   <span class="variable">flatDir</span>{
        <span class="variable">dirs</span> '<span class="variable">src</span><span class="end-block">/main</span><span class="end-block">/webapp</span><span class="end-block">/WEB-INF</span><span class="end-block">/lib</span>'
    }</span><span class="xml">
}</span>
</code></pre></li>
<li><p>然后需要将jar包放到对应的目录，并且在build文件中增加</p>
<pre><code>dependencies {
    compile ([':<span class="property">name</span>:<span class="property">version</span>'],[':<span class="property">name</span>:<span class="property">version</span>'])
}
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Gradle是一个基于Groovy实现的，类似于Ant工具的项目构建文件，其设计目标是用更简单的语法和方式来配置一个项目的构建，而不需要像Ant工具一样那么麻烦 。]]>
    
    </summary>
    
      <category term="编程-工具" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git使用Tips]]></title>
    <link href="http://luoyuan800.github.io/2015/07/02/git-study/"/>
    <id>http://luoyuan800.github.io/2015/07/02/git-study/</id>
    <published>2015-07-02T02:00:01.000Z</published>
    <updated>2015-10-19T09:24:16.860Z</updated>
    <content type="html"><![CDATA[<p>一些git命令的使用tips，关于git的原理解释就不在此处提及了<a id="more"></a></p>
<h2 id="复制远程代码到本地">复制远程代码到本地</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;版本库网址&gt;  &lt;本地文件夹&gt; <span class="comment">## 这个命令是默认建立master分支</span></span><br></pre></td></tr></table></figure>
<p>在clone出master分支之后，在对应的master文件夹下面使用checkout命令可以下载分支的代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b branch origin/branch  <span class="comment">## 这个命令会在当前目录下载指定分支</span></span><br></pre></td></tr></table></figure></p>
<p>如果只需要一个branch的代码，可以考虑直接clone一个branch的代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b &lt;branch name&gt; &lt;版本库网址&gt; &lt;本地文件夹位置（可选）&gt; <span class="comment">## 这个命令可以clone对应的branch代码并且放到指定的文件夹中</span></span><br></pre></td></tr></table></figure></p>
<h2 id="撤销本地的文件修改">撤销本地的文件修改</h2><p>使用远程版本库的文件覆盖本地的文件，其本质是将本地版本库的文件头回退，即是使得git记录文件修改的文件忘记本次修改的内容，然后是用pull更新当前代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure></p>
<h2 id="在某个branch的基础上创建一个newBranch（本地）">在某个branch的基础上创建一个newBranch（本地）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;newBranch&gt; origin/&lt;remotebarnch&gt; <span class="comment">## 这个命令只会在本地仓库创建一个新的branch，如果之后执行commit push命令的话就会在远程仓库创建这个branch</span></span><br></pre></td></tr></table></figure>
<h2 id="用指定的远程branch更新当前的branch">用指定的远程branch更新当前的branch</h2><p>这个命令要在需要更新branch的文件目录下执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin &lt;branchName&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="关联当前的branch和远程的branch">关联当前的branch和远程的branch</h2><p>这个命令可以指定当前本地的branch的pull和push的远程仓库对应的branch是哪一个（如果是直接从远程branch checkout的branch就默认关联同名）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git bran -- <span class="built_in">set</span>-upstram &lt;<span class="built_in">local</span>Branch&gt; origin/&lt;remoteBranch&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="修改当前项目commit的作者名称">修改当前项目commit的作者名称</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name &lt;name&gt; <span class="comment">## 修改用户名称</span></span><br><span class="line">$ git config user.email &lt;emailmaile@xxx.com&gt; <span class="comment">## 修改commit的作者的email</span></span><br></pre></td></tr></table></figure>
<p>以上的两个步骤也可以打开.git文件目录下的config文件，修改里面的author和email。修改完成之后下一次commit就会适应这个新的配置了。</p>
<h2 id="修改上一次commit的作者">修改上一次commit的作者</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend --author=<span class="string">'Gavin Luo &lt;gavin.luo@dell.com&gt;'</span></span><br></pre></td></tr></table></figure>
<h2 id="查看commit的记录：">查看commit的记录：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h2 id="撤销上一次的提交（已经push上远程仓库）">撤销上一次的提交（已经push上远程仓库）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git revert HEAD</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>
<p>这个命令会产生一个新的commit。</p>
<h2 id="撤销上一次提交">撤销上一次提交</h2><p>如果在提交之前忘记pull最新的代码下来会导致无法push本地修改的代码到远程，这个时候可以先撤销上一次的提交，更新本地代码之后再从那时提交一次就可以了。<br>reset命令是可以撤销本地的提交，记得reset之后要pull，把远程的更新拉到本地。注意这个命令不会产生新的commit。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD~<span class="number">1</span></span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure></p>
<h2 id="Merge操作">Merge操作</h2><p>Merge是将一个分支的修改内容合并到另外一个分支。首先切换到要进行merge的branch目录下，并且使用checkout命令设置当前的branch为需要进行合并的那个branch<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout localbranch</span><br><span class="line">$ git merge origin/remotebranch</span><br></pre></td></tr></table></figure></p>
<p>执行完命令后如果没有冲突，那么remoteBranch的修改就会merge到当前的branch中了。如果发生了冲突的话可以尝试使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure></p>
<p>这个命令可以在图形化的界面下进行冲突处理。</p>
<h2 id="强制覆盖本地文件">强制覆盖本地文件</h2><p>相信很多人都很烦恼merge的问题，有时候干脆直接用服务器上代码更新本地的代码。<br>````bash<br>$ git fetch —all<br>$ git reset —hard<br>$ git pull</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一些git命令的使用tips，关于git的原理解释就不在此处提及了]]>
    
    </summary>
    
      <category term="编程-工具" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 文件系统类型]]></title>
    <link href="http://luoyuan800.github.io/2015/07/01/linux-filesystem-types/"/>
    <id>http://luoyuan800.github.io/2015/07/01/linux-filesystem-types/</id>
    <published>2015-07-01T07:38:50.000Z</published>
    <updated>2015-07-02T00:44:09.240Z</updated>
    <content type="html"><![CDATA[<p>Linux操作系统下可用的各种文件系统类型注解<a id="more"></a></p>
<h2 id="ufs">ufs</h2><p><em>The Unix file system (UFS; also called the Berkeley Fast File System, the BSD Fast File System or FFS) is a file system used by many Unix and Unix-like operating systems. It is a distant descendant of the original filesystem used by Version 7 Unix.</em><br>UFS是UNIX文件系统的简称，它来源于4.3Tahoe发行版中提供的BSD Fat Fast File System（FFS）系统，属于FFS的演化版本。UFS几乎是大部分UNIX类操作系统默认的基于磁盘的文件系统，包括Solaris、Free BSD、Open BSD、Net BSD、HP-UX等，甚至Apple的OS X也能支持UFS文件系统。<br>在UFS文件系统中，“块”(“块”是UFS文件系统中文件分配和存储的基本单位，类似于FAT文件系统和NTFS文件系统中“簇”的概念）有多种类型，每种类型的块都具有特定的功能。UFS文件系统主要具有四种类型的块：引导块、超级块、i-节点、数据块。</p>
<ul>
<li>引导块：在引导系统时使用的信息</li>
<li>超级块：记录文件系统的详细信息</li>
<li>i-节点：记录文件的各种信息</li>
<li>数据块：存储每个文件的实际内容</li>
</ul>
<h2 id="ext2">ext2</h2><p><em>The ext2 or second extended filesystem is a file system for the Linux kernel. It was initially designed by Rémy Card as a replacement for the extended file system (ext). Its metadata structure was inspired by the earlier Unix File System (UFS).</em><br>The Second Extended File System(ext2)文件系统是Linux系统中的标准文件系统，是通过对Minix的文件系统进行扩展而得到的，其存取文件的性能极好。<br>在ext2文件系统中，文件由inode（包含有文件的所有信息）进行唯一标识。一个文件可能对应多个文件名，只有在所有文件名都被删除后，该文件才会被删除。此外，同一文件在磁盘中存放和被打开时所对应的inode是不同的，并由内核负责同步。<br>ext2文件系统采用三级间接块来存储数据块指针，并以块（block，默认为1KB）为单位分配空间。其磁盘分配策略是尽可能将逻辑相邻的文件分配到磁盘上物理相邻的块中，并尽可能将碎片分配给尽量少的文件，以从全局上提高性能。ext2文件系统将同一目录下的文件（包括目录）尽可能的放在同一个块组中，但目录则分布在各个块组中以实现负载均衡。在扩展文件时，会尽量一次性扩展8个连续块给文件（以预留空间的形式实现）。</p>
<h2 id="ext3">ext3</h2><p><em>Third extended filesystem, is a journaled file system that is commonly used by the Linux kernel. Its main advantage over ext2 is journaling, which improves reliability and eliminates the need to check the file system after an unclean shutdown.</em><br>ext3的设计目标就是提供对于ext2的高度兼容，很多磁盘上的结构和都和ext2很相似。也因为这样，ext3缺乏很多最新设计中的功能，例如动态分配inode和可变块大小（frags或tails）。<br>ext3文件系统在被挂载为写入的时候，是不能进行fsck的。 ext3档案系统的倾倒作业在这个档案系统还是挂载中的时候执行可能会造成资料的损坏。<br>ext3不支持在其他文件系统上已经支持（例如：JFS2和ext4）的扩展。</p>
<h2 id="ext4">ext4</h2><p><em>The ext4 or fourth extended filesystem is a journaling file system for Linux, developed as the successor to ext3.</em><br>EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）是Linux系统下的日志文件系统，是ext3文件系统的后继版本。Ext3文件系统最多只能支持32TB的文件系统和2TB的文件，根据使用的具体架构和系统设置，实际容量上限可能比这个数字还要低，即只能容纳2TB的文件系统和16GB的文件。而Ext4的文件系统容量达到1EB，而文件容量则达到16TB。<br>Ext4文件系统在Ext3的基础之上做了很多改进，引入了大量新功能，这些改进主要是为了提高未来的Linux系统的性能。<br>虽然Ext4做了很多改进，但依然能够与Ext3实现向后和向前的兼容性，这一点的确很难得。<br>因为Ext3文件系统是Linux操作系统上最受欢迎的文件系统之一，所以Ext4的研发人员考虑到应该让Ext3用户能够轻松迁移到Ext4，为此，Ext4被设计为在盘区结构方面具有向后和向前的兼容性。<br>首先Ext4是可以向前兼容的，也就是说Ext3文件系统可以挂载为Ext4文件系统使用，不过为了充分利用Ext4的优势，必须实现文件系统的迁移，以转换和利用新的Ext4格式。<br>Ext3文件系统可以在线转换为Ext4，但这样并不能用到Ext4的全部新特性，只有将文件系统重新创建为Ext4才比较彻底。<br>Ext4的向后兼容，向后兼容就是指可以将Ext4文件系统挂载为Ext3文件系统使用，但是前提是Ext4文件系统不能使用盘区功能。</p>
<h2 id="hfs">hfs</h2><p><em>Hierarchical File System (HFS) is a proprietary file system developed by Apple Inc for use in computer systems running Mac OS. Originally designed for use on floppy and hard disks, it can also be found on read-only media such as CD-ROMs. </em><br>HFS分层文件系统（Hierarchical File System，HFS）是一种由苹果电脑开发，并使用在Mac OS上的文件系统。最初被设计用于软盘和硬盘，同时也可以在在只读媒体如CD-ROM上见到。</p>
<h2 id="hfs+">hfs+</h2><p><em>HFS+ is a file system developed by Apple Inc. HFS+ was developed to replace the Hierarchical File System (HFS).</em><br>HFS+文件系统是目前的Apple电脑中默认的最常见的文件系统。HFS+来源于UNIX，但是又不用于UNIX，它增加了许多新的特性，同时也有许多不同于Windows、UNIX等系统的概念。HFS+是苹果公司为替代他们的分层文件系统（HFS）而开发的一种文件系统。它被用在macintosh电脑（或者其他运行Mac OS的电脑）上。它也是iPod上使用的其中一种格式。HFS+也被称为Mac OS Extended（或误称为“HFS Extended”)。在开发过程中，苹果公司也把这个文件系统的代号命名为“Sequoia”<br>HFS+是一个HFS的改进版本，支持更大的文件，并用Unicode来命名文件或文件夹，代替了Mac OS Roman或其他一些字符集. 和HFS一样，HFS+也使用B树来存储大部分分卷元数据。</p>
<h2 id="vsfs">vsfs</h2><h2 id="mvfs">mvfs</h2><p><em>MVFS (MultiVersion File System) is a virtual file system which displays specific versions of data stored in ClearCase. In particular, it supports dynamic views which can show an arbitrary combination of local and remote files.</em><br>这是一种虚拟的文件系统，在ClearCase中使用，用于展示不同版本的数据。</p>
<h2 id="vxfs">vxfs</h2><p><em>The VERITAS File System (or VxFS; called JFS and OnlineJFS in HP-UX) is an extent-based file system. VxFS is used as the primary filesystem of the HP-UX operating system. </em><br>VeritasFileSystem(VxFS）是首个商业日志记录文件系统。通过日志记录功能，元数据更改首先写入到日志，然后再写入到磁盘。由于无需 在多处写入更改，且元数据是异步写入的，因此吞吐量的速度较快。VxFS也是基于扩展区的意向日志记录文件系统。VxFS设计用于要求高性能和高可用性， 并且可以处理大量数据的操作环境。</p>
<h2 id="nfs">nfs</h2><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。</p>
<h2 id="nfs2">nfs2</h2><p><em>NFSv2 originally operated only over UDP. Its designers meant to keep the server side stateless, with locking (for example) implemented outside of the core protocol. The decision to make the file system stateless was a key decision, since it makes recovery from server failures trivial: all network clients freeze up when a server becomes unavailable, but once the server is again operational all the state to retry each transaction is contained in each RPC, which is retried by the client stub(s). This design decision allows UNIX applications, which usually cannot tolerate file server crashes, to ignore the problem.</em><br>NFSv2是基于32为系统的，所以其支持的最大文件只能是2G。设计的目标是使得对应的文件系统是无状态的。</p>
<h2 id="nfs3">nfs3</h2><ul>
<li>支持64位，文件大小可以大于2g</li>
<li>支持异步写操作</li>
</ul>
<h2 id="nfs4">nfs4</h2><p><em>NFS version 4.1 (RFC 5661, January 2010) aims to provide protocol support to take advantage of clustered server deployments including the ability to provide scalable parallel access to files distributed among multiple servers (pNFS extension).</em><br>针对的目标是集群的大文件读写优化。整合了afs和cifs的优点。</p>
<h2 id="hsfs">hsfs</h2><h2 id="jfs">jfs</h2><p>JFS( JOURNAL FILE SYSTEM)，一种字节级日志文件系统，借鉴了数据库保护系统的技术，以日志的形式记录文件的变化。JFS通过记录文件结构而不是数据本身的变化来保证数据的完整性。这种方式可以确保在任何时刻都能维护数据的可访问性。<br>该文件系统主要是为满足服务器（从单处理器系统到高级多处理器和群集系统）的高吞吐量和可靠性需求而设计、开发的。JFS文件系统是为面向事务的高性能系统而开发的。在IBM的AIX系统上，JFS已经过较长时间的测试，结果表明它是可靠、快速和容易使用的。 JFS也是一个有大量用户安装使用的企业级文件系统，具有可伸缩性和健壮性。与非日志文件系统相比，它的突出优点是快速重启能力，JFS能够在几秒或几分钟内就把文件系统恢复到一致状态。</p>
<h2 id="jfs2">jfs2</h2><p><em>In the AIX operating system, there exist two generations of JFS filesystem that are called JFS (JFS1) and JFS2 respectively.</em><br>Jfs2 是在AIX中专用的一种文件系统。</p>
<h2 id="reiserfs">reiserfs</h2><p>ReiserFS是一种新型的文件系统，它通过一种与众不同的方式—完全平衡树结构来容纳数据，包括文件数据，文件名以及日志支持。ReiserFS还以支持海量磁盘和磁盘阵列，并能在上面继续保很快的搜索速度和很高的效率。</p>
<h2 id="reiser4">reiser4</h2><p><em>Reiser4 is a computer file system, successor to the ReiserFS file system.</em><br>这个文件系统是设计用来替代reiserfs的。</p>
<h2 id="smbfs">smbfs</h2><h2 id="zfs">zfs</h2><p>ZFS文件系统的英文名称为Zettabyte File System,也叫动态文件系统（Dynamic File System）,是第一个128位文件系统。最初是由Sun公司为Solaris 10操作系统开发的文件系统。作为OpenSolaris开源计划的一部分，ZFS于2005年11月发布，被Sun称为是终极文件系统，经历了 10 年的活跃开发。而最新的开发将全面开放，并重新命名为 OpenZFS</p>
<h2 id="xfs">xfs</h2><p><em>XFS is a high-performance 64-bit journaling file system, the file system was ported to the Linux kernel in 2001.</em><br>XfS文件系统是SGI开发的高级日志文件系统，XFS极具伸缩性，非常健壮。所幸的是SGI将其移植到了Linux系统中。在linux环境下。目前版本可用的最新XFS文件系统的为1.2版本，可以很好地工作在2.4核心下。<br>XFS 是 Silicon Graphics，Inc. 于 90 年代初开发的。它至今仍作为 SGI 基于 IRIX 的产品（从工作站到超级计算机）的底层文件系统来使用。现在，XFS 也可以用于 Linux。XFS 的 Linux 版的到来是激动人心的，首先因为它为 Linux 社区提供了一种健壮的、优秀的以及功能丰富的文件系统，并且这种文件系统所具有的可伸缩性能够满足最苛刻的存储需求</p>
<h2 id="btrfs">btrfs</h2><p><em>Btrfs (B-tree file system) is a GPL-licensed copy-on-write file system for Linux.</em><br>Btrfs（通常念成Butter FS），由Oracle于2007年宣布并进行中的COW(copy-on-write式)文件系统。目标是取代Linux目前的ext3文件系统，改善ext3的限制，特别是单一文件大小的限制，总文件系统大小限制以及加入文件校验和特性。加入目前ext3/4未支持的一些功能，例如可写的磁盘快照(snapshots)，以及支持递归的快照(snapshots of snapshots)，内建磁盘阵列（RAID）支持，支持子卷(Subvolumes)的概念，允许在线调整文件系统大小。</p>
<h2 id="tmpfs">tmpfs</h2><p><em>A common name for a temporary file storage facility on many Unix-like operating systems.</em><br>tmpfs是一种基于内存的文件系统，它和虚拟磁盘ramdisk比较类似像，但不完全相同，和ramdisk一样，tmpfs可以使用RAM，但它也可以使用swap分区来存储。</p>
<h2 id="gfs2">gfs2</h2><p><em>The Global File System 2 or GFS2 is a shared disk file system for Linux computer clusters.</em></p>
<h2 id="vxcfs">vxcfs</h2><p><em>A cache coherent POSIX compliant shared file system built based upon VERITAS File System. Available on: IBM AIX, Solaris, Linux, and HP-UX.</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Linux操作系统下可用的各种文件系统类型注解]]>
    
    </summary>
    
      <category term="编程-Linux" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IPMI]]></title>
    <link href="http://luoyuan800.github.io/2015/07/01/IPMI/"/>
    <id>http://luoyuan800.github.io/2015/07/01/IPMI/</id>
    <published>2015-07-01T00:39:21.000Z</published>
    <updated>2015-07-16T09:31:37.291Z</updated>
    <content type="html"><![CDATA[<p>智能平台管理界面（IPMI，Intelligent Platform Management Interface）是管理基于 Intel结构的企业级系统中所使用的外围设备采用的一种工业标准，用户能够利用IPMI监控服务器的物理健康特征，如温度、电压、风扇工作状态、电源状 态等。该标准由美国英特尔、惠普（Hewlett-Packard）、NEC、美国戴尔电脑和SuperMicro等公司定制。新的版本是 IPMI2.0（<a href="http://www.intel.com/design/servers/ipmi/）。" target="_blank" rel="external">http://www.intel.com/design/servers/ipmi/）。</a><a id="more"></a></p>
<h2 id="IPMI平台">IPMI平台</h2><p>需要使用IPMI的前提条件是目标服务器具备有IPMI的硬件基础。IPMI是独立主机OS的一个管理模块，其本质是一个独立运行的硬件芯片，这个芯片提供IPMI的实现，并且具有独立的电源，独立的MAC和IP地址。可以将这个芯片视为网络层的一种硬件实现。这个芯片在IPMI的概念中被定义为BMC，嵌入式管理为控制器。</p>
<h3 id="服务器对IPMI的硬件支持">服务器对IPMI的硬件支持</h3><p>目前惠普、戴尔、和NEC等大多数厂商生成的服务器都会默认集成支持IPMI2.0。但是要注意并不是所有的服务器都支持，比如HP的服务器本身知道iLo管理系统，hp的服务器通过这个ILo管理系统模拟BMC实现IPMI，但是早起的ILo中是没有ipmi模块，需要升级到最新的版本才可以支持IPMI2.0.</p>
<h3 id="使用IPMI管理系统的条件">使用IPMI管理系统的条件</h3><p>IPMI有两种使用方式</p>
<ul>
<li><p>一种是本地使用，通过服务器的操作系统来管理本机的电源和其他硬件信息，这种要求当前的操作系统要提供IPMI的内核支持，需要在操作系统上安装IPMI的驱动。例如Linux系统通过OpenIPMI来提供对IPMI接口的支持，在Linux上使用IPMI管理服务的之前需要先安装并且启用这个内核驱动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ipmi start</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种是通过网络在另外一台机器上管理目标服务器。这个时候作为管理者使用的机器不需要安装IPMI驱动或者BMC，只需要通过网络发送IPMI命令到被管理的服务器上就使用IPMI进行服务器管理，如果查询硬件状态、开关机。这个时候我们可以在管理用的机器上安装IPMI管理工具如IPMITool。</p>
</li>
</ul>
<h2 id="IPMI_管理工具">IPMI 管理工具</h2><p>IPMI的管理工具可选择范围比较有限，目前Linux上就是用IPMITool，windows上使用 IPMIUtil。基于IPMI进行开发的Java工具包目前可免费是用的是基于Gplv3开源的vxipmi工具。我也基于IPMIutil实现了一个Java开发的支持工具包<a href="https://github.com/luoyuan800/IPMIUtil4J" title="IPMIUtil4J" target="_blank" rel="external">IPMIUtil4J</a>, 基于Apache2.0开放源代码，欢迎使用和提供建议。</p>
<h2 id="IPMI命令范例">IPMI命令范例</h2><p>IPMI使用Remote Management Control Protocol (RMCP) 版本1支持操作系统关闭（pre-OS和OS-absent），RMCP把把数据发送到<strong>UDP</strong>的623端口。象lan接口一样，lanplus同样使用 Ethernet LAN 的UDP协议与BMC通信，但是lanplus使用RMCP＋协议（在IPMIV20中描述）来同新，RMCP+允许使用改经的认证方式和数据完整性检 查。我没有深入去研究IPMI的命令格式的组成，只是大概学了下怎么是用IPMItool执行IPMI命令，于是在这里记录下一些常用的IPMI命令<br>IPMITool工具执行IPMI命令的时候需要有相应的网络接口来访问BMC，接口有三种模式： open， lan， lanplus，IPMI2.0开始可以是用lanplus来打开网络接口进行远程访问。Open端口用于本地监控系统使用的；Lan/lanplus通过网络进行远程监控。</p>
<h3 id="IPMITool命令格式">IPMITool命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipmitool -I lanplus -H &lt;ip&gt; -p &lt;port&gt; -C <span class="number">3</span> -U &lt;user&gt; -P &lt;password&gt; &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
<p> command的可选命令如下</p>
<ul>
<li>raw: 发送一个原始的IPMI请求，并且打印回复信息</li>
<li>lan： 配置网络信道（channel）</li>
<li>chassis： 查看服务器的基本状态信息（厂商）和配置电源</li>
<li>event： 向目标BMC发送一个定义的事件（比如测试配置SNMP是否成功）</li>
<li>mc：  查看MC（Management Contollor）状态和各种允许的项</li>
<li>sdr：打印传感器仓库中的任何监控项和从传感器读取到的值</li>
<li>sensor：打印传感器信息</li>
<li>Fru：打印内建的Field Replaceable Unit (FRU)信息</li>
<li>sel： 打印 System Event Log (SEL)      </li>
<li>pef： 配置 Platform Event Filtering (PEF)，事件过滤平台用于在监控系统发现有event时候，用PEF中的策略进行事件过滤，然后看是否需要报警</li>
<li>sol/isol：用于配置通过串口的Lan进行监控</li>
<li>user：配置BMC中用户的信息</li>
<li><p>channel：配置Management Controller信道</p>
<p>-C （CipherSuiteID）参数用来配置ipmi的加密登记，可以选择0-14， 各个id对应的加密组合如下表：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th style="text-align:center">AuthenticationAlgorithm</th>
<th style="text-align:center">IntegrityAlgorithm</th>
<th style="text-align:center">ConfidentialityAlgorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">SHA1</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">SHA1</td>
<td style="text-align:center">SHA1_96</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">SHA1</td>
<td style="text-align:center">SHA1_96</td>
<td style="text-align:center">AES_CBC128</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">SHA1</td>
<td style="text-align:center">SHA1_96</td>
<td style="text-align:center">XRC4_128</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">SHA1</td>
<td style="text-align:center">SHA1_96</td>
<td style="text-align:center">XRC4_40</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">AES_CBC128</td>
</tr>
<tr>
<td>9</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">XRC4_128</td>
</tr>
<tr>
<td>10</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">XRC4_40</td>
</tr>
<tr>
<td>11</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>12</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">AES_CBC128</td>
</tr>
<tr>
<td>13</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">XRC4_128</td>
</tr>
<tr>
<td>14</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">XRC4_40</td>
</tr>
</tbody>
</table>
<h3 id="命令输出结果举例">命令输出结果举例</h3><pre><code>ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C 3 -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> sensor list  <span class="comment">##这个命令能够获取传感器列表</span>

 CPU1 Temp        |<span class="string"> 0.000      </span>|<span class="string"> unspecified </span>|<span class="string"> ok    </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> 0.000     </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> na        
 CPU2 Temp        </span>|<span class="string"> 0.000      </span>|<span class="string"> unspecified </span>|<span class="string"> ok    </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> 0.000     </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> na        
 System Temp      </span>|<span class="string"> 39.000     </span>|<span class="string"> degrees C  </span>|<span class="string"> ok    </span>|<span class="string"> 0.000     </span>|<span class="string"> 0.000     </span>|<span class="string"> 0.000     </span>|<span class="string"> 81.000    </span>|<span class="string"> 82.000    </span>|<span class="string"> 
 CPU1DIMM         </span>|<span class="string"> 1.544      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 1.320     </span>|<span class="string"> 1.328     </span>|<span class="string"> 1.336     </span>|<span class="string"> 1.656     </span>|<span class="string"> 1.664     </span>|<span class="string"> 1.672     
 CPU2DIMM         </span>|<span class="string"> 1.544      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 1.320     </span>|<span class="string"> 1.328     </span>|<span class="string"> 1.336     </span>|<span class="string"> 1.656     </span>|<span class="string"> 1.664     </span>|<span class="string"> 1.672     
 +1.5V            </span>|<span class="string"> 1.512      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 1.320     </span>|<span class="string"> 1.328     </span>|<span class="string"> 1.336     </span>|<span class="string"> 1.656     </span>|<span class="string"> 1.664     </span>|<span class="string"> 1.672     
 +3.3V            </span>|<span class="string"> 3.240      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 2.880     </span>|<span class="string"> 2.904     </span>|<span class="string"> 2.928     </span>|<span class="string"> 3.648     </span>|<span class="string"> 3.672     </span>|<span class="string"> 3.696     
 +3.3VSB          </span>|<span class="string"> 3.336      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 2.880     </span>|<span class="string"> 2.904     </span>|<span class="string"> 2.928     </span>|<span class="string"> 3.648     </span>|<span class="string"> 3.672     </span>|<span class="string"> 3.696     
 VBAT             </span>|<span class="string"> 3.336      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 2.880     </span>|<span class="string"> 2.904     </span>|<span class="string"> 2.928     </span>|<span class="string"> 3.648     </span>|<span class="string"> 3.672     </span>|<span class="string"> 3.696     
 Fan1             </span>|<span class="string"> 7072.000   </span>|<span class="string"> RPM        </span>|<span class="string"> ok    </span>|<span class="string"> 340.000   </span>|<span class="string"> 408.000   </span>|<span class="string"> 476.000   </span>|<span class="string"> 17204.000 </span>|<span class="string"> 17272.000 </span>|<span class="string"> 17340.000 
 Fan2             </span>|<span class="string"> 7072.000   </span>|<span class="string"> RPM        </span>|<span class="string"> ok    </span>|<span class="string"> 340.000   </span>|<span class="string"> 408.000   </span>|<span class="string"> 476.000   </span>|<span class="string"> 17204.000 </span>|<span class="string"> 17272.000 </span>|<span class="string"> 17340.000 
 Fan3             </span>|<span class="string"> na         </span>|<span class="string"> RPM        </span>|<span class="string"> na    </span>|<span class="string"> 340.000   </span>|<span class="string"> 408.000   </span>|<span class="string"> 476.000   </span>|<span class="string"> 17204.000 </span>|<span class="string"> 17272.000 </span>|<span class="string"> 17340.000 
 PS Status        </span>|<span class="string"> 0.000      </span>|<span class="string"> unspecified </span>|<span class="string"> ok    </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> 0.000     </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> na

ipmitool -I lanplus -H &lt;ip&gt; -p &lt;port&gt; -C 3 -U &lt;user&gt; -P &lt;password&gt; sensor get "CPU1 Temp"  ##能够获取ID为CPU1 Temp监测值，CPU1 Temp是sensor的ID，服务器不同，ID表示也不同。
 Locating sensor record...
 Sensor ID              : CPU1 Temp (0x1)
 Entity ID             : 7.1
 Sensor Type (Analog)  : Unknown (0xC0)
 Sensor Reading        : 0 (+/- 0) unspecified
 Status                : ok
 Lower Non-Recoverable : 0.000
 Lower Critical        : na
 Lower Non-Critical    : 0.000
 Upper Non-Critical    : 0.000
 Upper Critical        : na
 Upper Non-Recoverable : na
 Assertion Events      : 
 Assertions Enabled    : lcr- 
 Deassertions Enabled  : lcr-</span>
</code></pre><h3 id="配置本地BMC的IP和用户名">配置本地BMC的IP和用户名</h3><p>注意这是如何配置本机的IPMI给远程主机连接使用的IP和用户名，所以需要在当前服务器的操作系统上进行配置。有些厂商的服务如HP会提供界面操作。</p>
<pre><code>ipmitool -I <span class="built_in">open</span> lan print <span class="number">1</span>                           <span class="comment">## 显示BMC通道的信息，如果不知道BMC使用的是哪个通道，请使用下面的命令确认：</span>
ipmitool -I <span class="built_in">open</span> channel info <span class="number">1</span>
ipmitool -I <span class="built_in">open</span> lan <span class="built_in">set</span> <span class="number">1</span> ipsrc static                <span class="comment">## 设置本地BMC地址为静态，才能设置IP</span>
ipmitool -I <span class="built_in">open</span> lan <span class="built_in">set</span> <span class="number">1</span> ipaddr <span class="number">10.53</span>.11.113         <span class="comment">## 设置本地BMC的IP地址</span>
ipmitool -I <span class="built_in">open</span> lan <span class="built_in">set</span> <span class="number">1</span> netmask <span class="number">255.255</span>.255.0       <span class="comment">## 子网掩码，别忘了设</span>
ipmitool -I <span class="built_in">open</span> lan <span class="built_in">set</span> <span class="number">1</span> defgw ipaddr <span class="number">10.53</span>.11.254   <span class="comment">## 网关，可设可不设</span>
ipmitool user list <span class="number">1</span>                                    <span class="comment">## 查看BMC的用户列表</span>
ipmitool user <span class="built_in">set</span> name <span class="number">1</span> username                        <span class="comment">## 对BMC的1号用户设置用户名username</span>
ipmitool user <span class="built_in">set</span> password <span class="number">1</span> <span class="number">123456</span>                    <span class="comment">## 对BMC的1号用户设置密码123456</span>
</code></pre><h3 id="个别IPMITool命令列举">个别IPMITool命令列举</h3><pre><code>ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> sensor thresh   <span class="comment"># 配置ID值等于id的监测项的各种限制值。</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis status  <span class="comment"># 查看主板状态，其中包括了主板电源信息，主板工作状态等</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis restart_cause  <span class="comment"># 查看上次系统重启的原因</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis policy list  <span class="comment"># 查看支持的底盘电源相关策略。</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis power <span class="keyword">on</span> <span class="comment"># 启动底盘，用此命令能够远程开机</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis power off <span class="comment"># 关闭底盘，用此命令能够远程关机</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis power reset <span class="comment">#实现硬重启，用此命令能够远程重启</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> mc reset <span class="comment"># 使BMC重新硬启动</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> mc info <span class="comment"># 查看BMC硬件信息</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> mc setenables =[<span class="keyword">on</span>|off] <span class="comment">#配置bmc相应的允许/禁止选项。</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> mc getenables <span class="comment"># 列出BMC任何允许的选项</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> lan print <span class="number">1</span> <span class="comment"># 打印channel 1的信息</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>智能平台管理界面（IPMI，Intelligent Platform Management Interface）是管理基于 Intel结构的企业级系统中所使用的外围设备采用的一种工业标准，用户能够利用IPMI监控服务器的物理健康特征，如温度、电压、风扇工作状态、电源状 态等。该标准由美国英特尔、惠普（Hewlett-Packard）、NEC、美国戴尔电脑和SuperMicro等公司定制。新的版本是 IPMI2.0（<a href="http://www.intel.com/design/servers/ipmi/）。">http://www.intel.com/design/servers/ipmi/）。</a>]]>
    
    </summary>
    
      <category term="编程-网络协议" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Log4j中的NDC和MDC]]></title>
    <link href="http://luoyuan800.github.io/2015/06/30/Log4j-N-MDC/"/>
    <id>http://luoyuan800.github.io/2015/06/30/Log4j-N-MDC/</id>
    <published>2015-06-30T04:08:35.000Z</published>
    <updated>2015-06-30T04:52:27.606Z</updated>
    <content type="html"><![CDATA[<p>Log4j中的NDC和MDC两个功能类似，都是用于存储上下文的信息。<a id="more"></a></p>
<h2 id="基本概念">基本概念</h2><p>NDC（Nested Diagnostic Context）MDC（Mapped Diagnostic Context）是一种嵌套诊断环境的机制。这种机制的提出，主要为了减少多线程的系统为每个客户单独记录日志的系统开销。就是说在多线程和多并发系统中年，这个模式可以只使用一个logger实例，记录每个线程的日志信息，并且会带上各个线程独特的标识信息。更多的时候这两张机制是作用在一个网络应用上，特别是一个服务平台要同时提过服务给多个客户的时候，需要追踪每个客户的信息并且记录日志的时候，使用客户的唯一标识放入到NDC或者MDC中，从而使得在log信息中更容易查看到哪一个客户触发了log事件。个人理解这个两个功能是存储额外的信息，并且可以在新版本的log4j是用MDCFilter或者NDCFilter来级能进行log文本的过滤。</p>
<h2 id="NDC与MDC的区别">NDC与MDC的区别</h2><p>NDC与MDC的区别在于存储方式的不同。<br>NDC是使用 栈的机制来存储信息，而MDC使用map的机制来存储信息。所以NDC可以通过%x来进行获取，而MDC需要通过%x{key}来获取</p>
<h2 id="使用方式">使用方式</h2><p>在log的pattern的配置中使用%x来 显示NDC 或者MDC信息。<br>在代码中设定NDC或者MDC必须在调用logger的记录方法之前，而且要保证在退出当前环境（当前代码段）的时候将信息移除，以免造成内存溢出</p>
<pre><code>……
NDC.push<span class="params">(message)</span>;
……
logger.info<span class="params">()</span>;
NDC.pop<span class="params">()</span>;
……
NDC.remove<span class="params">()</span>;<span class="comment">//在结束当前线程执行的时候要调用这个方法</span>
</code></pre><p>使用MDC的方式大致相同，只不过是需要提供key来作为信息的映射。</p>
<pre><code>……
<span class="tag">MDC</span><span class="class">.put</span>(<span class="tag">key</span>,<span class="tag">message</span>);
……
<span class="tag">logger</span><span class="class">.infog</span>();
……
<span class="tag">MDC</span><span class="class">.remove</span>(<span class="tag">key</span>);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Log4j中的NDC和MDC两个功能类似，都是用于存储上下文的信息。]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[About the Cron Expression]]></title>
    <link href="http://luoyuan800.github.io/2015/06/30/Cron-English/"/>
    <id>http://luoyuan800.github.io/2015/06/30/Cron-English/</id>
    <published>2015-06-30T03:44:14.000Z</published>
    <updated>2015-06-30T03:52:34.173Z</updated>
    <content type="html"><![CDATA[<p>Cron is use in Linux for the time schedule <a id="more"></a></p>
<h2 id="Format">Format</h2><p>Seconds Minutes Hours DayofMonth DayofWeek [Year]<br>The value of each row </p>
<table>
<thead>
<tr>
<th style="text-align:center">Second</th>
<th style="text-align:center">Minute</th>
<th style="text-align:center">Hours</th>
<th style="text-align:center">DayofMonth</th>
<th style="text-align:center">DayofWeek</th>
<th style="text-align:center">Year</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">, - * / 0-59</td>
<td style="text-align:center">, - * / 0-59</td>
<td style="text-align:center">, - * / 0-23</td>
<td style="text-align:center">, - * / 1-12 JAN-DEc</td>
<td style="text-align:center">, - * / ? L C # 1-7 SUN-SAT</td>
<td style="text-align:center">, - * / 1970-2099</td>
</tr>
</tbody>
</table>
<h2 id="Special_character:">Special character:</h2><pre><code>1. \* every
2. ? If the DayofMonth <span class="operator"><span class="keyword">use</span> \*, the <span class="keyword">DayofWeek</span> must <span class="keyword">use</span> ? <span class="keyword">to</span> <span class="keyword">match</span> <span class="keyword">any</span>
<span class="number">3.</span> \- Rang <span class="number">5</span>\-<span class="number">7</span> means5, <span class="number">6</span>, <span class="number">7</span> <span class="keyword">match</span>
<span class="number">4.</span> / <span class="built_in">interval</span> <span class="keyword">for</span> <span class="keyword">each</span>, <span class="number">0</span>/<span class="number">30</span> means <span class="keyword">start</span> <span class="keyword">when</span> <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">each</span> <span class="number">30</span> will <span class="keyword">match</span>.
<span class="number">5.</span> , It <span class="keyword">use</span> <span class="keyword">for</span> list
<span class="number">6.</span> L Means <span class="keyword">Last</span>
<span class="number">7.</span> W <span class="keyword">Work</span> <span class="keyword">day</span></span>
</code></pre><h2 id="Sample">Sample</h2><p>0 5,15, * * * ? every week every month each hours 5 and 15 minute match.<br>0 0 10,14,16 * * ? Every day 10am, 2pm, 4 pm match.<br>0 15 10 L * ? The last day of each month at 10:15 am </p>
<h2 id="Chinese_version_for_this_blog">Chinese version for this blog</h2><p><a href="../QuartZ-Cron">中文版</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Cron is use in Linux for the time schedule]]>
    
    </summary>
    
      <category term="编程-Linux" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cron 表达式入门]]></title>
    <link href="http://luoyuan800.github.io/2015/06/30/QuartZ-Cron/"/>
    <id>http://luoyuan800.github.io/2015/06/30/QuartZ-Cron/</id>
    <published>2015-06-30T01:28:52.000Z</published>
    <updated>2015-06-30T03:47:38.873Z</updated>
    <content type="html"><![CDATA[<p>关于cron表达式的基本概念介绍。<a id="more"></a></p>
<h2 id="Cron表达式简介">Cron表达式简介</h2><p>Cron是Linux中的计划任务管理系统，cron表达式可以用来定义一个计划时间来约定执行工作。<br>Cron表达式使用空格进行各个时间段的分隔，每个字段的范例格式如下表：<br>（年份可以留空，但是其他不可留空）</p>
<table>
<thead>
<tr>
<th style="text-align:center">Second</th>
<th style="text-align:center">Minut</th>
<th style="text-align:center">Hours</th>
<th style="text-align:center">DysofMounth</th>
<th style="text-align:center">Mounth</th>
<th style="text-align:center">DayofWeek</th>
<th style="text-align:center">Year</th>
<th style="text-align:right">Means</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">5,15</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">?</td>
<td style="text-align:center"></td>
<td style="text-align:right">每个小时的第五分钟，第十五分钟触发</td>
</tr>
</tbody>
</table>
<h2 id="Cron表达式中各个字段的可用字符">Cron表达式中各个字段的可用字符</h2><table>
<thead>
<tr>
<th>字段名称</th>
<th>字段可用字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>Seconds Minutes</td>
<td>, - * / 0-59</td>
</tr>
<tr>
<td>Hours</td>
<td>, - * / 0-23</td>
</tr>
<tr>
<td>DayofMonth</td>
<td>, - * / ? L W C 0-31</td>
</tr>
<tr>
<td>Month</td>
<td>, - * / 1-12 JAN-DEc</td>
</tr>
<tr>
<td>DayofWeek</td>
<td>, - * / ? L C # 1-7 SUN-SAT (1表示星期天，2表示星期一， 依次类推 )</td>
</tr>
<tr>
<td>Year</td>
<td>, - * / 1970-2099</td>
</tr>
</tbody>
</table>
<h2 id="特殊字符含义">特殊字符含义</h2><ol>
<li><strong>*</strong> 表示匹配该域的任意值，假如在Minutes域使用*, 即表示每分钟都会触发事件。</li>
<li><strong>?</strong> 只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和 DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*。 </li>
<li><strong>-</strong> 表示范围，例如在Minutes域使用5-20，表示从当前小时内的第5分到20分钟每分钟触发一次 </li>
<li><strong>/</strong> 表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着第5分钟触发一次，而第25，第45等分别触发一次. </li>
<li><strong>,</strong>  表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在第5和第20分每分钟触发一次。 </li>
<li><strong>L</strong> 表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在当前月份的最后的一个星期四触发。 </li>
<li><strong>W</strong> 表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一 到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 </li>
<li><strong>LW</strong> 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 </li>
<li><strong>#</strong> 用于确定每个月第几个星期几，只能出现在DayofWeek域。例如在4#2，表示某月的第二个星期三。</li>
<li>由于”DayofMonth “和”DayofWeek”这两个元素互斥的,必须要对其中一个设置?</li>
<li>\?字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值。当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”</li>
<li>L 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写。但是它在两个子表达式里的含义是不同的。</li>
<li>在天（月）子表达式中，“L”表示一个月的最后一天</li>
<li>在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT</li>
<li>如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五</li>
</ol>
<h2 id="举例">举例</h2><p>“0 0 10,14,16 * * ?” 每天上午10点，下午2点，4点<br>“0 0/30 9-17 * * ?” 朝九晚五工作时间内每半小时<br>“0 0 12 ? * WED” 表示每个星期三中午12点<br>“0 0 12 * * ?” 每天中午12点触发<br>“0 15 10 ? * *“ 每天上午10:15触发<br>“0 15 10 * * ?” 每天上午10:15触发<br>“0 15 10 * * ? <em>“ 每天上午10:15触发<br>“0 15 10 \</em> * ? 2005” 2005年的每天上午10:15触发<br>“0 * 14 * * ?” 在每天下午2点到下午2:59期间的每1分钟触发<br>“0 0/5 14 * * ?” 在每天下午2点到下午2:55期间的每5分钟触发<br>“0 0/5 14,18 * * ?” 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发<br>“0 0-5 14 * * ?” 在每天下午2点到下午2:05期间的每1分钟触发<br>“0 10,44 14 ? 3 WED” 每年三月的星期三的下午2:10和2:44触发<br>“0 15 10 ? * MON-FRI” 周一至周五的上午10:15触发<br>“0 15 10 15 * ?” 每月15日上午10:15触发<br>“0 15 10 L * ?” 每月最后一日的上午10:15触发<br>“0 15 10 ? * 6L” 每月的最后一个星期五上午10:15触发<br>“0 15 10 ? * 6L 2002-2005” 2002年至2005年的每月的最后一个星期五上午10:15触发<br>“0 15 10 ? * 6#3” 每月的第三个星期五上午10:15触发 </p>
<h2 id="英文版">英文版</h2><p><a href="../Cron-English">cron-English</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于cron表达式的基本概念介绍。]]>
    
    </summary>
    
      <category term="编程-Linux" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux/"/>
    
  </entry>
  
</feed>