<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yuan]]></title>
  <subtitle><![CDATA[一点一滴，技术积累]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://luoyuan800.github.io//"/>
  <updated>2015-07-03T09:33:18.386Z</updated>
  <id>http://luoyuan800.github.io//</id>
  
  <author>
    <name><![CDATA[Luo Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[gradle使用入门]]></title>
    <link href="http://luoyuan800.github.io/2015/07/03/gradle/"/>
    <id>http://luoyuan800.github.io/2015/07/03/gradle/</id>
    <published>2015-07-03T09:17:14.000Z</published>
    <updated>2015-07-03T09:33:18.386Z</updated>
    <content type="html"><![CDATA[<p>Gradle是一个基于Groovy实现的，类似于Ant工具的项目构建文件，其设计目标是用更简单的语法和方式来配置一个项目的构建，而不需要像Ant工具一样那么麻烦 。<a id="more"></a></p>
<h2 id="如何配置Gradle：">如何配置Gradle：</h2><ul>
<li>下载Gradle解压到自定义文件夹</li>
<li>配置环境变量：GRADLE_HOME</li>
<li>添加%GRADLE_HOME%到Path中</li>
<li>测试 gradle -v 输出正常表示配置成功</li>
</ul>
<h2 id="用Gradle_打包项目">用Gradle 打包项目</h2><ul>
<li>构建 build.gradle 文件</li>
<li><p>一个简单的gradle build文件</p>
<pre><code>apply plugin: <span class="string">'java'</span>
version = <span class="string">'1.0.0'</span>

<span class="keyword">repositories</span> {
    mavenLocal()
    mavenCentral()
    maven{
        url <span class="string">"https://oosnmp.net/dist/release"</span>
    }
}

<span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="string">'org.snmp4j:snmp4j:2.3.3'</span>
}

jar {
    manifest{
    attributes <span class="string">'Title'</span>: <span class="string">'SNMPFramework'</span>, <span class="string">'Version'</span> : <span class="number">1.0</span>, <span class="string">'Author'</span>:<span class="string">'LuoYuan'</span>
}

metaInf {
    <span class="keyword">from</span>(<span class="string">'..'</span>) {
        <span class="keyword">include</span> <span class="string">'*.md'</span>
    }
    includeEmptyDirs = <span class="keyword">false</span>
    }
}

<span class="keyword">sourceSets</span>{
    main {
        java{
            srcDir <span class="string">'src'</span>
        }
    }
}

<span class="keyword">task</span> javaDoces(type: Javadoc){
    <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.allJava
}
</code></pre></li>
</ul>
<p>这个build文件表示这个项目的依赖关系，还有从什么地方获取依赖包。</p>
<p><strong>dependencies</strong> 标签定义编译代码的时候要依赖的jar包</p>
<p>Gradle会尝试从<strong>repositories</strong>获取依赖的jar包 ，然后放到user/.gradle的文件目录下缓存，下次build的时候直接从这个地方获取。</p>
<p><strong>task</strong> 标签定义一个新的task， 可以通过gradle <task\> 运行。</task\></p>
<p><strong>sourceSet</strong>标签指定项目的源代码结果，如果不配置的话会是用默认的结构 src/main/java作为源文件的存放位置。</p>
<p><strong>jar</strong> 标签定义执行build之后生成的jar包目录结构，可以配置jar包中manifest文件的内容。</p>
<p><strong>metaInf</strong> 标签定义在生产的jar包中 META-INF 目录要放入的文件。</p>
<h2 id="Gradle_构建war项目：">Gradle 构建war项目：</h2><h3 id="默认的项目结构：">默认的项目结构：</h3><pre><code>.
├── build<span class="class">.gradle</span>
└── src
    └── main
        ├── java
        │   └── com
        │       └── manning
        │           └── gia
        │               └── todo
        │                   ├── model
        │                   │   └── ToDoItem<span class="class">.java</span>
        │                   ├── repository
        │                   │   ├── InMemoryToDoRepository<span class="class">.java</span>
        │                   │   └── ToDoRepository<span class="class">.java</span>
        │                   └── web
        │                       └── ToDoServlet<span class="class">.java</span>
        └── webapp-------------------------------------------------<span class="id">#A</span>
            ├── WEB-INF
            │   └── web.xml----------------------------------------<span class="id">#B</span>
            ├── css------------------------------------------------<span class="id">#C</span>
            │   ├── base<span class="class">.css</span>
            │   └── bg<span class="class">.png</span>
            └── jsp------------------------------------------------<span class="id">#D</span>
                ├── index<span class="class">.jsp</span>
                └── todo-list.jsp
</code></pre><p>#A Web源文件默认目录</p>
<p>#B Web应用描述符文件</p>
<p>#C 存储描述如何展现HTML元素的样式单文件的目录</p>
<p>#D 存放JSP形式的动态脚本化视图组件</p>
<h3 id="一个简单脚本示例：">一个简单脚本示例：</h3><pre><code><span class="tag">apply</span> <span class="rule"><span class="attribute">plugin</span>:<span class="value"> <span class="string">'war'</span>
version = <span class="string">'1.0.0'</span>
apply plugin: <span class="string">'jetty'</span>
httpPort = <span class="number">8888</span>
repositories {
    <span class="function">mavenLocal</span>()
    <span class="function">mavenCentral</span>()
}

war {
    manifest{
        attributes <span class="string">'Title'</span>: <span class="string">'SNMPFrameworkUI'</span>, <span class="string">'Version'</span> : <span class="number">1.0</span>, <span class="string">'Author'</span>:<span class="string">'LuoYuan'</span>
    }
    metaInf {
        <span class="function">from</span>(<span class="string">'.'</span>) {
            include <span class="string">'**/*.md'</span>
        }
        includeEmptyDirs = false
    }
}</span></span>
</code></pre><h3 id="标签含义介绍">标签含义介绍</h3><p><strong>apply plugin:’jetty’</strong> 指定是用jetty作为运行war的容器，当运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle jettyRun</span><br></pre></td></tr></table></figure></p>
<p>可以启动jetty 然后自动部署当前的war包进行测试。</p>
<p><strong>httpPort</strong> 这个属性指定jetty运行的时候使用的端口，默认为8080。</p>
<h2 id="使用gradle关联本地的jar包">使用gradle关联本地的jar包</h2><ul>
<li><p>首先定义repositories</p>
<pre><code><span class="xml">repositories </span><span class="expression">{
   <span class="variable">flatDir</span>{
        <span class="variable">dirs</span> '<span class="variable">src</span><span class="end-block">/main</span><span class="end-block">/webapp</span><span class="end-block">/WEB-INF</span><span class="end-block">/lib</span>'
    }</span><span class="xml">
}</span>
</code></pre></li>
<li><p>然后需要将jar包放到对应的目录，并且在build文件中增加</p>
<pre><code>dependencies {
    compile ([':<span class="property">name</span>:<span class="property">version</span>'],[':<span class="property">name</span>:<span class="property">version</span>'])
}
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Gradle是一个基于Groovy实现的，类似于Ant工具的项目构建文件，其设计目标是用更简单的语法和方式来配置一个项目的构建，而不需要像Ant工具一样那么麻烦 。]]>
    
    </summary>
    
      <category term="编程-工具" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git使用Tips]]></title>
    <link href="http://luoyuan800.github.io/2015/07/02/git-study/"/>
    <id>http://luoyuan800.github.io/2015/07/02/git-study/</id>
    <published>2015-07-02T02:00:01.000Z</published>
    <updated>2015-07-03T08:33:39.944Z</updated>
    <content type="html"><![CDATA[<p>一些git命令的使用tips，关于git的原理解释就不在此处提及了<a id="more"></a></p>
<h2 id="复制远程代码到本地">复制远程代码到本地</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;版本库网址&gt;  &lt;本地文件夹&gt; <span class="comment">## 这个命令是默认建立master分支</span></span><br></pre></td></tr></table></figure>
<p>在clone出master分支之后，在对应的master文件夹下面使用checkout命令可以下载分支的代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b branch origin/branch  <span class="comment">## 这个命令会在当前目录下载指定分支</span></span><br></pre></td></tr></table></figure></p>
<p>如果只需要一个branch的代码，可以考虑直接clone一个branch的代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b &lt;branch name&gt; &lt;版本库网址&gt; &lt;本地文件夹位置（可选）&gt; <span class="comment">## 这个命令可以clone对应的branch代码并且放到指定的文件夹中</span></span><br></pre></td></tr></table></figure></p>
<h2 id="撤销本地的文件修改">撤销本地的文件修改</h2><p>使用远程版本库的文件覆盖本地的文件，其本质是将本地版本库的文件头回退，即是使得git记录文件修改的文件忘记本次修改的内容，然后是用pull更新当前代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure></p>
<h2 id="在某个branch的基础上创建一个newBranch（本地）">在某个branch的基础上创建一个newBranch（本地）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;newBranch&gt; origin/&lt;remotebarnch&gt; <span class="comment">## 这个命令只会在本地仓库创建一个新的branch，如果之后执行commit push命令的话就会在远程仓库创建这个branch</span></span><br></pre></td></tr></table></figure>
<h2 id="用指定的远程branch更新当前的branch">用指定的远程branch更新当前的branch</h2><p>这个命令要在需要更新branch的文件目录下执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin &lt;branchName&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="关联当前的branch和远程的branch">关联当前的branch和远程的branch</h2><p>这个命令可以指定当前本地的branch的pull和push的远程仓库对应的branch是哪一个（如果是直接从远程branch checkout的branch就默认关联同名）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git bran -- <span class="built_in">set</span>-upstram &lt;<span class="built_in">local</span>Branch&gt; origin/&lt;remoteBranch&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="修改当前项目commit的作者名称">修改当前项目commit的作者名称</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name &lt;name&gt; <span class="comment">## 修改用户名称</span></span><br><span class="line">$ git config user.email &lt;emailmaile@xxx.com&gt; <span class="comment">## 修改commit的作者的email</span></span><br></pre></td></tr></table></figure>
<p>以上的两个步骤也可以打开.git文件目录下的config文件，修改里面的author和email。修改完成之后下一次commit就会适应这个新的配置了。</p>
<h2 id="修改上一次commit的作者">修改上一次commit的作者</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend --author=<span class="string">'Gavin Luo &lt;gavin.luo@dell.com&gt;'</span></span><br></pre></td></tr></table></figure>
<h2 id="查看commit的记录：">查看commit的记录：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h2 id="撤销上一次的提交（已经push上远程仓库）">撤销上一次的提交（已经push上远程仓库）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git revert HEAD</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>
<p>这个命令会产生一个新的commit。</p>
<h2 id="撤销上一次提交">撤销上一次提交</h2><p>如果在提交之前忘记pull最新的代码下来会导致无法push本地修改的代码到远程，这个时候可以先撤销上一次的提交，更新本地代码之后再从那时提交一次就可以了。<br>reset命令是可以撤销本地的提交，记得reset之后要pull，把远程的更新拉到本地。注意这个命令不会产生新的commit。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD~<span class="number">1</span></span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure></p>
<h2 id="Merge操作">Merge操作</h2><p>Merge是将一个分支的修改内容合并到另外一个分支。首先切换到要进行merge的branch目录下，并且使用checkout命令设置当前的branch为需要进行合并的那个branch<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout localbranch</span><br><span class="line">$ git merge origin/remotebranch</span><br></pre></td></tr></table></figure></p>
<p>执行完命令后如果没有冲突，那么remoteBranch的修改就会merge到当前的branch中了。如果发生了冲突的话可以尝试使用<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure></p>
<p>这个命令可以在图形化的界面下进行冲突处理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一些git命令的使用tips，关于git的原理解释就不在此处提及了]]>
    
    </summary>
    
      <category term="编程-工具" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 文件系统类型]]></title>
    <link href="http://luoyuan800.github.io/2015/07/01/linux-filesystem-types/"/>
    <id>http://luoyuan800.github.io/2015/07/01/linux-filesystem-types/</id>
    <published>2015-07-01T07:38:50.000Z</published>
    <updated>2015-07-02T00:44:09.240Z</updated>
    <content type="html"><![CDATA[<p>Linux操作系统下可用的各种文件系统类型注解<a id="more"></a></p>
<h2 id="ufs">ufs</h2><p><em>The Unix file system (UFS; also called the Berkeley Fast File System, the BSD Fast File System or FFS) is a file system used by many Unix and Unix-like operating systems. It is a distant descendant of the original filesystem used by Version 7 Unix.</em><br>UFS是UNIX文件系统的简称，它来源于4.3Tahoe发行版中提供的BSD Fat Fast File System（FFS）系统，属于FFS的演化版本。UFS几乎是大部分UNIX类操作系统默认的基于磁盘的文件系统，包括Solaris、Free BSD、Open BSD、Net BSD、HP-UX等，甚至Apple的OS X也能支持UFS文件系统。<br>在UFS文件系统中，“块”(“块”是UFS文件系统中文件分配和存储的基本单位，类似于FAT文件系统和NTFS文件系统中“簇”的概念）有多种类型，每种类型的块都具有特定的功能。UFS文件系统主要具有四种类型的块：引导块、超级块、i-节点、数据块。</p>
<ul>
<li>引导块：在引导系统时使用的信息</li>
<li>超级块：记录文件系统的详细信息</li>
<li>i-节点：记录文件的各种信息</li>
<li>数据块：存储每个文件的实际内容</li>
</ul>
<h2 id="ext2">ext2</h2><p><em>The ext2 or second extended filesystem is a file system for the Linux kernel. It was initially designed by Rémy Card as a replacement for the extended file system (ext). Its metadata structure was inspired by the earlier Unix File System (UFS).</em><br>The Second Extended File System(ext2)文件系统是Linux系统中的标准文件系统，是通过对Minix的文件系统进行扩展而得到的，其存取文件的性能极好。<br>在ext2文件系统中，文件由inode（包含有文件的所有信息）进行唯一标识。一个文件可能对应多个文件名，只有在所有文件名都被删除后，该文件才会被删除。此外，同一文件在磁盘中存放和被打开时所对应的inode是不同的，并由内核负责同步。<br>ext2文件系统采用三级间接块来存储数据块指针，并以块（block，默认为1KB）为单位分配空间。其磁盘分配策略是尽可能将逻辑相邻的文件分配到磁盘上物理相邻的块中，并尽可能将碎片分配给尽量少的文件，以从全局上提高性能。ext2文件系统将同一目录下的文件（包括目录）尽可能的放在同一个块组中，但目录则分布在各个块组中以实现负载均衡。在扩展文件时，会尽量一次性扩展8个连续块给文件（以预留空间的形式实现）。</p>
<h2 id="ext3">ext3</h2><p><em>Third extended filesystem, is a journaled file system that is commonly used by the Linux kernel. Its main advantage over ext2 is journaling, which improves reliability and eliminates the need to check the file system after an unclean shutdown.</em><br>ext3的设计目标就是提供对于ext2的高度兼容，很多磁盘上的结构和都和ext2很相似。也因为这样，ext3缺乏很多最新设计中的功能，例如动态分配inode和可变块大小（frags或tails）。<br>ext3文件系统在被挂载为写入的时候，是不能进行fsck的。 ext3档案系统的倾倒作业在这个档案系统还是挂载中的时候执行可能会造成资料的损坏。<br>ext3不支持在其他文件系统上已经支持（例如：JFS2和ext4）的扩展。</p>
<h2 id="ext4">ext4</h2><p><em>The ext4 or fourth extended filesystem is a journaling file system for Linux, developed as the successor to ext3.</em><br>EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）是Linux系统下的日志文件系统，是ext3文件系统的后继版本。Ext3文件系统最多只能支持32TB的文件系统和2TB的文件，根据使用的具体架构和系统设置，实际容量上限可能比这个数字还要低，即只能容纳2TB的文件系统和16GB的文件。而Ext4的文件系统容量达到1EB，而文件容量则达到16TB。<br>Ext4文件系统在Ext3的基础之上做了很多改进，引入了大量新功能，这些改进主要是为了提高未来的Linux系统的性能。<br>虽然Ext4做了很多改进，但依然能够与Ext3实现向后和向前的兼容性，这一点的确很难得。<br>因为Ext3文件系统是Linux操作系统上最受欢迎的文件系统之一，所以Ext4的研发人员考虑到应该让Ext3用户能够轻松迁移到Ext4，为此，Ext4被设计为在盘区结构方面具有向后和向前的兼容性。<br>首先Ext4是可以向前兼容的，也就是说Ext3文件系统可以挂载为Ext4文件系统使用，不过为了充分利用Ext4的优势，必须实现文件系统的迁移，以转换和利用新的Ext4格式。<br>Ext3文件系统可以在线转换为Ext4，但这样并不能用到Ext4的全部新特性，只有将文件系统重新创建为Ext4才比较彻底。<br>Ext4的向后兼容，向后兼容就是指可以将Ext4文件系统挂载为Ext3文件系统使用，但是前提是Ext4文件系统不能使用盘区功能。</p>
<h2 id="hfs">hfs</h2><p><em>Hierarchical File System (HFS) is a proprietary file system developed by Apple Inc for use in computer systems running Mac OS. Originally designed for use on floppy and hard disks, it can also be found on read-only media such as CD-ROMs. </em><br>HFS分层文件系统（Hierarchical File System，HFS）是一种由苹果电脑开发，并使用在Mac OS上的文件系统。最初被设计用于软盘和硬盘，同时也可以在在只读媒体如CD-ROM上见到。</p>
<h2 id="hfs+">hfs+</h2><p><em>HFS+ is a file system developed by Apple Inc. HFS+ was developed to replace the Hierarchical File System (HFS).</em><br>HFS+文件系统是目前的Apple电脑中默认的最常见的文件系统。HFS+来源于UNIX，但是又不用于UNIX，它增加了许多新的特性，同时也有许多不同于Windows、UNIX等系统的概念。HFS+是苹果公司为替代他们的分层文件系统（HFS）而开发的一种文件系统。它被用在macintosh电脑（或者其他运行Mac OS的电脑）上。它也是iPod上使用的其中一种格式。HFS+也被称为Mac OS Extended（或误称为“HFS Extended”)。在开发过程中，苹果公司也把这个文件系统的代号命名为“Sequoia”<br>HFS+是一个HFS的改进版本，支持更大的文件，并用Unicode来命名文件或文件夹，代替了Mac OS Roman或其他一些字符集. 和HFS一样，HFS+也使用B树来存储大部分分卷元数据。</p>
<h2 id="vsfs">vsfs</h2><h2 id="mvfs">mvfs</h2><p><em>MVFS (MultiVersion File System) is a virtual file system which displays specific versions of data stored in ClearCase. In particular, it supports dynamic views which can show an arbitrary combination of local and remote files.</em><br>这是一种虚拟的文件系统，在ClearCase中使用，用于展示不同版本的数据。</p>
<h2 id="vxfs">vxfs</h2><p><em>The VERITAS File System (or VxFS; called JFS and OnlineJFS in HP-UX) is an extent-based file system. VxFS is used as the primary filesystem of the HP-UX operating system. </em><br>VeritasFileSystem(VxFS）是首个商业日志记录文件系统。通过日志记录功能，元数据更改首先写入到日志，然后再写入到磁盘。由于无需 在多处写入更改，且元数据是异步写入的，因此吞吐量的速度较快。VxFS也是基于扩展区的意向日志记录文件系统。VxFS设计用于要求高性能和高可用性， 并且可以处理大量数据的操作环境。</p>
<h2 id="nfs">nfs</h2><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。</p>
<h2 id="nfs2">nfs2</h2><p><em>NFSv2 originally operated only over UDP. Its designers meant to keep the server side stateless, with locking (for example) implemented outside of the core protocol. The decision to make the file system stateless was a key decision, since it makes recovery from server failures trivial: all network clients freeze up when a server becomes unavailable, but once the server is again operational all the state to retry each transaction is contained in each RPC, which is retried by the client stub(s). This design decision allows UNIX applications, which usually cannot tolerate file server crashes, to ignore the problem.</em><br>NFSv2是基于32为系统的，所以其支持的最大文件只能是2G。设计的目标是使得对应的文件系统是无状态的。</p>
<h2 id="nfs3">nfs3</h2><ul>
<li>支持64位，文件大小可以大于2g</li>
<li>支持异步写操作</li>
</ul>
<h2 id="nfs4">nfs4</h2><p><em>NFS version 4.1 (RFC 5661, January 2010) aims to provide protocol support to take advantage of clustered server deployments including the ability to provide scalable parallel access to files distributed among multiple servers (pNFS extension).</em><br>针对的目标是集群的大文件读写优化。整合了afs和cifs的优点。</p>
<h2 id="hsfs">hsfs</h2><h2 id="jfs">jfs</h2><p>JFS( JOURNAL FILE SYSTEM)，一种字节级日志文件系统，借鉴了数据库保护系统的技术，以日志的形式记录文件的变化。JFS通过记录文件结构而不是数据本身的变化来保证数据的完整性。这种方式可以确保在任何时刻都能维护数据的可访问性。<br>该文件系统主要是为满足服务器（从单处理器系统到高级多处理器和群集系统）的高吞吐量和可靠性需求而设计、开发的。JFS文件系统是为面向事务的高性能系统而开发的。在IBM的AIX系统上，JFS已经过较长时间的测试，结果表明它是可靠、快速和容易使用的。 JFS也是一个有大量用户安装使用的企业级文件系统，具有可伸缩性和健壮性。与非日志文件系统相比，它的突出优点是快速重启能力，JFS能够在几秒或几分钟内就把文件系统恢复到一致状态。</p>
<h2 id="jfs2">jfs2</h2><p><em>In the AIX operating system, there exist two generations of JFS filesystem that are called JFS (JFS1) and JFS2 respectively.</em><br>Jfs2 是在AIX中专用的一种文件系统。</p>
<h2 id="reiserfs">reiserfs</h2><p>ReiserFS是一种新型的文件系统，它通过一种与众不同的方式—完全平衡树结构来容纳数据，包括文件数据，文件名以及日志支持。ReiserFS还以支持海量磁盘和磁盘阵列，并能在上面继续保很快的搜索速度和很高的效率。</p>
<h2 id="reiser4">reiser4</h2><p><em>Reiser4 is a computer file system, successor to the ReiserFS file system.</em><br>这个文件系统是设计用来替代reiserfs的。</p>
<h2 id="smbfs">smbfs</h2><h2 id="zfs">zfs</h2><p>ZFS文件系统的英文名称为Zettabyte File System,也叫动态文件系统（Dynamic File System）,是第一个128位文件系统。最初是由Sun公司为Solaris 10操作系统开发的文件系统。作为OpenSolaris开源计划的一部分，ZFS于2005年11月发布，被Sun称为是终极文件系统，经历了 10 年的活跃开发。而最新的开发将全面开放，并重新命名为 OpenZFS</p>
<h2 id="xfs">xfs</h2><p><em>XFS is a high-performance 64-bit journaling file system, the file system was ported to the Linux kernel in 2001.</em><br>XfS文件系统是SGI开发的高级日志文件系统，XFS极具伸缩性，非常健壮。所幸的是SGI将其移植到了Linux系统中。在linux环境下。目前版本可用的最新XFS文件系统的为1.2版本，可以很好地工作在2.4核心下。<br>XFS 是 Silicon Graphics，Inc. 于 90 年代初开发的。它至今仍作为 SGI 基于 IRIX 的产品（从工作站到超级计算机）的底层文件系统来使用。现在，XFS 也可以用于 Linux。XFS 的 Linux 版的到来是激动人心的，首先因为它为 Linux 社区提供了一种健壮的、优秀的以及功能丰富的文件系统，并且这种文件系统所具有的可伸缩性能够满足最苛刻的存储需求</p>
<h2 id="btrfs">btrfs</h2><p><em>Btrfs (B-tree file system) is a GPL-licensed copy-on-write file system for Linux.</em><br>Btrfs（通常念成Butter FS），由Oracle于2007年宣布并进行中的COW(copy-on-write式)文件系统。目标是取代Linux目前的ext3文件系统，改善ext3的限制，特别是单一文件大小的限制，总文件系统大小限制以及加入文件校验和特性。加入目前ext3/4未支持的一些功能，例如可写的磁盘快照(snapshots)，以及支持递归的快照(snapshots of snapshots)，内建磁盘阵列（RAID）支持，支持子卷(Subvolumes)的概念，允许在线调整文件系统大小。</p>
<h2 id="tmpfs">tmpfs</h2><p><em>A common name for a temporary file storage facility on many Unix-like operating systems.</em><br>tmpfs是一种基于内存的文件系统，它和虚拟磁盘ramdisk比较类似像，但不完全相同，和ramdisk一样，tmpfs可以使用RAM，但它也可以使用swap分区来存储。</p>
<h2 id="gfs2">gfs2</h2><p><em>The Global File System 2 or GFS2 is a shared disk file system for Linux computer clusters.</em></p>
<h2 id="vxcfs">vxcfs</h2><p><em>A cache coherent POSIX compliant shared file system built based upon VERITAS File System. Available on: IBM AIX, Solaris, Linux, and HP-UX.</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Linux操作系统下可用的各种文件系统类型注解]]>
    
    </summary>
    
      <category term="编程-Linux" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IPMI]]></title>
    <link href="http://luoyuan800.github.io/2015/07/01/IPMI/"/>
    <id>http://luoyuan800.github.io/2015/07/01/IPMI/</id>
    <published>2015-07-01T00:39:21.000Z</published>
    <updated>2015-07-01T02:06:00.561Z</updated>
    <content type="html"><![CDATA[<p>智能平台管理界面（IPMI，Intelligent Platform Management Interface）是管理基于 Intel结构的企业级系统中所使用的外围设备采用的一种工业标准，用户能够利用IPMI监控服务器的物理健康特征，如温度、电压、风扇工作状态、电源状 态等。该标准由美国英特尔、惠普（Hewlett-Packard）、NEC、美国戴尔电脑和SuperMicro等公司定制。新的版本是 IPMI2.0（<a href="http://www.intel.com/design/servers/ipmi/）。" target="_blank" rel="external">http://www.intel.com/design/servers/ipmi/）。</a><a id="more"></a></p>
<h2 id="IPMI平台">IPMI平台</h2><p>需要使用IPMI的前提条件是目标服务器具备有IPMI的硬件基础。IPMI是独立主机OS的一个管理模块，其本质是一个独立运行的硬件芯片，这个芯片提供IPMI的实现，并且具有独立的电源，独立的MAC和IP地址。可以将这个芯片视为网络层的一种硬件实现。这个芯片在IPMI的概念中被定义为BMC，嵌入式管理为控制器。</p>
<h3 id="服务器对IPMI的硬件支持">服务器对IPMI的硬件支持</h3><p>目前惠普、戴尔、和NEC等大多数厂商生成的服务器都会默认集成支持IPMI2.0。但是要注意并不是所有的服务器都支持，比如HP的服务器本身知道iLo管理系统，hp的服务器通过这个ILo管理系统模拟BMC实现IPMI，但是早起的ILo中是没有ipmi模块，需要升级到最新的版本才可以支持IPMI2.0.</p>
<h3 id="使用IPMI管理系统的条件">使用IPMI管理系统的条件</h3><p>IPMI有两种使用方式</p>
<ul>
<li><p>一种是本地使用，通过服务器的操作系统来管理本机的电源和其他硬件信息，这种要求当前的操作系统要提供IPMI的内核支持，需要在操作系统上安装IPMI的驱动。例如Linux系统通过OpenIPMI来提供对IPMI接口的支持，在Linux上使用IPMI管理服务的之前需要先安装并且启用这个内核驱动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ipmi start</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种是通过网络在另外一台机器上管理目标服务器。这个时候作为管理者使用的机器不需要安装IPMI驱动或者BMC，只需要通过网络发送IPMI命令到被管理的服务器上就使用IPMI进行服务器管理，如果查询硬件状态、开关机。这个时候我们可以在管理用的机器上安装IPMI管理工具如IPMITool。</p>
</li>
</ul>
<h2 id="IPMI_管理工具">IPMI 管理工具</h2><p>IPMI的管理工具可选择范围比较有限，目前Linux上就是用IPMITool，windows上使用 IPMIUtil。基于IPMI进行开发的Java工具包目前可免费是用的是基于Gplv3开源的vxipmi工具。我也基于IPMIutil实现了一个在windows平台下进行Java开发的支持工具包。</p>
<h2 id="IPMI命令范例">IPMI命令范例</h2><p>IPMI使用Remote Management Control Protocol (RMCP) 版本1支持操作系统关闭（pre-OS和OS-absent），RMCP把把数据发送到<strong>UDP</strong>的623端口。象lan接口一样，lanplus同样使用 Ethernet LAN 的UDP协议与BMC通信，但是lanplus使用RMCP＋协议（在IPMIV20中描述）来同新，RMCP+允许使用改经的认证方式和数据完整性检 查。我没有深入去研究IPMI的命令格式的组成，只是大概学了下怎么是用IPMItool执行IPMI命令，于是在这里记录下一些常用的IPMI命令<br>IPMITool工具执行IPMI命令的时候需要有相应的网络接口来访问BMC，接口有三种模式： open， lan， lanplus，IPMI2.0开始可以是用lanplus来打开网络接口进行远程访问。Open端口用于本地监控系统使用的；Lan/lanplus通过网络进行远程监控。</p>
<h3 id="IPMITool命令格式">IPMITool命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipmitool -I lanplus -H &lt;ip&gt; -p &lt;port&gt; -C <span class="number">3</span> -U &lt;user&gt; -P &lt;password&gt; &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
<p> command的可选命令如下</p>
<ul>
<li>raw: 发送一个原始的IPMI请求，并且打印回复信息</li>
<li>lan： 配置网络信道（channel）</li>
<li>chassis： 查看服务器的基本状态信息（厂商）和配置电源</li>
<li>event： 向目标BMC发送一个定义的事件（比如测试配置SNMP是否成功）</li>
<li>mc：  查看MC（Management Contollor）状态和各种允许的项</li>
<li>sdr：打印传感器仓库中的任何监控项和从传感器读取到的值</li>
<li>sensor：打印传感器信息</li>
<li>Fru：打印内建的Field Replaceable Unit (FRU)信息</li>
<li>sel： 打印 System Event Log (SEL)      </li>
<li>pef： 配置 Platform Event Filtering (PEF)，事件过滤平台用于在监控系统发现有event时候，用PEF中的策略进行事件过滤，然后看是否需要报警</li>
<li>sol/isol：用于配置通过串口的Lan进行监控</li>
<li>user：配置BMC中用户的信息</li>
<li><p>channel：配置Management Controller信道</p>
<p>-C （CipherSuiteID）参数用来配置ipmi的加密登记，可以选择0-14， 各个id对应的加密组合如下表：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th style="text-align:center">AuthenticationAlgorithm</th>
<th style="text-align:center">IntegrityAlgorithm</th>
<th style="text-align:center">ConfidentialityAlgorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">SHA1</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">SHA1</td>
<td style="text-align:center">SHA1_96</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">SHA1</td>
<td style="text-align:center">SHA1_96</td>
<td style="text-align:center">AES_CBC128</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">SHA1</td>
<td style="text-align:center">SHA1_96</td>
<td style="text-align:center">XRC4_128</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">SHA1</td>
<td style="text-align:center">SHA1_96</td>
<td style="text-align:center">XRC4_40</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">NONE</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">AES_CBC128</td>
</tr>
<tr>
<td>9</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">XRC4_128</td>
</tr>
<tr>
<td>10</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">XRC4_40</td>
</tr>
<tr>
<td>11</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">NONE</td>
</tr>
<tr>
<td>12</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">AES_CBC128</td>
</tr>
<tr>
<td>13</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">XRC4_128</td>
</tr>
<tr>
<td>14</td>
<td style="text-align:center">MD5</td>
<td style="text-align:center">MD5_128</td>
<td style="text-align:center">XRC4_40</td>
</tr>
</tbody>
</table>
<h3 id="命令输出结果举例">命令输出结果举例</h3><pre><code>ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C 3 -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> sensor list  <span class="comment">##这个命令能够获取传感器列表</span>

 CPU1 Temp        |<span class="string"> 0.000      </span>|<span class="string"> unspecified </span>|<span class="string"> ok    </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> 0.000     </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> na        
 CPU2 Temp        </span>|<span class="string"> 0.000      </span>|<span class="string"> unspecified </span>|<span class="string"> ok    </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> 0.000     </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> na        
 System Temp      </span>|<span class="string"> 39.000     </span>|<span class="string"> degrees C  </span>|<span class="string"> ok    </span>|<span class="string"> 0.000     </span>|<span class="string"> 0.000     </span>|<span class="string"> 0.000     </span>|<span class="string"> 81.000    </span>|<span class="string"> 82.000    </span>|<span class="string"> 
 CPU1DIMM         </span>|<span class="string"> 1.544      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 1.320     </span>|<span class="string"> 1.328     </span>|<span class="string"> 1.336     </span>|<span class="string"> 1.656     </span>|<span class="string"> 1.664     </span>|<span class="string"> 1.672     
 CPU2DIMM         </span>|<span class="string"> 1.544      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 1.320     </span>|<span class="string"> 1.328     </span>|<span class="string"> 1.336     </span>|<span class="string"> 1.656     </span>|<span class="string"> 1.664     </span>|<span class="string"> 1.672     
 +1.5V            </span>|<span class="string"> 1.512      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 1.320     </span>|<span class="string"> 1.328     </span>|<span class="string"> 1.336     </span>|<span class="string"> 1.656     </span>|<span class="string"> 1.664     </span>|<span class="string"> 1.672     
 +3.3V            </span>|<span class="string"> 3.240      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 2.880     </span>|<span class="string"> 2.904     </span>|<span class="string"> 2.928     </span>|<span class="string"> 3.648     </span>|<span class="string"> 3.672     </span>|<span class="string"> 3.696     
 +3.3VSB          </span>|<span class="string"> 3.336      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 2.880     </span>|<span class="string"> 2.904     </span>|<span class="string"> 2.928     </span>|<span class="string"> 3.648     </span>|<span class="string"> 3.672     </span>|<span class="string"> 3.696     
 VBAT             </span>|<span class="string"> 3.336      </span>|<span class="string"> Volts      </span>|<span class="string"> ok    </span>|<span class="string"> 2.880     </span>|<span class="string"> 2.904     </span>|<span class="string"> 2.928     </span>|<span class="string"> 3.648     </span>|<span class="string"> 3.672     </span>|<span class="string"> 3.696     
 Fan1             </span>|<span class="string"> 7072.000   </span>|<span class="string"> RPM        </span>|<span class="string"> ok    </span>|<span class="string"> 340.000   </span>|<span class="string"> 408.000   </span>|<span class="string"> 476.000   </span>|<span class="string"> 17204.000 </span>|<span class="string"> 17272.000 </span>|<span class="string"> 17340.000 
 Fan2             </span>|<span class="string"> 7072.000   </span>|<span class="string"> RPM        </span>|<span class="string"> ok    </span>|<span class="string"> 340.000   </span>|<span class="string"> 408.000   </span>|<span class="string"> 476.000   </span>|<span class="string"> 17204.000 </span>|<span class="string"> 17272.000 </span>|<span class="string"> 17340.000 
 Fan3             </span>|<span class="string"> na         </span>|<span class="string"> RPM        </span>|<span class="string"> na    </span>|<span class="string"> 340.000   </span>|<span class="string"> 408.000   </span>|<span class="string"> 476.000   </span>|<span class="string"> 17204.000 </span>|<span class="string"> 17272.000 </span>|<span class="string"> 17340.000 
 PS Status        </span>|<span class="string"> 0.000      </span>|<span class="string"> unspecified </span>|<span class="string"> ok    </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> 0.000     </span>|<span class="string"> 0.000     </span>|<span class="string"> na        </span>|<span class="string"> na

ipmitool -I lanplus -H &lt;ip&gt; -p &lt;port&gt; -C 3 -U &lt;user&gt; -P &lt;password&gt; sensor get "CPU1 Temp"  ##能够获取ID为CPU1 Temp监测值，CPU1 Temp是sensor的ID，服务器不同，ID表示也不同。
 Locating sensor record...
 Sensor ID              : CPU1 Temp (0x1)
 Entity ID             : 7.1
 Sensor Type (Analog)  : Unknown (0xC0)
 Sensor Reading        : 0 (+/- 0) unspecified
 Status                : ok
 Lower Non-Recoverable : 0.000
 Lower Critical        : na
 Lower Non-Critical    : 0.000
 Upper Non-Critical    : 0.000
 Upper Critical        : na
 Upper Non-Recoverable : na
 Assertion Events      : 
 Assertions Enabled    : lcr- 
 Deassertions Enabled  : lcr-</span>
</code></pre><h3 id="配置本地BMC的IP和用户名">配置本地BMC的IP和用户名</h3><p>注意这是如何配置本机的IPMI给远程主机连接使用的IP和用户名，所以需要在当前服务器的操作系统上进行配置。有些厂商的服务如HP会提供界面操作。</p>
<pre><code>ipmitool -I <span class="built_in">open</span> lan print <span class="number">1</span>                           <span class="comment">## 显示BMC通道的信息，如果不知道BMC使用的是哪个通道，请使用下面的命令确认：</span>
ipmitool -I <span class="built_in">open</span> channel info <span class="number">1</span>
ipmitool -I <span class="built_in">open</span> lan <span class="built_in">set</span> <span class="number">1</span> ipsrc static                <span class="comment">## 设置本地BMC地址为静态，才能设置IP</span>
ipmitool -I <span class="built_in">open</span> lan <span class="built_in">set</span> <span class="number">1</span> ipaddr <span class="number">10.53</span>.11.113         <span class="comment">## 设置本地BMC的IP地址</span>
ipmitool -I <span class="built_in">open</span> lan <span class="built_in">set</span> <span class="number">1</span> netmask <span class="number">255.255</span>.255.0       <span class="comment">## 子网掩码，别忘了设</span>
ipmitool -I <span class="built_in">open</span> lan <span class="built_in">set</span> <span class="number">1</span> defgw ipaddr <span class="number">10.53</span>.11.254   <span class="comment">## 网关，可设可不设</span>
ipmitool user list <span class="number">1</span>                                    <span class="comment">## 查看BMC的用户列表</span>
ipmitool user <span class="built_in">set</span> name <span class="number">1</span> username                        <span class="comment">## 对BMC的1号用户设置用户名username</span>
ipmitool user <span class="built_in">set</span> password <span class="number">1</span> <span class="number">123456</span>                    <span class="comment">## 对BMC的1号用户设置密码123456</span>
</code></pre><h3 id="个别IPMITool命令列举">个别IPMITool命令列举</h3><pre><code>ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> sensor thresh   <span class="comment"># 配置ID值等于id的监测项的各种限制值。</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis status  <span class="comment"># 查看主板状态，其中包括了主板电源信息，主板工作状态等</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis restart_cause  <span class="comment"># 查看上次系统重启的原因</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis policy list  <span class="comment"># 查看支持的底盘电源相关策略。</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis power <span class="keyword">on</span> <span class="comment"># 启动底盘，用此命令能够远程开机</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis power off <span class="comment"># 关闭底盘，用此命令能够远程关机</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> chassis power reset <span class="comment">#实现硬重启，用此命令能够远程重启</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> mc reset <span class="comment"># 使BMC重新硬启动</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> mc info <span class="comment"># 查看BMC硬件信息</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> mc setenables =[<span class="keyword">on</span>|off] <span class="comment">#配置bmc相应的允许/禁止选项。</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> mc getenables <span class="comment"># 列出BMC任何允许的选项</span>
ipmitool -I lanplus -H <span class="variable">&lt;ip&gt;</span> -p <span class="variable">&lt;port&gt;</span> -C <span class="number">3</span> -U <span class="variable">&lt;user&gt;</span> -P <span class="variable">&lt;password&gt;</span> lan print <span class="number">1</span> <span class="comment"># 打印channel 1的信息</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>智能平台管理界面（IPMI，Intelligent Platform Management Interface）是管理基于 Intel结构的企业级系统中所使用的外围设备采用的一种工业标准，用户能够利用IPMI监控服务器的物理健康特征，如温度、电压、风扇工作状态、电源状 态等。该标准由美国英特尔、惠普（Hewlett-Packard）、NEC、美国戴尔电脑和SuperMicro等公司定制。新的版本是 IPMI2.0（<a href="http://www.intel.com/design/servers/ipmi/）。">http://www.intel.com/design/servers/ipmi/）。</a>]]>
    
    </summary>
    
      <category term="编程-网络协议" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Log4j中的NDC和MDC]]></title>
    <link href="http://luoyuan800.github.io/2015/06/30/Log4j-N-MDC/"/>
    <id>http://luoyuan800.github.io/2015/06/30/Log4j-N-MDC/</id>
    <published>2015-06-30T04:08:35.000Z</published>
    <updated>2015-06-30T04:52:27.606Z</updated>
    <content type="html"><![CDATA[<p>Log4j中的NDC和MDC两个功能类似，都是用于存储上下文的信息。<a id="more"></a></p>
<h2 id="基本概念">基本概念</h2><p>NDC（Nested Diagnostic Context）MDC（Mapped Diagnostic Context）是一种嵌套诊断环境的机制。这种机制的提出，主要为了减少多线程的系统为每个客户单独记录日志的系统开销。就是说在多线程和多并发系统中年，这个模式可以只使用一个logger实例，记录每个线程的日志信息，并且会带上各个线程独特的标识信息。更多的时候这两张机制是作用在一个网络应用上，特别是一个服务平台要同时提过服务给多个客户的时候，需要追踪每个客户的信息并且记录日志的时候，使用客户的唯一标识放入到NDC或者MDC中，从而使得在log信息中更容易查看到哪一个客户触发了log事件。个人理解这个两个功能是存储额外的信息，并且可以在新版本的log4j是用MDCFilter或者NDCFilter来级能进行log文本的过滤。</p>
<h2 id="NDC与MDC的区别">NDC与MDC的区别</h2><p>NDC与MDC的区别在于存储方式的不同。<br>NDC是使用 栈的机制来存储信息，而MDC使用map的机制来存储信息。所以NDC可以通过%x来进行获取，而MDC需要通过%x{key}来获取</p>
<h2 id="使用方式">使用方式</h2><p>在log的pattern的配置中使用%x来 显示NDC 或者MDC信息。<br>在代码中设定NDC或者MDC必须在调用logger的记录方法之前，而且要保证在退出当前环境（当前代码段）的时候将信息移除，以免造成内存溢出</p>
<pre><code>……
NDC.push<span class="params">(message)</span>;
……
logger.info<span class="params">()</span>;
NDC.pop<span class="params">()</span>;
……
NDC.remove<span class="params">()</span>;<span class="comment">//在结束当前线程执行的时候要调用这个方法</span>
</code></pre><p>使用MDC的方式大致相同，只不过是需要提供key来作为信息的映射。</p>
<pre><code>……
<span class="tag">MDC</span><span class="class">.put</span>(<span class="tag">key</span>,<span class="tag">message</span>);
……
<span class="tag">logger</span><span class="class">.infog</span>();
……
<span class="tag">MDC</span><span class="class">.remove</span>(<span class="tag">key</span>);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Log4j中的NDC和MDC两个功能类似，都是用于存储上下文的信息。]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[About the Cron Expression]]></title>
    <link href="http://luoyuan800.github.io/2015/06/30/Cron-English/"/>
    <id>http://luoyuan800.github.io/2015/06/30/Cron-English/</id>
    <published>2015-06-30T03:44:14.000Z</published>
    <updated>2015-06-30T03:52:34.173Z</updated>
    <content type="html"><![CDATA[<p>Cron is use in Linux for the time schedule <a id="more"></a></p>
<h2 id="Format">Format</h2><p>Seconds Minutes Hours DayofMonth DayofWeek [Year]<br>The value of each row </p>
<table>
<thead>
<tr>
<th style="text-align:center">Second</th>
<th style="text-align:center">Minute</th>
<th style="text-align:center">Hours</th>
<th style="text-align:center">DayofMonth</th>
<th style="text-align:center">DayofWeek</th>
<th style="text-align:center">Year</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">, - * / 0-59</td>
<td style="text-align:center">, - * / 0-59</td>
<td style="text-align:center">, - * / 0-23</td>
<td style="text-align:center">, - * / 1-12 JAN-DEc</td>
<td style="text-align:center">, - * / ? L C # 1-7 SUN-SAT</td>
<td style="text-align:center">, - * / 1970-2099</td>
</tr>
</tbody>
</table>
<h2 id="Special_character:">Special character:</h2><pre><code>1. \* every
2. ? If the DayofMonth <span class="operator"><span class="keyword">use</span> \*, the <span class="keyword">DayofWeek</span> must <span class="keyword">use</span> ? <span class="keyword">to</span> <span class="keyword">match</span> <span class="keyword">any</span>
<span class="number">3.</span> \- Rang <span class="number">5</span>\-<span class="number">7</span> means5, <span class="number">6</span>, <span class="number">7</span> <span class="keyword">match</span>
<span class="number">4.</span> / <span class="built_in">interval</span> <span class="keyword">for</span> <span class="keyword">each</span>, <span class="number">0</span>/<span class="number">30</span> means <span class="keyword">start</span> <span class="keyword">when</span> <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">each</span> <span class="number">30</span> will <span class="keyword">match</span>.
<span class="number">5.</span> , It <span class="keyword">use</span> <span class="keyword">for</span> list
<span class="number">6.</span> L Means <span class="keyword">Last</span>
<span class="number">7.</span> W <span class="keyword">Work</span> <span class="keyword">day</span></span>
</code></pre><h2 id="Sample">Sample</h2><p>0 5,15, * * * ? every week every month each hours 5 and 15 minute match.<br>0 0 10,14,16 * * ? Every day 10am, 2pm, 4 pm match.<br>0 15 10 L * ? The last day of each month at 10:15 am </p>
<h2 id="Chinese_version_for_this_blog">Chinese version for this blog</h2><p><a href="../QuartZ-Cron">中文版</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Cron is use in Linux for the time schedule]]>
    
    </summary>
    
      <category term="编程-Linux" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cron 表达式入门]]></title>
    <link href="http://luoyuan800.github.io/2015/06/30/QuartZ-Cron/"/>
    <id>http://luoyuan800.github.io/2015/06/30/QuartZ-Cron/</id>
    <published>2015-06-30T01:28:52.000Z</published>
    <updated>2015-06-30T03:47:38.873Z</updated>
    <content type="html"><![CDATA[<p>关于cron表达式的基本概念介绍。<a id="more"></a></p>
<h2 id="Cron表达式简介">Cron表达式简介</h2><p>Cron是Linux中的计划任务管理系统，cron表达式可以用来定义一个计划时间来约定执行工作。<br>Cron表达式使用空格进行各个时间段的分隔，每个字段的范例格式如下表：<br>（年份可以留空，但是其他不可留空）</p>
<table>
<thead>
<tr>
<th style="text-align:center">Second</th>
<th style="text-align:center">Minut</th>
<th style="text-align:center">Hours</th>
<th style="text-align:center">DysofMounth</th>
<th style="text-align:center">Mounth</th>
<th style="text-align:center">DayofWeek</th>
<th style="text-align:center">Year</th>
<th style="text-align:right">Means</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">5,15</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">?</td>
<td style="text-align:center"></td>
<td style="text-align:right">每个小时的第五分钟，第十五分钟触发</td>
</tr>
</tbody>
</table>
<h2 id="Cron表达式中各个字段的可用字符">Cron表达式中各个字段的可用字符</h2><table>
<thead>
<tr>
<th>字段名称</th>
<th>字段可用字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>Seconds Minutes</td>
<td>, - * / 0-59</td>
</tr>
<tr>
<td>Hours</td>
<td>, - * / 0-23</td>
</tr>
<tr>
<td>DayofMonth</td>
<td>, - * / ? L W C 0-31</td>
</tr>
<tr>
<td>Month</td>
<td>, - * / 1-12 JAN-DEc</td>
</tr>
<tr>
<td>DayofWeek</td>
<td>, - * / ? L C # 1-7 SUN-SAT (1表示星期天，2表示星期一， 依次类推 )</td>
</tr>
<tr>
<td>Year</td>
<td>, - * / 1970-2099</td>
</tr>
</tbody>
</table>
<h2 id="特殊字符含义">特殊字符含义</h2><ol>
<li><strong>*</strong> 表示匹配该域的任意值，假如在Minutes域使用*, 即表示每分钟都会触发事件。</li>
<li><strong>?</strong> 只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和 DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*。 </li>
<li><strong>-</strong> 表示范围，例如在Minutes域使用5-20，表示从当前小时内的第5分到20分钟每分钟触发一次 </li>
<li><strong>/</strong> 表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着第5分钟触发一次，而第25，第45等分别触发一次. </li>
<li><strong>,</strong>  表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在第5和第20分每分钟触发一次。 </li>
<li><strong>L</strong> 表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在当前月份的最后的一个星期四触发。 </li>
<li><strong>W</strong> 表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一 到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 </li>
<li><strong>LW</strong> 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 </li>
<li><strong>#</strong> 用于确定每个月第几个星期几，只能出现在DayofWeek域。例如在4#2，表示某月的第二个星期三。</li>
<li>由于”DayofMonth “和”DayofWeek”这两个元素互斥的,必须要对其中一个设置?</li>
<li>\?字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值。当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”</li>
<li>L 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写。但是它在两个子表达式里的含义是不同的。</li>
<li>在天（月）子表达式中，“L”表示一个月的最后一天</li>
<li>在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT</li>
<li>如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五</li>
</ol>
<h2 id="举例">举例</h2><p>“0 0 10,14,16 * * ?” 每天上午10点，下午2点，4点<br>“0 0/30 9-17 * * ?” 朝九晚五工作时间内每半小时<br>“0 0 12 ? * WED” 表示每个星期三中午12点<br>“0 0 12 * * ?” 每天中午12点触发<br>“0 15 10 ? * *“ 每天上午10:15触发<br>“0 15 10 * * ?” 每天上午10:15触发<br>“0 15 10 * * ? <em>“ 每天上午10:15触发<br>“0 15 10 \</em> * ? 2005” 2005年的每天上午10:15触发<br>“0 * 14 * * ?” 在每天下午2点到下午2:59期间的每1分钟触发<br>“0 0/5 14 * * ?” 在每天下午2点到下午2:55期间的每5分钟触发<br>“0 0/5 14,18 * * ?” 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发<br>“0 0-5 14 * * ?” 在每天下午2点到下午2:05期间的每1分钟触发<br>“0 10,44 14 ? 3 WED” 每年三月的星期三的下午2:10和2:44触发<br>“0 15 10 ? * MON-FRI” 周一至周五的上午10:15触发<br>“0 15 10 15 * ?” 每月15日上午10:15触发<br>“0 15 10 L * ?” 每月最后一日的上午10:15触发<br>“0 15 10 ? * 6L” 每月的最后一个星期五上午10:15触发<br>“0 15 10 ? * 6L 2002-2005” 2002年至2005年的每月的最后一个星期五上午10:15触发<br>“0 15 10 ? * 6#3” 每月的第三个星期五上午10:15触发 </p>
<h2 id="英文版">英文版</h2><p><a href="../Cron-English">cron-English</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于cron表达式的基本概念介绍。]]>
    
    </summary>
    
      <category term="编程-Linux" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于Hexo构建博客并且部署到Github上]]></title>
    <link href="http://luoyuan800.github.io/2015/06/30/Hexo-GitHub/"/>
    <id>http://luoyuan800.github.io/2015/06/30/Hexo-GitHub/</id>
    <published>2015-06-30T00:53:00.000Z</published>
    <updated>2015-07-01T07:20:08.489Z</updated>
    <content type="html"><![CDATA[<p>一个简单的Hexo构建博客的入门资料<a id="more"></a></p>
<h2 id="环境准备">环境准备</h2><ol>
<li>注册一个Github账号<br>这一步就忽略不说了</li>
<li>下载Node安装（如果有需要可以配置path路径）<br>Node可以下载对应操作系统的安装版本，安装后会自动设置path</li>
<li><p>安装hexo<br>执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化hexo<br>创建自定义目录用来存放hexo项目，在这个目录下执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="构建博客页面">构建博客页面</h2><ol>
<li><p>在之前生成的hexo项目的目录下执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g  <span class="comment"># 这个是命令 hexo generate 的简写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到在当前目录下生成了一个public的目录，这个目录就是你博客页面</p>
</li>
<li><p>启动本地server查看页面 执行命令： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> s  <span class="comment"># 这个命令是hexo server的简写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在浏览器输入 localhost:4000查看效果</p>
</li>
</ol>
<h2 id="博客风格设置">博客风格设置</h2><h3 id="拷贝别人已经设计好的风格">拷贝别人已经设计好的风格</h3><p>1.1 下载别人写好的风格文件夹并且放到项目目录的themes 目录下面</p>
<p>1.2 然后更改项目根目录下的_config.yml的文件中的 theme: thems_name</p>
<h3 id="修改博客的theme">修改博客的theme</h3><p>2.1 找到你当前使用的theme的文件夹，在其中有一个_config.yml文件。</p>
<p>2.2 打开这个文件进行编辑即可以修改页面布局和一些其他的内容。</p>
<h2 id="发表或者编辑文章">发表或者编辑文章</h2><ol>
<li>在项目目录的 ./source/_posts 目录下的 *.md文件就是文章内容，可以是用文本编辑器打开编辑</li>
<li><p>文件的格式：（注意所有冒号后面都要有一个空格）</p>
<pre><code><span class="label">title:</span> postName <span class="preprocessor">#文章页面上的显示名称，可以任意修改，不会出现在URL中</span>
<span class="label">date:</span> <span class="number">2013</span>-<span class="number">12</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">16</span> <span class="preprocessor">#文章生成时间，一般不改，当然也可以任意修改</span>
<span class="label">categories:</span> example <span class="preprocessor">#分类 可选，设置了的会自动归类</span>
<span class="label">tags:</span> [tag1,tag2,tag3] <span class="preprocessor">#文章标签，可空，多标签请用格式，注意:后面有个空格</span>
---
这里是正文
</code></pre></li>
</ol>
<ol>
<li><p>摘要显示可以是用&lt;!--more-->放在作为摘要的文字后面</p>
<pre><code>title: Hello
---
这里是摘要<span class="comment">&lt;!--more--&gt;</span>
这里是正文
</code></pre></li>
</ol>
<h2 id="部署博客到网络上">部署博客到网络上</h2><ul>
<li>使用github提供的空间可以部署刚刚用hexo构建的博客：</li>
<li>在github上创建衣和用户名相关的项目（名字格式是固定的）, 例如：luoyuan800.github.io</li>
<li>将刚刚构建的hexo项目下的public文件夹中的都push到git项目中（拷贝后push）</li>
<li>访问 <a href="http://luoyuan800.github.io">http://luoyuan800.github.io</a> 即可以查看博客。（将其中的luoyuan800换成你的用户名）</li>
<li>如果发现不能访问的话，确认名称的格式，还有git用户中要配置一个已经verify的邮箱。</li>
</ul>
<h2 id="配置评论系统">配置评论系统</h2><p>默认的静态网页是不提供评论的，而Hexo这个框架搭建的博客默认是可以简单设置使用disqus搭建评论<br>而国内用户没办法是用disqus，可以选择使用多说（duoshuo）。</p>
<ol>
<li>去多说的网站<a href="http://duoshuo.com/" target="_blank" rel="external">http://duoshuo.com/</a> 注册一个账号（可以使用第三方QQ微博之类的登录）然后注册一个shortname</li>
<li>我是使用Jacman（Theme）的模块搭建博客的，那么只需要打开这个Theme的文件下面的_config.yml文件，找到其中的#### Comment这一段，然后在对应的duoshuo_shortname后面添加你的shortname就可以加载评论模块了</li>
</ol>
<h2 id="配置站内搜索">配置站内搜索</h2><p>我使用的是jacman主题，这个主题可以简单的配置基于Google，百度， tinysou这个三种站内搜索工具。<br>因为Google访问比较麻烦，百度检索的收录速度超级慢，我选择了tinysou这个工具。</p>
<ul>
<li>打开<a href="http://tinysou.com/plan.html" target="_blank" rel="external">tinysou</a></li>
<li>选择立即注册（免费版），用邮箱注册一个账号并且验证</li>
<li>进入控制台创建一个Engines</li>
<li>进入你创建的Engines的管理页面，点击爬虫选项卡，在其中添加博客的域名（luoyuan800.github.io)</li>
<li>打开hexo项目中themes文件夹中的jacman文件夹中的_config.yml文件， 修改一下内容：<pre><code><span class="string">tinysou_search:</span>     ## <span class="string">http:</span><span class="comment">//tinysou.com/</span>
<span class="label">  enable:</span> <span class="literal">true</span>
<span class="label">  id:</span> engine key ## e.g. <span class="string">"4ac092ad8d749fdc6293"</span> <span class="keyword">for</span> your tiny search id
</code></pre></li>
<li>在Hexo项目目录下的sources文件夹下面创建一个search文件夹</li>
<li>在刚刚创建的文件夹下面创建一个index.md文件，其中填写内容<pre><code>layout: search 
<span class="header">title: search
---</span>
</code></pre></li>
</ul>
<h2 id="添加RSS功能">添加RSS功能</h2><p>jacman主题漠然开启RSS模块，不过如果你直接使用点击RSS只会返回404。因为HEXO默认是没有生成RSS文件的</p>
<ul>
<li><p>安装hexo的rss插件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑项目文件下的_config.yml文件添加如下内容<br>  feed:</p>
<pre><code>type: atom       <span class="hexcolor">#fee</span>d 类型 (atom/rss2)
path: atom<span class="class">.xml</span>   <span class="id">#rss</span> 路径
limit: <span class="number">20</span>        #在 rss 中最多生成的文章数(<span class="number">0</span>显示所有)
</code></pre></li>
<li>重新构建网站并且上传到你的网站空间<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">``</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注：以上所有修改完成后都需要重新构建项目然后发布public文件下的文件才可以看到效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个简单的Hexo构建博客的入门资料]]>
    
    </summary>
    
      <category term="网站-工具" scheme="http://luoyuan800.github.io/categories/%E7%BD%91%E7%AB%99-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>