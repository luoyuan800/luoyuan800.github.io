<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yuan]]></title>
  <subtitle><![CDATA[一点一滴，技术积累]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://luoyuan800.github.io//"/>
  <updated>2016-10-31T04:26:33.852Z</updated>
  <id>http://luoyuan800.github.io//</id>
  
  <author>
    <name><![CDATA[Luo Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[勇者闯迷宫]]></title>
    <link href="http://luoyuan800.github.io/2016/10/31/maze_never_end/"/>
    <id>http://luoyuan800.github.io/2016/10/31/maze_never_end/</id>
    <published>2016-10-31T02:00:01.000Z</published>
    <updated>2016-10-31T04:26:33.852Z</updated>
    <content type="html"><![CDATA[<p>自己写的一个小游戏<a id="more"></a></p>
<blockquote>
<h2 id="勇者闯迷宫">勇者闯迷宫</h2></blockquote>
<p>Android 二维码下载</p>
<p><img src="http://7xk7ce.com1.z0.glb.clouddn.com/1477882861.png" alt="二维码"> </p>
<p><a href="http://bmob-cdn-5020.b0.upaiyun.com/2016/10/29/0959d79c406e809080bc8ac0e5f6f9ee.apk" target="_blank" rel="external">Androd下载</a></p>
<hr>
<ul>
<li>勇者闯迷宫浴火归来，更加合理的数据设计，更加多的怪物，更加坚固的作弊检测。</li>
<li>剧情：是谁建造了迷宫，是谁把主人公丢在这个迷宫里，为什么有那么多稀奇古怪的怪物，是谁在背后操控着主角的命运，那些神经兮兮的NPC又是谁，残缺的文档隐藏着什么样的历史？</li>
<li>玩法：一款放置类的冒险游戏。自由PK，万人同服，完全免费。<strong>宠物</strong>培养，宠物竞技，宠物排行，离线挂机。完全自由的<strong>装备打造</strong>系统，任意搭配的技能组合。你想得到的，都可以玩到，如果没有，告诉我，更新给你加上去！持续更新各种游戏内容，欢迎您的建议！</li>
<li>欢迎加群 543177861</li>
</ul>
<hr>
<h2 id="玩家自定义装备、宠物展示">玩家自定义装备、宠物展示</h2><h2 id=""><img src="http://7xk7ce.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720161031112323.jpg" alt="装备自定义"><img src="http://7xk7ce.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720161031112341.jpg" alt="装备自定义"> <img src="http://7xk7ce.com1.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720161031112405.jpg" alt="宠物培育"></h2><h3 id="更新日志">更新日志</h3><h5 id="3-4_更新_2016-10-29">3.4 更新 2016-10-29</h5><ul>
<li>增加宠物排名争夺</li>
<li>增加十二生肖相关宠物</li>
</ul>
<h5 id="3-3-7_更新_2016-10-23">3.3.7 更新 2016-10-23</h5><ul>
<li>增加装备（饰品）升级系统</li>
</ul>
<h5 id="3-3-5_更新_2016-09-26">3.3.5 更新 2016-09-26</h5><ul>
<li>增加宠物升级功能</li>
</ul>
<h5 id="3-3-2_更新_2016-09-17">3.3.2 更新 2016-09-17</h5><ul>
<li>增加双倍锻造、加快游戏速度的道具</li>
</ul>
<h5 id="3-3_更新_2016-09-09">3.3 更新 2016-09-09</h5><ul>
<li>增加宠物特殊进化</li>
<li>增加20多种伊布</li>
</ul>
<h5 id="3-0_更新_2016-08-24">3.0 更新 2016-08-24</h5><ul>
<li>增加宠物进化的功能</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>自己写的一个小游戏]]>
    
    </summary>
    
      <category term="杂物" scheme="http://luoyuan800.github.io/categories/%E6%9D%82%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PipedOutputStream和PipedInputStream]]></title>
    <link href="http://luoyuan800.github.io/2016/10/30/piped-in-out/"/>
    <id>http://luoyuan800.github.io/2016/10/30/piped-in-out/</id>
    <published>2016-10-30T02:31:14.000Z</published>
    <updated>2016-10-28T02:32:29.961Z</updated>
    <content type="html"><![CDATA[<p>关于PipedOutputStream和PipedInputStream的一些使用问题。<a id="more"></a></p>
<h2 id="PipedOutputStream和PipedInputStream的用处">PipedOutputStream和PipedInputStream的用处</h2><p>当需要同时处理输入和输出的时候，可以尝试使用Piple实现类似于生产者和消费者的角色功能。其中Pipe的OutputStream是生产组，用来接受数据并且写入Piple中，PipedInputStream类似消费者，从Pipe中读取数据。所以在PipedInputStream和PipedOutPutStream源代码中可以看到变量和方法的命名都是和writer和receiver相关的。</p>
<h2 id="用法">用法</h2><p>一般来说我们需要使用两个线程分别处理Output和Input，就是说要在两个不同的线程中使用PipedOutputStream和PipedInputStream。<br>使用 <code>PipledOutputStream.connect(PipedInputStream)</code> 将两个管道连接在以前，这样PipedOutputStream会在接受到数据时调用PipedInputStream的receive方法从而实现将数据写入管道中。</p>
<h2 id="常见错误信息">常见错误信息</h2><h3 id="IOException(“Pipe_not_connected”)">IOException(“Pipe not connected”)</h3><p>如果只是实例化了PipedInputStream，但是没有调用connect方法（调用PipedInputStream 和PipedOutputStream的connect方法都是一样的效果），就会在InoutStream.read()方法中抛出这个异常。</p>
<h3 id="IOException(“Pipe_closed”)">IOException(“Pipe closed”)</h3><p>如果PipedOutputStream调用了close方法之后，InputStream还是继续调用read()方法就会抛出这个异常。</p>
<h3 id="IOException(“Write_end_dead”)">IOException(“Write end dead”)</h3><p>如果执行OutputStream的线程已经执行结束，但是没有调用PipedOutStream.close()。那么InputStream.read()方法就会抛出这个异常。解决方法就是负责生产数据的线程在执行完成之后应该马上调用PipedOutputStream.close()。</p>
<h3 id="IOException(“Pipe_broken”)">IOException(“Pipe broken”)</h3><p>这个异常在多线程同时执行才会发生的典型错误，并且发生带有一定的偶然性。当PipedInputStream正在执行read()方法的时候，负责生产数据（持有PipedOutputStream）的线程执行结束了，但是并没有在线程结束的时候调用OutputStream的close方法，那么就有可能导致这个异常发生。</p>
<h2 id="如何正确使用">如何正确使用</h2><ol>
<li>首先必须要有两个线程分别负责PipedInputStream和PipedOutputStream</li>
<li>最好能在各自线程执行结束的时候关闭各自负责的Stream</li>
<li>在负责生成数据的线程执行完成之后一定要马上关闭PipedOutputStream</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于PipedOutputStream和PipedInputStream的一些使用问题。]]>
    
    </summary>
    
      <category term="编程-Linux/Unix" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux-Unix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Groovy中unique方法性能分析]]></title>
    <link href="http://luoyuan800.github.io/2016/09/26/groovy_unique_performance/"/>
    <id>http://luoyuan800.github.io/2016/09/26/groovy_unique_performance/</id>
    <published>2016-09-26T02:59:21.000Z</published>
    <updated>2016-09-26T03:02:13.972Z</updated>
    <content type="html"><![CDATA[<p>最近发现使用Groovy中的集合去重unique方法似乎会导致运行时间变长。身为一个java程序员一直比较习惯用HashSet去过滤重复的数据，看到groovy中有这么一个去重复的方法，觉得挺方便，所以就很开心的用上了。但是测试以后发现，这个方法性能真的是很差劲的…… <a id="more"></a></p>
<h2 id="数字列表的去重">数字列表的去重</h2><h3 id="测试代码">测试代码</h3><p>首先是测试数值的比较，我以下代码分别测速list的大小为100， 10000， 1000000。</p>
<pre><code>random = new Random<span class="params">()</span>;
performanceReport<span class="params">(<span class="number">100</span>)</span>
performanceReport<span class="params">(<span class="number">10000</span>)</span>
performanceReport<span class="params">(<span class="number">10000000</span>)</span>
def performanceReport<span class="params">(int size)</span> {
    println<span class="params">(<span class="string">"Report for list size $size"</span>)</span>
    def list = [];
    <span class="params">(<span class="number">1</span>..size)</span>.each {
        list.add<span class="params">(random.nextInt<span class="params">(<span class="number">1000</span>)</span>)</span>
    }
    def start = System.currentTimeMillis<span class="params">()</span>;
    list.unique<span class="params">()</span>;
    def end = System.currentTimeMillis<span class="params">()</span>;
    def dur = end - start;
    dur /= <span class="number">1000</span>;
    println<span class="params">(<span class="string">"unique use time $dur s"</span>)</span>;
    list.clear<span class="params">()</span>;
    <span class="params">(<span class="number">1</span>..size)</span>.each {
        list.add<span class="params">(random.nextInt<span class="params">(<span class="number">1000</span>)</span>)</span>
    }
    start = System.currentTimeMillis<span class="params">()</span>;
    def uSet = new HashSet<span class="params">(list.size<span class="params">()</span>)</span>;
    <span class="keyword">for</span> <span class="params">(e in list)</span> {
        uSet.add<span class="params">(e)</span>;
    }
    end = System.currentTimeMillis<span class="params">()</span>;
    dur = end - start;
    dur /= <span class="number">1000</span>;
    println<span class="params">(<span class="string">"hash set use time $dur s"</span>)</span>;
    println<span class="params">('---------------------')</span>;
}
</code></pre><h3 id="测试结果">测试结果</h3><pre><code><span class="keyword">Report</span> <span class="keyword">for</span> <span class="keyword">list</span> size 100
unique <span class="keyword">use</span> time 0.006 <span class="literal">s</span>
hash <span class="keyword">set</span> <span class="keyword">use</span> time 0.006 <span class="literal">s</span>
---------------------
<span class="keyword">Report</span> <span class="keyword">for</span> <span class="keyword">list</span> size 10000
unique <span class="keyword">use</span> time 0.127 <span class="literal">s</span>
hash <span class="keyword">set</span> <span class="keyword">use</span> time 0.004 <span class="literal">s</span>
---------------------
<span class="keyword">Report</span> <span class="keyword">for</span> <span class="keyword">list</span> size 10000000
unique <span class="keyword">use</span> time 49.479 <span class="literal">s</span>
hash <span class="keyword">set</span> <span class="keyword">use</span> time 0.279 <span class="literal">s</span>
</code></pre><p>我重复运行了代码三遍，出来的结果都差不多，所以对比结果基本是确定的：</p>
<ol>
<li>List比较少元素的情况下，比如100以内，运行效率差不了多少</li>
<li>当List元素较多的时候，差异非常明显，特别是大容量List的运行结果，使用unique就绝对是一个错误的选择！</li>
</ol>
<h2 id="字符串列表的去重">字符串列表的去重</h2><h3 id="测试代码-1">测试代码</h3><p>我使用随机生成的十位英文字符串（只包含a、b、c）进行测试比较。测试运行比较列表大小为100、1000、100000的结果。</p>
<pre><code>random = new Random<span class="params">()</span>;
strings = ['a', 'b', 'c'];
performanceReport<span class="params">(<span class="number">100</span>)</span>
performanceReport<span class="params">(<span class="number">1000</span>)</span>
performanceReport<span class="params">(<span class="number">100000</span>)</span>
<span class="comment">//生成随机字符串</span>
def genString<span class="params">()</span>{
    def s = '';
    <span class="params">(<span class="number">1</span>..<span class="number">4</span>)</span>.each{
        def index = random.nextInt<span class="params">(strings.size<span class="params">()</span>)</span>;
        s += strings[index];
    }
    return s;
}
def performanceReport<span class="params">(int size)</span> {
    println<span class="params">(<span class="string">"Report for list size $size"</span>)</span>
    def list = [];
    <span class="params">(<span class="number">1</span>..size)</span>.each {
        list.add<span class="params">(genString<span class="params">()</span>)</span>
    ｝
    def start = System.currentTimeMillis<span class="params">()</span>;
    list.unique<span class="params">()</span>;
    def end = System.currentTimeMillis<span class="params">()</span>;
    def dur = end - start;
    dur /= <span class="number">1000</span>;
    println<span class="params">(<span class="string">"unique use time $dur s"</span>)</span>;
    list.clear<span class="params">()</span>;
    <span class="params">(<span class="number">1</span>..size)</span>.each {
        list.add<span class="params">(genString<span class="params">()</span>)</span>
    }
    start = System.currentTimeMillis<span class="params">()</span>;
    def uSet = new HashSet<span class="params">(list.size<span class="params">()</span>)</span>;
    <span class="keyword">for</span> <span class="params">(e in list)</span> {
        uSet.add<span class="params">(e)</span>;
    }
    end = System.currentTimeMillis<span class="params">()</span>;
    dur = end - start;
    dur /= <span class="number">1000</span>;
    println<span class="params">(<span class="string">"hash set use time $dur s"</span>)</span>;
    println<span class="params">('---------------------')</span>;
}
</code></pre><h3 id="测试结果-1">测试结果</h3><p>重复运行代码三遍，发现结果对比的差值都比较固定，所以可以取其中一个结果作为参考。</p>
<pre><code><span class="keyword">Report</span> <span class="keyword">for</span> <span class="keyword">list</span> size 100
unique <span class="keyword">use</span> time 0.002 <span class="literal">s</span>
hash <span class="keyword">set</span> <span class="keyword">use</span> time 0.005 <span class="literal">s</span>
---------------------
<span class="keyword">Report</span> <span class="keyword">for</span> <span class="keyword">list</span> size 1000
unique <span class="keyword">use</span> time 0.049 <span class="literal">s</span>
hash <span class="keyword">set</span> <span class="keyword">use</span> time 0.001 <span class="literal">s</span>
---------------------
<span class="keyword">Report</span> <span class="keyword">for</span> <span class="keyword">list</span> size 100000
unique <span class="keyword">use</span> time 30.716 <span class="literal">s</span>
hash <span class="keyword">set</span> <span class="keyword">use</span> time 0.019 <span class="literal">s</span>
</code></pre><ol>
<li>列表容量较少的时候（100左右），groovy的unique方法性能还是有一点点优势的</li>
<li>大容量的列表去重的时候，依旧比使用HashSet的速度慢了很多。所以如果大列表处理的时候，还是得选用HashSet。</li>
</ol>
<h2 id="Groovy_unique方法源码分析">Groovy unique方法源码分析</h2><p>unique方法的源码如下：</p>
<pre><code>public static &lt;T&gt; Collection&lt;T&gt; unique<span class="params">(Collection&lt;T&gt; self, boolean mutate)</span> {
    ArrayList answer = new ArrayList<span class="params">()</span>;
    Iterator i$ = self.iterator<span class="params">()</span>;
    <span class="comment">//双重循环</span>
    while<span class="params">(i$.hasNext<span class="params">()</span>)</span> {
        Object t = i$.next<span class="params">()</span>;
        boolean duplicated = <span class="literal">false</span>;
        Iterator i$<span class="number">1</span> = answer.iterator<span class="params">()</span>;
        <span class="comment">//循环传进来的带重复元素的列表而不是循环已经去重的列表</span>
        while<span class="params">(i$<span class="number">1</span>.hasNext<span class="params">()</span>)</span> {
            Object t2 = i$<span class="number">1</span>.next<span class="params">()</span>;
            <span class="keyword">if</span><span class="params">(coercedEquals<span class="params">(t, t2)</span>)</span> {
                duplicated = <span class="literal">true</span>;
                break;
            }
        }

        <span class="keyword">if</span><span class="params">(!duplicated)</span> {
            answer.add<span class="params">(t)</span>;
        }
    }

    <span class="keyword">if</span><span class="params">(mutate)</span> {
        self.clear<span class="params">()</span>;
        self.addAll<span class="params">(answer)</span>;
    }

    return <span class="params">(Collection)</span><span class="params">(mutate?self:answer)</span>;
}
</code></pre><p>可以发现，非常不幸的两个导致性能底下的代码实现</p>
<ol>
<li>双重循环</li>
<li>在判断重复元素的时候，是去循环原始的List，而不是新构建的容量较小的List，这个也会增加代码执行时间。</li>
</ol>
<h2 id="结论">结论</h2><p>一直以为这种框架性质的代码，一定是千锤百炼，写得优雅又高效的，不过事实就是：代码写得好看，性能并不一定好！<br>Groovy方法虽然便捷，但是使用内置的方法还是得谨慎，毕竟要处理超过100的列表是经常的事。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近发现使用Groovy中的集合去重unique方法似乎会导致运行时间变长。身为一个java程序员一直比较习惯用HashSet去过滤重复的数据，看到groovy中有这么一个去重复的方法，觉得挺方便，所以就很开心的用上了。但是测试以后发现，这个方法性能真的是很差劲的……]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Unix系统中的SHELL]]></title>
    <link href="http://luoyuan800.github.io/2016/07/22/unix-shell/"/>
    <id>http://luoyuan800.github.io/2016/07/22/unix-shell/</id>
    <published>2016-07-22T01:44:14.000Z</published>
    <updated>2016-07-26T03:45:12.850Z</updated>
    <content type="html"><![CDATA[<p>关于各个版本shell的介绍<a id="more"></a></p>
<h2 id="首先是各个操作系统上自带的shell的列表">首先是各个操作系统上自带的shell的列表</h2><table>
<thead>
<tr>
<th></th>
<th>SHELL</th>
<th>Solaris</th>
<th>HP-UX</th>
<th>AIX</th>
<th>LINUX</th>
</tr>
</thead>
<tbody>
<tr>
<td>BSH</td>
<td>/usr/bin/sh</td>
<td>-</td>
<td>/usr/bin/bsh</td>
<td>/bin/ash</td>
<td></td>
</tr>
<tr>
<td>CSH</td>
<td>/usr/bin/csh</td>
<td>/usr/bin/csh</td>
<td>/usr/bin/csh</td>
<td>/bin/csh</td>
<td></td>
</tr>
<tr>
<td>TCSH</td>
<td>/usr/bin/tcsh</td>
<td>-</td>
<td>-</td>
<td>/bin/tcsh</td>
<td></td>
</tr>
<tr>
<td>KSH88</td>
<td>/usr/bin/ksh</td>
<td>/usr/bin/ksh</td>
<td>/usr/bin/ksh</td>
<td>-</td>
</tr>
<tr>
<td>KSH93</td>
<td>/usr/dt/bin/dtksh</td>
<td>dtksh</td>
<td>/usr/bin/ksh93</td>
<td>-</td>
</tr>
<tr>
<td>BASH</td>
<td>/usr/bin/bash</td>
<td>-</td>
<td>-</td>
<td>/bin/bash</td>
</tr>
<tr>
<td>PDKSH</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>/bin/ksh</td>
</tr>
<tr>
<td>POSIXSH</td>
<td>/usr/xpg4/bin/sh</td>
<td>/bin/sh</td>
<td>/usr/bin/psh</td>
<td>/bin/sh</td>
</tr>
<tr>
<td>ZSH</td>
<td>/usr/bin/zsh</td>
<td>-</td>
<td>-</td>
<td>/bin/zsh</td>
</tr>
</tbody>
</table>
<p>默认情况下在上表中路径为/bin/sh的shell操作系统命令行默认的shell（可以通过修改配置文件改变）。<br>如果要切换到不同的shell，输入对应的shell即可启动。</p>
<h2 id="不同shell的个人看法">不同shell的个人看法</h2><ul>
<li>ksh适用与script开发，因为比较规范。</li>
<li>bash比较多人用，因为是Linux的默认shell，并且各种操作比较符合正常人使用。</li>
<li>zsh功能比较齐全，可以算是bash的扩展，但是坑人的是它不能使用退格键删除输入</li>
<li>bsh比较反人类操作，不支持方向键和删除键</li>
<li>csh虽然各个平台都有安装，但是不太适用需要编写script的人</li>
</ul>
<h2 id="关于shell的注意事项">关于shell的注意事项</h2><p>不要改变默认root用户登陆的shell，因为不是系统静态绑定的shell是可以被删除的，如果修改成非静态的shell会有root用户无法登陆的风险。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于各个版本shell的介绍]]>
    
    </summary>
    
      <category term="编程-Linux/Unix" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux-Unix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android ListView]]></title>
    <link href="http://luoyuan800.github.io/2016/01/31/android_ListView/"/>
    <id>http://luoyuan800.github.io/2016/01/31/android_ListView/</id>
    <published>2016-01-31T03:39:21.000Z</published>
    <updated>2016-01-31T03:47:50.111Z</updated>
    <content type="html"><![CDATA[<p>简单记录下ListView的使用方式。<br><a id="more"></a></p>
<h2 id="使用方式">使用方式</h2><p>创建ListView对象之后需要设置一个Adapter才可以显示数据。</p>
<h2 id="Adapter">Adapter</h2><p>ListView的Adapter是要展示的对象集合。一般使用的时候都会自己创建一个自定义的Adapter继承自BaseAdapter，在其中定义显示的内容和方式。</p>
<ol>
<li>getCount() 方法</li>
</ol>
<p>必须实现这个方法返回Adapter中数据的个数，需要这个个数来判断ListView是否需要显示滚动条。</p>
<ol>
<li>getItem(int position) 方法</li>
</ol>
<p>必须实现这个方法返回某个位置显示的对象</p>
<ol>
<li>getItemId(int position) 方法</li>
</ol>
<p>返回某个指定位置上显示的对象的唯一标示</p>
<ol>
<li>getView(final int position, View convertView, ViewGroup parent) 方法<br>返回用来显示单个数据的view。在这个方法中创建View对象并且设置显示的数据样式。参数里面 传进来的convertView是当前（position）说使用的View，这个是给View重用提供方便的。如果当前位置已经显示过了，那么这个View不为空，可以更新这个view的显示数据；如果当前位置是第一次显示，这个参数为空，需要在方法中手动创建。</li>
</ol>
<h2 id="ViewHolder">ViewHolder</h2><p>在网上找到的很多示例都会在Adapter中使用ViewHolder对象。<br>这个并不是android提供的一种机制，而是开发者约定俗成的重用View的一种方式。ListView可以实现View重用（拉动滚动条的时候，直接更新当前已经显示的view），使用一个额外的类ViewHolder来存储额外的数据，可以在update view显示新的数据的时候更加方便。</p>
<h2 id="一个简单的示例">一个简单的示例</h2><pre><code><span class="comment">/**
 * Copyright 2015 gluo.
 * ALL RIGHTS RESERVED.
 * Created by gluo on 11/2/2015.
 */</span>
ListView view = <span class="keyword">new</span> ListView(context);
view.setAdapter(<span class="keyword">new</span> BaseAdapter {

    <span class="function"><span class="keyword">public</span> <span class="title">PetAdapter</span><span class="params">(ArrayList&lt;String&gt;data)</span> </span>{
        adapterData = data;
    }

    <span class="keyword">private</span> List&lt;String&gt; adapterData;

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> adapterData != <span class="keyword">null</span> ? adapterData.size() : 0;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">String <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
        <span class="keyword">if</span> (position &gt;= getCount()) position = <span class="number">0</span>;
        <span class="function"><span class="keyword">return</span> adapterData.<span class="title">get</span><span class="params">(position)</span></span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
        <span class="keyword">return</span> position;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">View <span class="title">getView</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>{
        PetViewHolder holder;
        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) {
            holder = <span class="keyword">new</span> PetViewHolder();
            convertView = holder.view;
            convertView.setTag(holder);
        } <span class="keyword">else</span> {
            holder = (PetViewHolder) convertView.getTag();
        }
        String pet = getItem(position);
        holder.updatePet(pet);
        <span class="keyword">return</span> convertView;
    }

    <span class="class"><span class="keyword">class</span> <span class="title">PetViewHolder</span> </span>{
        <span class="keyword">private</span> TextView view = <span class="keyword">new</span> TextView(context);
        <span class="keyword">private</span> String pet;

        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">updatePet</span><span class="params">(<span class="keyword">final</span> String pet)</span> </span>{
            <span class="keyword">this</span>.pet = pet;
            view.setText(pet);           
        }
    }
}
</code></pre><h2 id="局限">局限</h2><p>ListView只能上下滚动，并且一行只会显示一条数据。如果需要一行显示多个数据的话需要在自定义View上下文章。但是要是实现自动换行是很复杂的。</p>
<h2 id="扩展">扩展</h2><p>有时候一次性加载太多数据到一个ListView中是很耗内存的。所以上拉加载更多就应运而生。Android原生不支持上拉加载更多。需要自己实现：</p>
<ol>
<li>一开始只加载有限的条数数据</li>
<li>判断上拉的时候是否到达底部</li>
<li>ListView中添加自定义的footView显示是否可以加载更多，或者一个按钮可以点击加载更多。</li>
<li><p>一个简单的例子</p>
<pre><code>package cn.gavin.utils.ui;

<span class="keyword">import</span> android.content.Context;
<span class="keyword">import</span> android.util.AttributeSet;
<span class="keyword">import</span> android.view.LayoutInflater;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.view.View.OnClickListener;
<span class="keyword">import</span> android.view.ViewGroup;
<span class="keyword">import</span> android.widget.AbsListView;
<span class="keyword">import</span> android.widget.AbsListView.OnScrollListener;
<span class="keyword">import</span> android.widget.ListView;
<span class="keyword">import</span> android.widget.TextView;

<span class="keyword">import</span> cn.gavin.R;

public <span class="class"><span class="keyword">class</span> <span class="title">LoadMoreListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> <span class="title">implements</span> <span class="title">OnScrollListener</span>,
        <span class="title">OnClickListener</span> </span>{
    <span class="comment">// 点击加载更多枚举所有状态</span>
    private enum DListViewLoadingMore {
        LV_LOADING, <span class="comment">// 普通状态</span>
        LV_NORMAL, <span class="comment">// 加载状态</span>
        LV_OVER <span class="comment">// 结束状态</span>
    }

    <span class="comment">/**
     * 自定义接口
     */</span>
    public interface OnRefreshLoadingMoreListener {
        <span class="comment">/**
         * 点击加载更多
         */</span>
        <span class="keyword">void</span> onLoadMore();

    }
</code></pre></li>
</ol>
<pre><code>    <span class="keyword">private</span> DListViewLoadingMore loadingMoreState = DListViewLoadingMore.LV_NORMAL;<span class="comment">// 加载更多默认状态.</span>

    <span class="keyword">private</span> View mLoadingView;<span class="comment">// 加载中...View(mFootView)</span>

    <span class="keyword">private</span> TextView mLoadMoreTextView;<span class="comment">// 加载更多.(mFootView)</span>

    <span class="keyword">private</span> OnRefreshLoadingMoreListener onRefreshLoadingMoreListener;<span class="comment">// 下拉刷新接口（自定义）</span>

    <span class="function"><span class="keyword">public</span> <span class="title">LoadMoreListView</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">super</span>(context, <span class="keyword">null</span>);
        initDragListView(context);
    }

    <span class="function"><span class="keyword">public</span> <span class="title">LoadMoreListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{
        <span class="keyword">super</span>(context, attrs);
        initDragListView(context);
    }

    <span class="comment">/**
     * 初始化ListView
     */</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initDragListView</span><span class="params">(Context context)</span> </span>{
        initLoadMoreView(context);<span class="comment">// 初始化footer</span>

        setOnScrollListener(<span class="keyword">this</span>);<span class="comment">// ListView滚动监听</span>
    }


    <span class="comment">/**
     * 初始化底部加载更多控件
     */</span>
    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">initLoadMoreView</span><span class="params">(Context context)</span> </span>{
        View mFootView = LayoutInflater.from(context).inflate(R.layout.footer, (ViewGroup) <span class="keyword">this</span>.findViewById(R.id.load_more_view));

        View mLoadMoreView = mFootView.findViewById(R.id.load_more_view);

        mLoadMoreTextView = (TextView) mFootView
                .findViewById(R.id.load_more_tv);

        mLoadingView = mFootView
                .findViewById(R.id.loading_layout);

        mLoadMoreView.setOnClickListener(<span class="keyword">this</span>);

        addFooterView(mFootView);
    }


    <span class="comment">/**
     * 底部点击事件
     */</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
        <span class="comment">// 防止重复点击</span>
        <span class="keyword">if</span> (onRefreshLoadingMoreListener != <span class="keyword">null</span>
                &amp;&amp; loadingMoreState == DListViewLoadingMore.LV_NORMAL) {
            switchFooterViewState(DListViewLoadingMore.LV_LOADING);
            onRefreshLoadingMoreListener.onLoadMore();<span class="comment">// 对外提供方法加载更多.</span>
        }

    }

    <span class="comment">/**
     * 点击加载更多
     *
     * <span class="doctag">@param</span> flag 数据是否已全部加载完毕
     */</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onLoadMoreComplete</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>{
        <span class="keyword">if</span> (flag) {
            switchFooterViewState(DListViewLoadingMore.LV_OVER);
        } <span class="keyword">else</span> {
            switchFooterViewState(DListViewLoadingMore.LV_NORMAL);
        }

    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onScroll</span><span class="params">(AbsListView view, <span class="keyword">int</span> firstVisibleItem,
                         <span class="keyword">int</span> visibleItemCount, <span class="keyword">int</span> totalItemCount)</span> </span>{
    }

    <span class="comment">/**
     * ListView 滑动监听
     */</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(AbsListView view, <span class="keyword">int</span> scrollState)</span> </span>{

    }

    <span class="comment">// 更新Footview视图</span>
    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">switchFooterViewState</span><span class="params">(DListViewLoadingMore state)</span> </span>{
        <span class="keyword">switch</span> (state) {
            <span class="comment">// 普通状态</span>
            <span class="keyword">case</span> LV_NORMAL:
                mLoadingView.setVisibility(View.GONE);
                mLoadMoreTextView.setVisibility(View.VISIBLE);
                mLoadMoreTextView.setText(<span class="string">"查看更多"</span>);
                <span class="keyword">break</span>;
            <span class="comment">// 加载中状态</span>
            <span class="keyword">case</span> LV_LOADING:
                mLoadingView.setVisibility(View.VISIBLE);
                mLoadMoreTextView.setVisibility(View.GONE);
                <span class="keyword">break</span>;
            <span class="comment">// 加载完毕状态</span>
            <span class="keyword">case</span> LV_OVER:
                mLoadingView.setVisibility(View.GONE);
                mLoadMoreTextView.setVisibility(View.VISIBLE);
                mLoadMoreTextView.setText(<span class="string">"加载完毕"</span>);
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                <span class="keyword">break</span>;
        }
        loadingMoreState = state;
    }


    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setOnLoadListener</span><span class="params">(OnRefreshLoadingMoreListener loadListener)</span></span>{
        <span class="keyword">this</span>.onRefreshLoadingMoreListener = loadListener;
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>简单记录下ListView的使用方式。<br>]]>
    
    </summary>
    
      <category term="编程-Android" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux学习积累]]></title>
    <link href="http://luoyuan800.github.io/2015/11/25/ubuntu/"/>
    <id>http://luoyuan800.github.io/2015/11/25/ubuntu/</id>
    <published>2015-11-25T01:44:14.000Z</published>
    <updated>2016-10-28T02:28:14.872Z</updated>
    <content type="html"><![CDATA[<p>自己用到过和遇见过得命令和异常陈列，基本是Ubuntu之类的界面和操作系统。<a id="more"></a></p>
<h2 id="Permission_denied">Permission denied</h2><p><code>sudo chmod -R 777 dell</code></p>
<p>此命令设置所有用户都有权限访问这个文件夹，其中<code>777=111111111</code>。</p>
<h2 id="如何安装bin文件">如何安装bin文件</h2><p><code>sudo chmod u+x name.bin</code></p>
<p>这个命令给予这个bin文件读写的权限</p>
<p><code>sudo name.bin</code></p>
<p>这个命令执行安装</p>
<h2 id="创建新用户">创建新用户</h2><p><code>sudo adduser &lt;username&gt;</code></p>
<h2 id="修改用户密码">修改用户密码</h2><p><code>sudo password &lt;username&gt;</code></p>
<h2 id="切换用户">切换用户</h2><p><code>su &lt;username&gt;</code></p>
<p>输入密码后就切换到对应的user了</p>
<p><code>su - &lt;username&gt;</code></p>
<p>这个命令会把当前设置的环境变量也带过去</p>
<h2 id="修改默认root用户的密码">修改默认root用户的密码</h2><p>如果安装时候直接设置了自己的用户名，那么root用户的密码就会是随机的（Ubuntu默认不开放root用户)。</p>
<p><code>sudo passwd</code></p>
<p>之后按照提示输入密码就可以修改root用户的密码了</p>
<h2 id="为特定用户添加sudo命令权限">为特定用户添加sudo命令权限</h2><p>有些用户没有运行sudo的权限，执行sudo的话会提示<code>username is not in the sudoers file</code><br>修改sudoers文件可以解决这个问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ su -root <span class="comment">## 切换root用户`</span></span><br><span class="line">$ chmod u+w /etc/sudoers <span class="comment"># 添加写权限</span></span><br><span class="line">$  /etc/sudoers </span><br><span class="line">$ <span class="comment"># 在打开的文本编辑器中，找到r**oot ALL=(ALL) ALL在下面添加一行 username ALL=(ALL) ALL</span></span><br><span class="line">$ <span class="comment"># 保存后记得关闭sudoers的写权限</span></span><br><span class="line">$ chmod u-w /etc/sudoers</span><br></pre></td></tr></table></figure></p>
<h2 id="挂载远程文件系统(mount_remote_filesystem_NFS)">挂载远程文件系统(mount remote filesystem NFS)</h2><ol>
<li>实现本机的文件系统可以被别的机器挂载</li>
</ol>
<p>1.1. 安装nfs服务器</p>
<p><code>sudo apt-get install nfs-kernel-server</code></p>
<p>1.2. 修改权限配置文件</p>
<p><code>vi /etc/exports</code></p>
<p>根据其中的范例添加你想要共享出去的文件目录（mount point）</p>
<p>1.3. 重启服务使得配置生效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> /etc/init.d/portmap restart</span><br><span class="line"><span class="variable">$sudo</span> /etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure></p>
<p>1.4. 你可以使用 <code>showmount -e</code> 命令查看共享成功的文件系统</p>
<ol>
<li>挂载命令</li>
</ol>
<p><code>sudo mount -t nfs localhost:/home /mnt</code></p>
<p>其中-t nfs 可以省略，会使用默认支持的nfs文件类型挂载。</p>
<h2 id="一些基本的命令提示‘command_not_found’">一些基本的命令提示‘command not found’</h2><p>（这个问题一般会出现在redhat 红帽系统中）<br>例如输入命令：<code>ifconfig</code><br>显示<code>bash: ifconfig: command not found</code><br>可能是路径问题，如果然后输入<br><code>/sbin/ifconfig</code>  就会显示IP地址等信息。<br>那么解决办法是<br>执行<code>cat ~/.bash_profile</code> 看自己的PATH，然后再执行：<br><code>gedit /etc/profile</code> 在最后一行后面添加：<br>PATH=$PATH:sbin<br>export PATH=$PATH:/sbin<br>保存退出。<br>然后在初始化一下：<code>source /etc/profile</code> 你再直接输入：<code>ifconfig</code> 就会直接显示IP等信息了</p>
<h2 id="error_while_loading_shared_libraries">error while loading shared libraries</h2><p>error while loading shared libraries：<strong>**</strong> ：cannot restore segment prot after reloc: Permission denied。<br>网上查了一下，原因是selinux的问题，selinux的设置太过严格导致的。解决的办法是在root用户下，修改/etc/selinux/config 文件<br>把SELINUX=enforcing 改成 SELINUX=disabled。<br>然后，保存关闭，重启机器就可以了。</p>
<h2 id="Linux开启ssh服务">Linux开启ssh服务</h2><ul>
<li>开启服务执行 /etc/init.d/sshd start</li>
<li>如果还是不能连接，尝试关闭防火墙<ul>
<li>输入 setup</li>
<li>在弹出界面选择firewall</li>
<li>选择 no firewall。</li>
</ul>
</li>
</ul>
<h2 id="修改ssh的最大连接并发数">修改ssh的最大连接并发数</h2><ul>
<li>打开文件进行编辑 ： vi /etc.ssh/sshd_config</li>
<li>找到 MazStartups 去掉注释，并且修改大最小和最大的数值。</li>
<li>重启ssh服务，可以尝试以下命令（不同内核）<ul>
<li>sudo systemctl restart sshd </li>
<li>/etc/rc.d/init.d/sshd restart </li>
<li>service sshd restart</li>
</ul>
</li>
</ul>
<h2 id="Linux_解压">Linux 解压</h2><ul>
<li>tar<ul>
<li>解压： tar xvf fileName.tar</li>
<li>打包： tar cvf vffileNametar dirName</li>
</ul>
</li>
<li>.gz<ul>
<li>解压： gunzip FileName.gz</li>
<li>解压： gzip -d FileName.gz</li>
<li>打包： gzip FileName dirName</li>
</ul>
</li>
<li>.tar.gz 和 .tgz<ul>
<li>解压： tar zxvf FileName.tar.gz</li>
<li>打包： tar zcvf FileName.tar.gz DirName</li>
</ul>
</li>
</ul>
<h2 id="Linux中的复制命令">Linux中的复制命令</h2><p>cp -rf source_dir target_dir</p>
<h2 id="查看Linux内核版本的命令">查看Linux内核版本的命令</h2><ul>
<li>命令： uname -a, 查看系统内核版本号及系统名称</li>
<li>命令： cat /proc/version, 查看目录”/proc”下version的信息，也可以得到当前系统的内核版本号及系统名称 </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>自己用到过和遇见过得命令和异常陈列，基本是Ubuntu之类的界面和操作系统。]]>
    
    </summary>
    
      <category term="编程-Linux/Unix" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux-Unix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android自动更新推送的实现]]></title>
    <link href="http://luoyuan800.github.io/2015/10/28/android_auto_update/"/>
    <id>http://luoyuan800.github.io/2015/10/28/android_auto_update/</id>
    <published>2015-10-28T03:39:21.000Z</published>
    <updated>2015-10-28T07:06:02.415Z</updated>
    <content type="html"><![CDATA[<p>当发布了一个Android app之后，我们最需要使用的功能就是如何实现当有更新的是推送给用户。<br><a id="more"></a></p>
<h2 id="实现思路">实现思路</h2><ol>
<li>首先是要申请一个可以直接访问的网盘放置你的更新文件</li>
<li>放置一个文件，里面注明更新后的版本号</li>
<li>在app的代码中每次启动的时候去下载那个标识有版本号的文件，然后匹配当前app的版本和，如果不一致，提示用户更新。</li>
</ol>
<h2 id="代码相关">代码相关</h2><h3 id="读取网络文件">读取网络文件</h3><p>首先是如何下载网络上文件。 Android不允许在UI主线程进行网络访问的操作，所以我们需要构建一个线程，无论是用<code>new Thread</code>还是用<code>handler.put(Runnable)</code> 都是可以的，在线程的run方法中进行网络访问或者下载：</p>
<pre><code><span class="keyword">private</span> <span class="keyword">void</span> checkUpdate() {
    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
        <span class="keyword">public</span> <span class="keyword">void</span> run() {
            <span class="keyword">try</span> {
                PackageInfo pInfo = getPackageManager().getPackageInfo(
                        getPackageName(), <span class="number">0</span>);<span class="comment">//获取当前的版本信息</span>
                currentVersion = pInfo.versionName.<span class="built_in">trim</span>();
                <span class="comment">// 构造URL</span>
                URL url = <span class="keyword">new</span> URL(VERSION_CHECK_URL);
                <span class="comment">// 打开连接</span>
                URLConnection con = url.openConnection();
                <span class="comment">//获得文件的长度</span>
                <span class="built_in">int</span> contentLength = con.getContentLength();
                <span class="comment">// 输入流</span>
                InputStream is = con.getInputStream();
                <span class="keyword">BufferedReader</span> br = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(is));

                <span class="built_in">int</span> curVersionCode = pInfo.versionCode;
                updateVersion = br.readLine().replace((<span class="built_in">char</span>) <span class="number">65279</span>, <span class="string">' '</span>).<span class="built_in">trim</span>();
                <span class="comment">//请注意这一行，只是为了防止网络上的文件使用了win的带BOM的编码文本，BOM文本第一行开头会有一个特殊的字符。</span>

                <span class="keyword">if</span> (updateVersion.equalsIgnoreCase(currentVersion)) {
                    <span class="comment">//不需要升级通知</span>
                } <span class="keyword">else</span> {
                    <span class="keyword">String</span> info = br.readLine();
                    versionUpdateInfo = <span class="keyword">new</span> StringBuilder(<span class="string">"新版本:"</span> + updateVersion);
                    <span class="keyword">while</span> (info != <span class="keyword">null</span> &amp;&amp; !info.isEmpty()) {
                    <span class="comment">//获取升级信息，你可以在升级的文本里面第一行写上版本号，第二行开始写上升级的详细信息。</span>
                        versionUpdateInfo.<span class="built_in">append</span>(<span class="string">"\n"</span>).<span class="built_in">append</span>(info);
                        info = br.readLine();
                    }
                   <span class="comment">//弹出一个窗口，提示用户可以进行升级</span>
                }
                br.close();
            } <span class="keyword">catch</span> (Exception e) {
                e.printStackTrace();
            }
        }
    }).start();
}
</code></pre><h3 id="下载更新包">下载更新包</h3><p> 下载升级包并且保存到本地SD卡，首先必须要设置SD卡的权限，这里不在赘述。以下代码是下载安装包并且保存到本地SD卡：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">boolean</span> downloadPAK(Handler handler) {
    <span class="keyword">try</span> {
        <span class="comment">// 构造URL</span>
        URL url = <span class="keyword">new</span> URL(PACKAGE_DOWNLOAD_URL);
        <span class="comment">// 打开连接</span>
        URLConnection con = url.openConnection();
        <span class="comment">//获得文件的长度</span>
        <span class="keyword">int</span> contentLength = con.getContentLength();

        <span class="comment">// 输入流</span>
        InputStream is = con.getInputStream();
        BufferedInputStream br = <span class="keyword">new</span> BufferedInputStream(is);
        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];
        <span class="keyword">int</span> len;
        <span class="comment">// 输出的文件流</span>
        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(APK_PATH + <span class="string">"/appName.apk"</span>);
        <span class="keyword">if</span> (<span class="keyword">file</span>.exists()) {
            <span class="keyword">file</span>.<span class="keyword">delete</span>();
        }
        <span class="keyword">File</span> path = <span class="keyword">new</span> <span class="keyword">File</span>(APK_PATH);
        <span class="keyword">if</span> (!path.exists()) {
            path.mkdirs();
        }
        <span class="keyword">file</span>.createNewFile();
        OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">file</span>);
        <span class="comment">// 开始读取</span>
        <span class="keyword">int</span> alreadySize = <span class="number">0</span>;
        <span class="keyword">while</span> ((len = is.<span class="keyword">read</span>(data)) != -<span class="number">1</span>) {
            os.<span class="keyword">write</span>(data, <span class="number">0</span>, len);
        }
        os.flush();
        os.close();
        br.close();
        <span class="comment">//通知用户下载成功</span>
        <span class="keyword">return</span> <span class="keyword">true</span>;
    } <span class="keyword">catch</span> (Exception e) {
        e.printStackTrace();
        Log.e(TAG, <span class="string">"DownloadUpdate"</span>, e);
    }
       <span class="comment">//通知用户下载失败</span>
    <span class="keyword">return</span> <span class="keyword">false</span>;
}
</code></pre><h3 id="自动安装APK">自动安装APK</h3><p>下载完成后我们要弹出安装提示给用户，并且保证安装能够完成：</p>
<pre><code><span class="keyword">private</span> void installAPK() {
    <span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>(<span class="type">Intent</span>.ACTION_VIEW);
    <span class="type">intent</span>.setDataAndType(Uri.fromFile(new <span class="keyword">File</span>(APK_PATH + <span class="string">"/appName.apk"</span>)),
            <span class="string">"application/vnd.android.package-archive"</span>);
    <span class="type">intent</span>.addFlags(<span class="type">Intent</span>.FLAG_ACTIVITY_NEW_TASK);//必须要加上这一句话才能保证安装完成后不会跳出到主界面
    context.startActivity(<span class="type">intent</span>);
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>当发布了一个Android app之后，我们最需要使用的功能就是如何实现当有更新的是推送给用户。<br>]]>
    
    </summary>
    
      <category term="编程-Android" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识Android]]></title>
    <link href="http://luoyuan800.github.io/2015/10/28/start_android/"/>
    <id>http://luoyuan800.github.io/2015/10/28/start_android/</id>
    <published>2015-10-28T00:39:21.000Z</published>
    <updated>2015-10-28T07:52:48.850Z</updated>
    <content type="html"><![CDATA[<p>以下是一些零散初级的Android相关知识。<br><a id="more"></a></p>
<h2 id="界面类">界面类</h2><p>展示在屏幕上的东西。在安卓中的基类为Activity。所有界面都是需要实现这个接口，并且实现相应的onCreate方法。</p>
<h2 id="布局">布局</h2><p>android中界面类是布局是分来来设定的，布局可以在一个放到res/layout文件夹中的xml文件来描述。布局文件的标识是一个整型的id：R.layout.id。需要在一个Activity的onCreate方法中使用setContentView方法将对应的布局文件绑定到这个Activity中。</p>
<h2 id="Local_String">Local String</h2><p>在界面中暂时的静态文字（不会动态改变的文字）是可以抽取到一个放置在res/value文件夹中的strings.xml中定义，可以在布局描述文件中使用id号来引用这个文字。</p>
<h2 id="主文件">主文件</h2><p>Android中的主文件，也就是Android程序的入口文件不是java类，而是AndroidManifest.xml文件，该文件中会描述到这个Android程序支持的版本，程序具有的手机操作权限。同时，如果我们定义了一个Activity类，那么需要将这个类名在Androidmanifest.xml中用<activity>标签声明一次，在程序运行的过程中才可以使用到这个界面。在文件中的<uses-sdk android:minsdkversion="11">标签限制了当前android项目开发中能够使用的功能的最低版本，而且也限制了生成的程序能够安装的最低版本。</uses-sdk></activity></p>
<h2 id="控件">控件</h2><p>Android中能显示给用户看的界面上基本元素就是控件，能够使用的控件对象在android.widget包内。可以在布局文件中通过和控件同名的标签来引用控件与定义控件属性。</p>
<h2 id="Activity切换">Activity切换</h2><p>从一个Activity切换到另外一个activity有两种场景：<br>需要使用到Intent主动设置切换的目的界面，然后调用startActivity（Intent）生成目的界面的实例。<br>当前界面被结束的时候，比如按下了手机的后退键，会被动的切换到上一个界面，如果没有上级界面就会退出程序。因为Intent是构建是需要制定源界面实例和目的界面类，所以可以实现后退的功能。<br>Activity的界面切换效果展示，默认的界面切换是直接展示下一个界面，我们可以设定界面切换动画，从而使得切换过程更加频繁。动画效果是用一个xml文件来描述，并且必须被放置在res/anim文件夹内。可以在发生界面切换的地方调用overridePendingTransition(进入的动画id, 退出的动画id)来设置切换动画。会发生界面切换地方包括：</p>
<p>1.调用了startActivity方法之后;</p>
<ol>
<li>在Activity的finished方法中调用了super.finished()之后。</li>
</ol>
<h2 id="ListView">ListView</h2><p>在Android中如果你需要展示一个列表，并且希望可以产生列表项的点击动作，那么可以选择一个ListView。可以在一个layout的xml文件中定义ListView。同时定义list_item的xml文件。最简便的而且推荐的方法是，是实现一个继承自ListActivity的类，那么这个Activity就实现了ListView的功能了，我们只需要定义一个List Item的layout文件就可以展示列表数据了。<br>ListView中要展示的数据是通过Adapter类来传入的，要展示到ListView中的数据组需要先放置到Adapter中，然后将Adapter设置给ListView实例。<br>ListView并不是直接使用Adapter的数据去构建直接的Item来展示数据，而是在Adapter中有getView的方法，这个方法会返回某个Item的展示View实例。一般情况下我们需要自己构建一个Adapter类的子类复写getView方法来设定用什么样的格式展示数据。<br>网络上说的很多的View缓存技术，就是对应大量List数据的展示并不是每一个Item都创建一个ItemView，而是将一个屏幕显示数量的View缓存起来，每次滚动ListView的时候，都是更新View，而不是重新创建，这样可以节省系统资源。这个功能就是通过Adapter的getView方法来实现的。</p>
<h2 id="R">R</h2><p>在Android的项目代码编写中，R这个静态常量是可以引用到我们定义在layout、value、anim…等文件夹中的XML资源的。<br>注意的是android.R引用到的是Android本身内置的资源。</p>
<h2 id="res文件夹">res文件夹</h2><p>res文件夹内的文件不能用数字命名</p>
<h3 id="anim">anim</h3><p>这个文件夹下放置动画效果的文件，如果你的项目中没有这个文件夹，可以手动创建。</p>
<h3 id="drawable">drawable</h3><p>这个文件夹内放置图片文件</p>
<h2 id="安装Android开发IDE_Android_Studio">安装Android开发IDE Android Studio</h2><ol>
<li><p>因为google被墙，所以我们需要在host文件中增加（HOSTS文件位置：C:\Windows\system32\drivers\etc\hosts）：</p>
<p> 74.125.237.1 dl-ssl.google.com</p>
</li>
<li><p>在Android Studio的安装文件BIN文件夹里打找到“idea.properties”，最后一行添加：<code>disable.android.first.run=true</code></p>
</li>
</ol>
<h2 id="启动Android虚拟机失败">启动Android虚拟机失败</h2><p>如果提示 Failed to obtain GLES 1.x extensions string!<br>有可能是因为远程操作电脑导致的这个问题,解决办法是打开虚拟机的配置，去掉Use Host GPU前面的√</p>
<h2 id="Android_开发过程中遇到的异常信息">Android 开发过程中遇到的异常信息</h2><h3 id="android-os-NetworkOnMainThreadException">android.os.NetworkOnMainThreadException</h3><p>Android4.0之后开始不允许在主线程内访问网络，所以只需要使用一个子线程去访问网络，并且使用消息机制返回网络访问的结果就可以避开这个异常了。</p>
<h3 id="ndroid-view-WindowLeaked">ndroid.view.WindowLeaked</h3><p>按字面了解，Window Leaked大概就是说一个窗体泄漏了，也就是我们常说的内存泄漏，为什么窗体会泄漏呢？产生原因：<br>我们知道Android的每一个Activity都有个WindowManager窗体管理器，同样，构建在某个Activity之上的对话框、PopupWindow也有相应的WindowManager窗体管理器。因为对话框、PopupWindown不能脱离Activity而单独存在着，所以当某个Dialog或者某个PopupWindow正在显示的时候我们去finish()了承载该Dialog(或PopupWindow)的Activity时，就会抛Window Leaked异常了，因为这个Dialog(或PopupWindow)的WindowManager已经没有谁可以附属了，所以它的窗体管理器已经泄漏了。<br>解决方法是关闭(finish)某个Activity前，要确保附属在上面的Dialog或PopupWindow已经关闭(dismiss)了。</p>
<h3 id="Android_showDialog时报错">Android showDialog时报错</h3><p>错误信息是<code>requestFeature() must be called before adding content</code></p>
<p>出现此问题是由于dialog.show()之前调用了dialog.setContentView()或者dialog.getwindow()等，正确的应该是dialog.show()之后调用dialog.setContentView()</p>
<h3 id="Service_Intent_must_be_explicit">Service Intent must be explicit</h3><p>android5.0 api=21以上要求启动service要设置packagename。</p>
<h3 id="Gradle_DSL_method_not_found:_‘android()’">Gradle DSL method not found: ‘android()’</h3><p>这个错误一般是在创建一个新的Android项目的时候报错，解决办法是删掉build.gradle中的<code>android{}</code>定义</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下是一些零散初级的Android相关知识。<br>]]>
    
    </summary>
    
      <category term="编程-Android" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于snmp4j发送 V3 trap]]></title>
    <link href="http://luoyuan800.github.io/2015/10/09/snmp4j-trap-v3/"/>
    <id>http://luoyuan800.github.io/2015/10/09/snmp4j-trap-v3/</id>
    <published>2015-10-09T08:10:14.000Z</published>
    <updated>2015-10-09T08:49:22.095Z</updated>
    <content type="html"><![CDATA[<p>基于snmp4j收集数据或者发送v1版本的trap比较简单，可以自己动手网上搜索，这里展示下如何发送v3的trap（因为网络上搜索不到）<br><a id="more"></a></p>
<h2 id="SNMP4J版本要求">SNMP4J版本要求</h2><p>snmp4j 2.2.2及以上的版本都会支持使用snmp v3</p>
<h2 id="发送SNMP_v3_Trap的代码">发送SNMP v3 Trap的代码</h2><pre><code><span class="preprocessor"><span class="keyword">import</span> org.snmp4j.PDU;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.ScopedPDU;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.Snmp;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.TransportMapping;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.UserTarget;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.mp.MPv3;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.mp.SnmpConstants;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.SecurityLevel;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.SecurityModels;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.SecurityProtocols;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.USM;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.UsmUser;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.UsmUserEntry;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.Address;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.GenericAddress;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.OID;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.OctetString;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.VariableBinding;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.transport.DefaultUdpTransportMapping;</span>

<span class="preprocessor"><span class="keyword">import</span> java.io.IOException;</span>

<span class="comment">/**
* 本类用于发送v3 Trap信息
*
* @author luoyuan
*/</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnmpSendV3Trap</span> </span>{

<span class="keyword">private</span> Snmp snmp = <span class="literal">null</span>;

<span class="keyword">private</span> Address targetAddress = <span class="literal">null</span>;

<span class="keyword">public</span> SnmpSendV3Trap(String target, int port) throws IOException {
    <span class="comment">//配置EngineID</span>
    OctetString localEngineID = <span class="keyword">new</span> OctetString(MPv3.createLocalEngineID());
    <span class="comment">// 设置目的地的IP和端口</span>
    targetAddress = GenericAddress.parse(String.format(<span class="string">"udp:%s/%s"</span>, target, port));
    TransportMapping transport = <span class="keyword">new</span> DefaultUdpTransportMapping();
    <span class="comment">//配置USM，传入 engine id</span>
    USM usm = <span class="keyword">new</span> USM(SecurityProtocols.getInstance(), localEngineID, <span class="number">0</span>);
    <span class="comment">//添加Usm user， 这里的配置的user， 目标接收端也正确认证才可以接受到这个trap</span>
    <span class="comment">//这里创建User的是全部使用null是表示使用NOAUTH_NOPRIV的模式发送trap</span>
    <span class="comment">//具体的Auth模式可以参考收集snmp数据，是一样配置的。</span>
    usm.updateUser(<span class="keyword">new</span> UsmUserEntry(<span class="keyword">new</span> OctetString(<span class="string">"luo"</span>), <span class="keyword">new</span> UsmUser(<span class="keyword">new</span> OctetString(<span class="string">"luo"</span>),
            <span class="literal">null</span>,
            <span class="literal">null</span>,
            <span class="literal">null</span>,
            <span class="literal">null</span>)));
    <span class="comment">//添加USM到Security Models中</span>
    SecurityModels.getInstance().addSecurityModel(usm);
    <span class="comment">//构建SNMP对象， 并且添加v3模式到其中</span>
    snmp = <span class="keyword">new</span> Snmp(transport);
    snmp.getMessageDispatcher().addMessageProcessingModel(<span class="keyword">new</span> MPv3(usm));
    transport.listen();

}

<span class="comment">/**
 * 向管理进程发送Trap报文
 *
 * @throws IOException
 */</span>
<span class="keyword">public</span> <span class="keyword">void</span> sendPDU() throws IOException {

    <span class="comment">// 设置 target, v3trap 一定要使用UserTarget</span>
    UserTarget target = <span class="keyword">new</span> UserTarget();
    target.setAddress(targetAddress);
    target.setVersion(SnmpConstants.version3);
    <span class="comment">//设置用户认证信息</span>
    target.setSecurityLevel(SecurityLevel.NOAUTH_NOPRIV);
    target.setSecurityName(<span class="keyword">new</span> OctetString(<span class="string">"luo"</span>));

    <span class="comment">// 创建 PDU, 注意这里要使用ScopedPDU</span>
    ScopedPDU pdu = <span class="keyword">new</span> ScopedPDU();
    pdu.add(<span class="keyword">new</span> VariableBinding(<span class="keyword">new</span> OID(<span class="string">".1.3.6.1.2.4407.11.1.1.1.1"</span>),
            <span class="keyword">new</span> OctetString(<span class="string">"SnmpTrap"</span>)));
    pdu.add(<span class="keyword">new</span> VariableBinding(<span class="keyword">new</span> OID(<span class="string">".1.3.6.1.2.4407.11.1.1.1.2"</span>),
            <span class="keyword">new</span> OctetString(<span class="string">"v3"</span>)));
    pdu.setType(PDU.TRAP);

    <span class="comment">// 发送trap</span>
    snmp.send(pdu, target);
}

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
    <span class="keyword">try</span> {
        SnmpSendV3Trap trapSender = <span class="keyword">new</span> SnmpSendV3Trap(<span class="string">"10.154.10.11"</span>, <span class="number">162</span>);
        trapSender.sendPDU();
    } <span class="keyword">catch</span> (IOException e) {
        e.printStackTrace();
    }
}
}
</code></pre><h2 id="接收_v3_trap_的代码">接收 v3 trap 的代码</h2><pre><code><span class="preprocessor"><span class="keyword">import</span> org.snmp4j.CommandResponder;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.CommandResponderEvent;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.MessageDispatcherImpl;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.Snmp;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.TransportMapping;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.mp.MPv3;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.SecurityModels;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.SecurityProtocols;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.USM;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.UsmUser;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.security.UsmUserEntry;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.Address;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.GenericAddress;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.OctetString;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.TcpAddress;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.UdpAddress;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.smi.VariableBinding;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.transport.DefaultTcpTransportMapping;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.transport.DefaultUdpTransportMapping;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.util.MultiThreadedMessageDispatcher;</span>
<span class="preprocessor"><span class="keyword">import</span> org.snmp4j.util.ThreadPool;</span>
<span class="preprocessor"><span class="keyword">import</span> java.io.IOException;</span>
<span class="preprocessor"><span class="keyword">import</span> java.util.Vector;</span>

<span class="comment">/**
 * 本类用于监听发送到本机的Trap信息
 *
 * @author luoyuan
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalTrapReceiver</span> <span class="keyword">implements</span> <span class="title">CommandResponder</span> </span>{

    <span class="keyword">private</span> MultiThreadedMessageDispatcher dispatcher;
    <span class="keyword">private</span> Snmp snmp = <span class="literal">null</span>;

    <span class="keyword">private</span> LocalTrapReceiver() throws IOException {
        dispatcher = <span class="keyword">new</span> MultiThreadedMessageDispatcher(ThreadPool.create(<span class="string">"snmp trap"</span>, <span class="number">2</span>),
                <span class="keyword">new</span> MessageDispatcherImpl());
        Address listenUdpAddress = GenericAddress.parse(<span class="string">"udp:0.0.0.0/162"</span>); <span class="comment">// udp监听端口</span>
        Address listenTCPAddress = GenericAddress.parse(<span class="string">"tcp:0.0.0.0/162"</span>); <span class="comment">// tcp监听端口</span>
        TransportMapping transport;
        <span class="comment">// 对TCP与UDP协议进行处理</span>
        DefaultUdpTransportMapping udpTransport = <span class="keyword">new</span> DefaultUdpTransportMapping(
                (UdpAddress) listenUdpAddress);
        DefaultTcpTransportMapping tcpTransport = <span class="keyword">new</span> DefaultTcpTransportMapping(
                (TcpAddress) listenTCPAddress);

        snmp = <span class="keyword">new</span> Snmp(dispatcher, udpTransport);
        snmp.addTransportMapping(tcpTransport);

        <span class="comment">//配置engine</span>
        OctetString localEngineID = <span class="keyword">new</span> OctetString(MPv3.createLocalEngineID());
        <span class="comment">//配置USM 和user，需要和发送trap的配置一样才可以成功接收trap</span>
        USM usm = <span class="keyword">new</span> USM(SecurityProtocols.getInstance(), localEngineID, <span class="number">0</span>);
        usm.updateUser(<span class="keyword">new</span> UsmUserEntry(<span class="keyword">new</span> OctetString(<span class="string">"luo"</span>), <span class="keyword">new</span> UsmUser(<span class="keyword">new</span> OctetString(<span class="string">"luo"</span>),
                <span class="literal">null</span>,
                <span class="literal">null</span>,
                <span class="literal">null</span>,
                <span class="literal">null</span>)));
        SecurityModels.getInstance().addSecurityModel(usm);
        snmp.getMessageDispatcher().addMessageProcessingModel(<span class="keyword">new</span> MPv3(usm));
        snmp.listen();
    }


    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="keyword">try</span> {
            snmp.addCommandResponder(<span class="keyword">this</span>);
            System.out.println(<span class="string">"开始监听Trap信息!"</span>);
        } <span class="keyword">catch</span> (Exception ex) {
            ex.printStackTrace();
        }
    }

    <span class="comment">/**
     * 当接收到trap时，会自动进入这个方法
     *
     * @param respEvnt
     */</span>
    <span class="keyword">public</span> <span class="keyword">void</span> processPdu(CommandResponderEvent respEvnt) {
        <span class="comment">// 解析Response并且直接打印出来</span>
        <span class="keyword">if</span> (respEvnt != <span class="literal">null</span> &amp;&amp; respEvnt.getPDU() != <span class="literal">null</span>) {
            System.out.println(<span class="string">"security name = "</span> + <span class="keyword">new</span> OctetString(respEvnt.getSecurityName()));
            Vector&lt;? <span class="keyword">extends</span> VariableBinding&gt; recVBs = respEvnt.getPDU().getVariableBindings();
            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; recVBs.size(); i++) {
                VariableBinding recVB = recVBs.elementAt(i);
                System.out.println(recVB.getOid() + <span class="string">" : "</span> + recVB.getVariable());
            }
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws IOException {
        LocalTrapReceiver localTrapReceiver = <span class="keyword">new</span> LocalTrapReceiver();
        localTrapReceiver.run();
    }

}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>基于snmp4j收集数据或者发送v1版本的trap比较简单，可以自己动手网上搜索，这里展示下如何发送v3的trap（因为网络上搜索不到）<br>]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[启用WinRm]]></title>
    <link href="http://luoyuan800.github.io/2015/09/22/WinRm/"/>
    <id>http://luoyuan800.github.io/2015/09/22/WinRm/</id>
    <published>2015-09-22T06:45:50.000Z</published>
    <updated>2015-09-23T01:54:11.487Z</updated>
    <content type="html"><![CDATA[<p>如何在Windows上配置启用WinRm<a id="more"></a></p>
<h2 id="在windows_server_system上配置WinRm">在windows server system上配置WinRm</h2><ol>
<li>使用Administrator账号登陆目标机器（不是Administrator用户组，而是Administrator账号）。</li>
<li>使用命令<code>winrm enumerate winrm/config/listener</code>查看WinRm在当前的机器上是否因配置过。</li>
<li>如果没有返回消息，就表明WinRm没有成功配置。</li>
<li>执行 <code>winrm quickconfig</code> 初始化WinRm</li>
<li>执行命令<code>winrm set winrm/config/service/auth @{Basic=&quot;true&quot;}</code> 配置登陆方式</li>
<li>执行 <code>winrm set winrm/config/service @{AllowUnencrypted=&quot;true&quot;}</code> 配置加密方式</li>
<li>执行 <code>winrm enumerate winrm/config/listener</code> 查看WinR是否成功配置</li>
<li>如果发现还是不能执行WinRm命令的话，打开端口http和https<ol>
<li><code>winrm quickconfig -transport:https</code></li>
<li><code>winrm quickconfig -transport:http</code></li>
</ol>
</li>
<li>如果发现以上命令执行不成功，那么尝试参考下面的步骤： 更换登陆方式为negotiate</li>
</ol>
<h2 id="WinRm_登陆方式设置">WinRm 登陆方式设置</h2><h3 id="默认的WinRm登陆是使用Basic的，但是Basic模式下是不能修改WinRm的配置，只能读取数据。如果需要修改配置，首先我们需要配置登陆模式为negotiate。">默认的WinRm登陆是使用Basic的，但是Basic模式下是不能修改WinRm的配置，只能读取数据。如果需要修改配置，首先我们需要配置登陆模式为negotiate。</h3><ol>
<li>首先需要打开注册表<code>regedit</code></li>
<li>找到注册表<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WSMAN\Service</code></li>
<li>修改键 <code>auth-negotiate</code> 为 1， <code>suth-basic</code> 为 0</li>
<li>重启系统</li>
</ol>
<h3 id="如果需要切换回Basic的登陆方式">如果需要切换回Basic的登陆方式</h3><ol>
<li>首先在Negotiate模式下执行<code>winrm set winrm/config/service/auth @{Basic=&quot;true&quot;}</code></li>
<li>然后再执行<code>winrm set winrm/config/service/auth @{Negotiate=&quot;false&quot;}</code></li>
</ol>
<h2 id="WinRm的用户组设置">WinRm的用户组设置</h2><ol>
<li>设定WinR用户组，我们可以指定特定的用户组具有访问WinRm的权限<ol>
<li>命令行执行lusrmgr.msc</li>
<li>在弹出窗口中选择users，然后选择你要给予权限的用户，点击右键选择properties</li>
<li>选择Member of的选项卡，在其中添加当前用户到某个指定用户组</li>
</ol>
</li>
<li>配置用户组权限<ol>
<li>有些情况下用户组权限是不能访问WinRm的，所以需要修改用户组的权限</li>
<li>执行命令<code>winrm set winrm/config/service @{RootSDDL=&quot;O:NSG:BAD:P(A;;GA;;;BA)(A;;GA;;;S-1-5-32-558)S:P(AU;FA;GA;;;WD)(AU;SA;GWGX;;;WD)&quot;}</code></li>
<li>这个命令是个SID为<code>S-1-5-32-558</code> 的用户组添加WinRm的控制权限</li>
</ol>
</li>
<li>还需要给将这个用户组添加到指定Namespace中<ol>
<li>命令行执行<code>wmimgmt.msc</code></li>
<li>弹出窗口中在 WMI Control上点击右键选择properties</li>
<li>选择Security 选项卡</li>
<li>找到root/cimv2, root, root/mscluster(这个是cluster环境下才有的）</li>
<li>分别选择namespaces 然后选择Security之后添加用户组到里面，并且要给予全部的权限（全部打勾）</li>
</ol>
</li>
<li>用户组额外的权限设置<ol>
<li>如果某些WinRm查询接口无法获得数据，可能是因为权限导致的</li>
<li>使用<code>sc sdshow SCMANAGER</code> 查看当前的权限</li>
<li>使用<code>sc sdset SCMANAGER D:(A;;CCLCRPRC;;;用户组SID)(A;;CC;;;AU)(A;;CCLCRPRC;;;IU)(A;;CCLCRPRC;;;SU)(A;;CCLCRPWPRC;;;SY)(A;;KA;;;BA)S:(AU;FA;KA;;;WD)(AU;OIIOFA;GA;;;WD)</code> 使得用户组获得权限</li>
<li>参考资料：<a href="http://blogs.msmvps.com/erikr/2007/09/26/set-permissions-on-a-specific-service-windows" target="_blank" rel="external">http://blogs.msmvps.com/erikr/2007/09/26/set-permissions-on-a-specific-service-windows</a>, and <a href="http://www.netid.washington.edu/documentation/domains/sddl.aspx" target="_blank" rel="external">http://www.netid.washington.edu/documentation/domains/sddl.aspx</a>.</li>
</ol>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>如何在Windows上配置启用WinRm]]>
    
    </summary>
    
      <category term="编程-网络协议" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM 启动参数设置]]></title>
    <link href="http://luoyuan800.github.io/2015/07/24/jvm-argument/"/>
    <id>http://luoyuan800.github.io/2015/07/24/jvm-argument/</id>
    <published>2015-07-24T08:57:43.000Z</published>
    <updated>2015-07-23T09:32:43.389Z</updated>
    <content type="html"><![CDATA[<p>JVM可以在启动的时候进行配置，大部分时候要进行调节的参数是为了优化运行效率，提升GC机制的执行效率。<br><a id="more"></a></p>
<h2 id="启用参数示例">启用参数示例</h2><pre><code>JAVA_OPTS="-server -XX:+UseParNewGC -Xms1024m -Xmx2048m 
    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxNewSize=</span><span class="number">128</span>m -<span class="constant">XX</span><span class="symbol">:NewSize=</span><span class="number">128</span>m -<span class="constant">XX</span><span class="symbol">:PermSize=</span><span class="number">96</span>m 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxPermSize=</span><span class="number">128</span>m -<span class="constant">XX</span><span class="symbol">:+UseConcMarkSweepGC</span> 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:+CMSPermGenSweepingEnabled</span> -<span class="symbol">verbose:</span>gc 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:+PrintGCDetails</span> -<span class="constant">XX</span><span class="symbol">:+PrintGCTimeStamps</span> 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:CMSInitiatingOccupancyFraction=</span><span class="number">1</span> -<span class="constant">XX</span><span class="symbol">:+CMSIncrementalMode</span>
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxTenuringThreshold=</span><span class="number">0</span> -<span class="constant">XX</span><span class="symbol">:SurvivorRatio=</span><span class="number">20000</span> 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseCMSCompactAtFullCollection</span> 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:CMSFullGCsBeforeCompaction=</span><span class="number">0</span>  
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:CMSIncrementalDutyCycleMin=</span><span class="number">10</span> -<span class="constant">XX</span><span class="symbol">:CMSIncrementalDutyCycle=</span><span class="number">30</span> 
</span>    -<span class="ruby"><span class="constant">XX</span><span class="symbol">:CMSMarkStackSize=</span><span class="number">8</span>M -<span class="constant">XX</span><span class="symbol">:CMSMarkStackSizeMax=</span><span class="number">32</span>M<span class="string">"</span></span>
</code></pre><h2 id="参数说明">参数说明</h2><h3 id="-server">-server</h3><p>一定要作为第一个参数，在多个CPU时提升性能（大概就是把JVM做为服务器使用）</p>
<h3 id="-Xmx1280m">-Xmx1280m</h3><p>设置JVM最大可用内存为1280m。最大可设为3550m。具体应用可适当调整。</p>
<h3 id="-Xms1280m">-Xms1280m</h3><p>设置JVM初始内存为1280m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p>
<h3 id="-Xmn480m">-Xmn480m</h3><p>设置年轻代大小为480m。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p>
<h3 id="-Xss256k">-Xss256k</h3><p>设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
<h3 id="-XX:PermSize=64m">-XX:PermSize=64m</h3><p>指定 jvm 中 Perm Generation 的最小值。 这个参数需要看你的实际情况。可以通过jmap 命令看看到底需要多少。</p>
<h3 id="-XX:MaxPermSize=128m">-XX:MaxPermSize=128m</h3><p>指定 Perm Generation 的最大值</p>
<h3 id="-XX:+UseConcMarkSweepGC">-XX:+UseConcMarkSweepGC</h3><p>设置并发收集器</p>
<h3 id="-XX:ParallelGCThreads=8">-XX:ParallelGCThreads=8</h3><p>配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p>
<h3 id="-XX:CMSFullGCsBeforeCompaction=0">-XX:CMSFullGCsBeforeCompaction=0</h3><p>由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</p>
<h3 id="-XX:+UseCMSCompactAtFullCollection">-XX:+UseCMSCompactAtFullCollection</h3><p>打开对年老代的压缩。可能会影响性能，但是可以消除碎片。</p>
<h3 id="-XX:SurvivorRatio=8">-XX:SurvivorRatio=8</h3><p>每个survivor space 和 eden之间的比例。</p>
<h3 id="-XX:MaxTenuringThreshold=7">-XX:MaxTenuringThreshold=7</h3><p>设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。</p>
<h3 id="-XX:GCTimeRatio=19">-XX:GCTimeRatio=19</h3><p>设置垃圾回收时间占程序运行时间的百分比，公式为1/(1+n)。</p>
<h3 id="-Xnoclassgc">-Xnoclassgc</h3><p>禁用类垃圾回收，性能会有一定提高。</p>
<h3 id="-XX:+DisableExplicitGC">-XX:+DisableExplicitGC</h3><p>当此参数打开时，在程序中调用System.gc()将会不起作用。默认是off。</p>
<h3 id="-XX:+UseParNewGC">-XX:+UseParNewGC</h3><p>设置年轻代为并行收集。可与CMS收集同时使用。</p>
<h3 id="-XX:-CMSParallelRemarkEnabled">-XX:-CMSParallelRemarkEnabled</h3><p>在使用 UseParNewGC 的情况下 , 尽量减少 mark 的时间。</p>
<h3 id="-XX:CMSInitiatingOccupancyFraction=70">-XX:CMSInitiatingOccupancyFraction=70</h3><p>指示在 old generation 在使用了 70% 的比例后 , 启动 concurrent collector。</p>
<h3 id="-XX:SoftRefLRUPolicyMSPerMB=0">-XX:SoftRefLRUPolicyMSPerMB=0</h3><p>每兆堆空闲空间中SoftReference的存活时间。</p>
<h3 id="-verbose">-verbose</h3><p>显示垃圾收集信息</p>
<h3 id="-Xloggc:gc-log">-Xloggc:gc.log</h3><p>指定垃圾收集日志文件（记录垃圾回收的日志）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JVM可以在启动的时候进行配置，大部分时候要进行调节的参数是为了优化运行效率，提升GC机制的执行效率。<br>]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JVM 垃圾回收器]]></title>
    <link href="http://luoyuan800.github.io/2015/07/23/jvm-gc/"/>
    <id>http://luoyuan800.github.io/2015/07/23/jvm-gc/</id>
    <published>2015-07-23T08:57:43.000Z</published>
    <updated>2015-07-23T08:58:31.538Z</updated>
    <content type="html"><![CDATA[<p>简单列举了JVM中使用的集中垃圾收集器<a id="more"></a></p>
<h2 id="新生代收集器">新生代收集器</h2><h3 id="Serial">Serial</h3><p>Serial收集器的机制被称为“Stop the word”。它属于单线程收集器，进行垃圾收集GC的时候会暂停所有的用户线程，采用复制算法进行GC。<br>这个收集器适用于Client端，因为它对于小内存的收集来说尤为高效，停顿时间也比较短。</p>
<h3 id="ParNew">ParNew</h3><p>ParNew收集器同样是使用“Stop the word”机制。但是它是多线程的。如果是运行在多cpu的服务器上的时候，首选这种收集器。</p>
<h3 id="Parallel_Scavenger">Parallel Scavenger</h3><p>这是一个吞吐量优先的垃圾收集器，采用多线程机制。</p>
<h2 id="年老代收集器">年老代收集器</h2><h3 id="Serial_Old">Serial Old</h3><p>和Serial相对应，是年老代收集器，使用单线程的和标记-整理算法进行垃圾回收。</p>
<h3 id="Parallel_Old">Parallel Old</h3><p>是Parallel Scavenge收集器的年老代版本。使用多线程和标记-整理算法，主要是服务端模式下和Parallel Scavenge收集器组合使用。</p>
<h3 id="CMS（Current_Mark_Sweep)">CMS（Current Mark Sweep)</h3><p>CMS是对年老带的进行对象回收，这是一个额外的回收管理机制，基于标记-清除算法实现。它的特点是JVM的停顿时间较短（普通的年老代回收机制就有较长时间的JVM响应停顿），因此CMS主要可以应用于对响应时间有较高要求的服务器上。由于收集完成后会产生碎片，所以要开启 <code>-XXUseCMSCompactAtFullCollection</code>开关参数，表示在Full GC之后，要进行一次碎片整理。开启CMS需要使用额外的参数启用它 ：在启动JVM参数加上<code>-XX:+UseConcMarkSweepGC</code>。</p>
<h4 id="CMS的运作阶段">CMS的运作阶段</h4><p><img src="http://7xk7ce.com1.z0.glb.clouddn.com/cms.png" alt=""></p>
<ul>
<li>初始标记 ：在这个阶段，需要虚拟机停顿正在执行的任务，Stop The Word。这个过程从垃圾回收的”根对象”开始，只扫描到能够和”根对象”直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。</li>
<li>并发标记 ：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。</li>
<li>并发预清理 ：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段”重新标记”的工作，因为下一个阶段会Stop The World。</li>
<li>重新标记 ：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从”根对象”开始向下追溯，并处理对象关联。</li>
<li>并发清理 ：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。</li>
<li>并发重置 ：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。</li>
</ul>
<h3 id="G1(Garbage_First)">G1(Garbage First)</h3><p>G1将整个JAVA堆（包括新生代、老年代）划分为多个固定大小的独立区域，并跟踪垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，有限回收垃圾最多的区域。 它是基于标记-整理算法实现的，并且具有非常准确的控制停顿。</p>
<h2 id="各个收集器的可用组合">各个收集器的可用组合</h2><p>图例表示了各个收集器组合可能性，如果两个收集器之间存在连线，表明他们可以一起组合使用。<br><img src="http://7xk7ce.com1.z0.glb.clouddn.com/relationship.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>简单列举了JVM中使用的集中垃圾收集器]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Java进行文本加密]]></title>
    <link href="http://luoyuan800.github.io/2015/07/22/java-encode/"/>
    <id>http://luoyuan800.github.io/2015/07/22/java-encode/</id>
    <published>2015-07-22T07:58:00.000Z</published>
    <updated>2015-07-22T08:07:29.252Z</updated>
    <content type="html"><![CDATA[<p>通用的加密模式可以分为对称加密、不对称加密、单向加密（不可逆加密）。偶然想要查询下如何在java中进行文本加密，网上搜索到的都是大篇幅介绍加密原理，如何使用却都是一句话带过，真真是看着就烦。所以本文不涉及加密原理和概念，只是列举了如何使用java进行加密的例子，作为参考使用。<a id="more"></a></p>
<h2 id="MD5">MD5</h2><p>不可逆加密指的是使用MD5或者SHA进行加密，其本质是抽取特征码，抽取出来的密文是不可逆向解密回原来的文本的。这种方式大多用于密码的存储——只在数据库中存储抽取的特征码，而不存储原来的密码。</p>
<pre><code>MessageDigest md5 = MessageDigest.getInstance<span class="params">(<span class="string">"MD5"</span>)</span>;
BASE64Encoder base64Encoder = new BASE64Encoder<span class="params">()</span>;
String info = base64Encoder.encode<span class="params">(md5.digest<span class="params">(<span class="string">"luoyuan"</span>.getBytes<span class="params">(<span class="string">"utf-8"</span>)</span>)</span>)</span>;
System.out.println<span class="params">(info)</span>;
</code></pre><p>其中<code>getInstance(String)</code>的取值是限定的，如果传入的不是以下的字符串之一，就会抛出<code>NoSuchAlgorithmException</code></p>
<ul>
<li>MD5</li>
<li>MD2</li>
<li>SHA-1</li>
<li>SHA-256</li>
<li>SHA-384</li>
<li>SHA-512</li>
</ul>
<h2 id="AES">AES</h2><p>AES和DES的使用方式在Java中都差不多，所以不在此处提及DES的使用范例。<br>AES加密方式属于对称加密，加密和解密都需要使用一样的密钥。所以在加密时候使用的密钥要和密文一起发送。</p>
<h3 id="加密">加密</h3><pre><code>String mess = <span class="string">"luoyuan"</span>;
KeyGenerator keyGenerator = KeyGenerator.getInstance<span class="params">(<span class="string">"AES"</span>)</span>;<span class="comment">//获取一个AES相关的KeyGenerator</span>
keyGenerator.init<span class="params">(<span class="number">128</span>)</span>;<span class="comment">//指定生成密钥的长度为128</span>
SecretKey key = keyGenerator.generateKey<span class="params">()</span>;<span class="comment">//生成一个密钥</span>
Cipher cipher = Cipher.getInstance<span class="params">(<span class="string">"AES/ECB/PKCS5Padding"</span>)</span>;<span class="comment">//构建Cipher,设置模式，解密的时候也必须使用同样的模式</span>
cipher.init<span class="params">(Cipher.ENCRYPT_MODE, key)</span>;<span class="comment">//使用生成的密钥初始化</span>
byte[] encode = cipher.doFinal<span class="params">(mess.getBytes<span class="params">(<span class="string">"utf-8"</span>)</span>)</span>;<span class="comment">//执行加密过程</span>
System.out.println<span class="params">(Arrays.toString<span class="params">(encode)</span>)</span>;
</code></pre><h3 id="解密">解密</h3><pre><code>byte[] keyCode = <span class="decorator">{...}</span>;//加密过程生成的密钥的encoded
byte[] data = <span class="decorator">{...}</span>;//加密后的文本字节数组
<span class="type">SecretKey</span> key = new <span class="type">SecretKeySpec</span>(keyCode, <span class="string">"AES"</span>);//根据给出的密钥（字节数组）生成一个<span class="type">Key</span>对象
<span class="type">Cipher</span> cipher = <span class="type">Cipher</span>.getInstance(<span class="string">"AES/ECB/PKCS5Padding"</span>); //生成一个和加密时候使用的模式一样的<span class="type">Cipher</span>
cipher.init(<span class="type">Cipher</span>.<span class="type">DECRYPT_MODE</span>, key);
byte[] decode = cipher.doFinal(data);//执行解密步骤
<span class="type">System</span>.<span class="keyword">out</span>.println(new <span class="type">String</span>(decode));
</code></pre><h2 id="RSA">RSA</h2><p>RSA(DSA)加密属于非对称加密，加密解密过程会使用到不同的密钥——公钥和私钥。<br>如果使用公钥加密，那么解密可以使用私钥解密，如果使用私钥加密，则必须使用公钥进行解密。</p>
<h3 id="加密-1">加密</h3><pre><code>String msg = <span class="string">"Luoyuan"</span>;
KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance<span class="params">(<span class="string">"RSA"</span>)</span>;<span class="comment">//初始化一个KeyPairGenerator</span>
keyGenerator.initialize<span class="params">(<span class="number">1024</span>)</span>;<span class="comment">//设置密钥长度为1024</span>
KeyPair keyPair = keyGenerator.generateKeyPair<span class="params">()</span>;<span class="comment">//RSA加密需要生成相对应的公钥和私钥</span>
RSAPrivateKey privateKey = <span class="params">(RSAPrivateKey)</span> keyPair.getPrivate<span class="params">()</span>;<span class="comment">//获得私钥</span>
RSAPublicKey publicKey = <span class="params">(RSAPublicKey)</span> keyPair.getPublic<span class="params">()</span>;<span class="comment">//获得公钥</span>
Cipher cipher = Cipher.getInstance<span class="params">(<span class="string">"RSA"</span>)</span>;
cipher.init<span class="params">(Cipher.ENCRYPT_MODE, privateKey)</span>;<span class="comment">//使用私钥加密</span>
byte[] encode = cipher.doFinal<span class="params">(msg.getBytes<span class="params">(<span class="string">"utf-8"</span>)</span>)</span>;
System.out.println<span class="params">(Arrays.toString<span class="params">(encode)</span>)</span>;
</code></pre><h3 id="解密-1">解密</h3><pre><code>byte[] publicKeyCode = <span class="decorator">{...}</span>;
byte[] encode = <span class="decorator">{...}</span>;
<span class="type">Cipher</span> cipher = <span class="type">Cipher</span>.getInstance(<span class="string">"RSA"</span>);
<span class="type">RSAPublicKey</span> publicKey = new <span class="type">RSAPublicKeyImpl</span>(publicKeyCode);//根据公钥的encode构建公钥对象
cipher.init(<span class="type">Cipher</span>.<span class="type">DECRYPT_MODE</span>, publicKey);//使用公钥解密
byte[] decode = cipher.doFinal(encode);
<span class="type">System</span>.<span class="keyword">out</span>.println(new <span class="type">String</span>(decode));
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>通用的加密模式可以分为对称加密、不对称加密、单向加密（不可逆加密）。偶然想要查询下如何在java中进行文本加密，网上搜索到的都是大篇幅介绍加密原理，如何使用却都是一句话带过，真真是看着就烦。所以本文不涉及加密原理和概念，只是列举了如何使用java进行加密的例子，作为参考使用。]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则表达式进阶]]></title>
    <link href="http://luoyuan800.github.io/2015/07/15/java-regex/"/>
    <id>http://luoyuan800.github.io/2015/07/15/java-regex/</id>
    <published>2015-07-15T08:19:43.000Z</published>
    <updated>2015-07-23T06:21:35.351Z</updated>
    <content type="html"><![CDATA[<p>正则表达式的作用在我看来是：匹配、查找、替换三种。使用正则表达式也算是粗粗入门了，至少已经可以写一些简单的表达式来进行字符串的匹配了，而且也会从网络上拷贝别人的一些比较复杂的表达式……那么就学习一些进阶的东西吧。包括 捕获组和非捕获组，匹配模式解析。（本文中的正则表达式均是Java中可以使用的格式，<code>\\</code>表示普通正则表达式中的<code>\</code>）<a id="more"></a></p>
<h2 id="组的概念">组的概念</h2><p>首先了解正则表达式中组的概念，在正则表示中组的应用是非常广泛的，只是我们经常没有在意组的真正用法：抽取字符串。一般我们使用正则表达式都只是使用它的匹配功能，只需要验证目标文本是否符合要求。那么如果我们要应用到正则表达式的抽取字符串和替换的时候，组就可以提供我们正确的获得查找结果。<br>Java中组是使用()来表示，一个()表示一个组，在匹配过程中，是依次按照组进行文本匹配，当匹配到当前组之后，就会使用余下的文本来匹配下一个组。</p>
<h3 id="捕获组">捕获组</h3><p>顾名思义，捕获组就是会捕获我们需要匹配的字符串进而提供给我们抽取。<br>如果有一个正则表达<code>(\\w+)(\\d{3}).*</code>，那么这个表达式中包含3个捕获组，分别为代表整个表达式的组0：<code>\\w\\d{3}.*</code> 组1为<code>\\w+</code> 这里表示匹配一个或多个字符，组2为<code>\\d{3}</code>匹配正好3个数字字符。那么我们可以用这个表达式去抽取文本中的连续的三个数字。</p>
<h3 id="非捕获组">非捕获组</h3><p>以上提到的组都是属于捕获组，就是会匹配这个组的字符串，并且抽取到组中。Java中还有非捕获组的概念，即是一个非的概念。以 (<code>?</code>) 开头的组是纯的非捕获组，它不捕获文本，也不针对组合计进行计数。就是说，如果小括号中以?号开头，那么这个分组就不会抽取文本。Java中支持的非捕获组并不多（请忽略专业的概念术语）</p>
<ul>
<li><code>(?=X)</code>     X，通过零宽度的正 lookahead 即左侧匹配</li>
<li><code>(?!X)</code>     X，通过零宽度的负 lookahead 即左侧匹配 </li>
<li><code>(?&lt;=X)</code>     X，通过零宽度的正 lookbehind 即右侧匹配 </li>
<li><code>(?&lt;!X)</code>     X，通过零宽度的负 lookbehind 即右侧匹配 </li>
</ul>
<p>非捕获组中四个表达式的区别：</p>
<ul>
<li><code>(?=X )</code> 和<code>(?!X)</code>用于右侧匹配</li>
<li><code>(?&lt;=X)</code>和<code>(?&lt;!X)</code>用于左侧匹配</li>
</ul>
<p>被非捕获组匹配的到的字符串，最后是不会被抽取出来的。所以非捕获组是应用于更加精确的定位某段字符串而存在的。下面是几个非捕获组的范例<br>匹配用字符串： <code>abc12dd344oo</code></p>
<ul>
<li><code>(?&lt;=abc)(\\d+)</code> 匹配左侧为abc的数字串，分组为组(1) = 12</li>
<li><code>(?&lt;!abc)(\\d+)</code> 匹配左侧不是abc的数字串，分组为组（1） = 2 和 344. 注意这个正则表达式会导致匹配失控，因为可以匹配到的分组有两个。</li>
<li><code>(\\d+)(?=dd)</code> 匹配右侧为dd的数字串， 分组为组（1） = 12</li>
<li><code>(\\d+)(?!dd)</code> 匹配右侧不是dd的数字串， 分组为组（1） = 1 和344. 同样，这个表达式在Java中也是会失控。</li>
</ul>
<h3 id="Java中根据组来抽取字符串">Java中根据组来抽取字符串</h3><p>字符串的抽取需要用到java中的Pattern和Matcher来进行。</p>
<pre><code>Pattern pattern = Pattern.compile<span class="params">(“\\w+<span class="params">(\\d{<span class="number">3</span>})</span>.*”)</span>;
Matcher matcher = pattern.matcher<span class="params">(“aaaa123aaaa”)</span>;
<span class="keyword">if</span><span class="params">(matcher.find<span class="params">()</span>)</span>{
    String nums = matcher.group<span class="params">(<span class="number">1</span>)</span>;
}
</code></pre><p>其中<code>Matcher.group(int)</code>方法中传入的就是这个要查找的组的序号。如果传入的序号大于表达式中组的实际个数，那么会抛出异常。</p>
<h2 id="匹配模式">匹配模式</h2><p>在有了组的基本概念之后，再来讨论Java中的正则表达式在匹配中使用到的三种模式</p>
<h3 id="贪婪模式">贪婪模式</h3><p>没有加上其他模式标识的普通模式就是贪婪模式，在日常应用中我们最常用的模式就贪婪模式。贪婪模式总是尽可能的去匹配文本，以期望能够返回匹配成功。贪婪模式其实效率最为差的一种模式，因为在匹配过程中他首先从整个文本开始进行匹配，然后会大量的回溯文本，并且是一个一个字符进行回溯，越是长的文本，在贪婪模式下匹配效率越差。</p>
<h3 id="勉强模式">勉强模式</h3><p>与贪婪模式相反，该模式是从第一个字符开始向后进行匹配，只是匹配尽量少的文本，所以除非最差的情况下，该模式的匹配次数会比贪婪模式少。勉强模式的标识是在传统的贪婪模式的组表达式后面增加一个<code>?</code> 。</p>
<h3 id="占有模式">占有模式</h3><p>这种模式是Java特有的模式，它只会对整个文本匹配一次，不会回溯。这种模式的速度是最快的，因为只是匹配一次。Java编程思想中提到，这个模式可以防止正则表达式失控，也可以减少匹配过程中因为要保存回溯信息而占用的空间。占有模式的标识是在传统的贪婪模式组表达式后面增加一个<code>+</code> 。</p>
<h3 id="模式在文本匹配中的影响">模式在文本匹配中的影响</h3><p>对应同一个文本，不同的模式会返回不同的匹配结果.假定要分析的字符串是<code>xfooxxxxxxfoo</code>(来源网络）</p>
<ul>
<li>模式<code>.*foo</code> （贪婪模式）: 模式分为子模式<code>p1(.*)</code>和子模式<code>p2(foo)</code>两个部分. 其中p1中的量词匹配方式使用默认方式(贪婪型)。匹配开始时,吃入所有字符<code>xfooxxxxxx</code>去匹配子模式p1。匹配成功,但这样以来就没有了字符串去匹配子模式p2。本轮匹配失败；第二轮：减少p1部分的匹配量，吐出最后一个字符, 把字符串分割成<code>xfooxxxxxxfo</code>和<code>o</code>两个子字符串s1和s2。 s1匹配p1, 但s2不匹配p2。本轮匹配失败；第三轮，再次减少p1部分匹配量，吐出两个字符, 字符串被分割成<code>xfooxxxxxxfo</code>和<code>oo</code>两部分。结果同上。第四轮，再次减少p1匹配量, 字符串分割成<code>xfooxxxxxx</code>和<code>foo</code>两个部分, 这次s1/s2分别和p1/p2匹配。停止尝试,返回匹配成功。</li>
<li>模式<code>.*?foo</code> （勉强模式）: 最小匹配方式。第一次尝试匹配, p1由于是0或任意次，因此被忽略，用字符串去匹配p2,失败；第二次，读入第一个字符<code>x</code>, 尝试和p1匹配, 匹配成功; 字符串剩余部分<code>fooxxxxxxfoo</code>中前三个字符和p2也是匹配的. 因此, 停止尝试, 返回匹配成功。在这种模式下，如果对剩余字符串继续去寻找和模式相匹配的子字符串，还会找到字符串末尾的另一个<code>xfoo</code>，而在贪婪模式下，由于第一次匹配成功的子串就已经是所有字符，因此不存在第二个匹配子串。</li>
<li>模式<code>.*+foo</code> （占有模式）:匹配开始时读入所有字符串, 和p1匹配成功, 但没有剩余字符串去和p2匹配。因此, 匹配失败。返回。</li>
</ul>
<p>再看下面一个例子：贪婪模式与占有模式的比较</p>
<blockquote>
<p>正则：<code>\\w+[a-z]</code>与<code>\\w++[a-z]</code><br>目标串：<code>232hjdhfd7474$</code></p>
</blockquote>
<p>分析:</p>
<ul>
<li><code>\\w+[a-z]</code>：<code>\\w+</code>属于贪婪模式，会一次性吃掉它所能吃掉的所有的字符，也就是子串<code>232hjdhfd7474</code>，此时<code>[a-z]</code>不能够找到匹配了，故<code>\w+</code>匹配的串会吐出一个字符<code>4</code>，但此时还是得不到匹配。反复的这样吐出回退，直到吐出字符<code>d</code>时，此时<code>[a-z]</code>能够匹配h，所以这时正则表达式会返回一次成功的匹配结果，为<code>232hjdhfd</code></li>
<li><code>\\w++[a-z]</code>：<code>\\w++</code>属于侵占模式，它会一次性吃掉它所能够吃掉的所有字符，即子串<code>232hjdhfd7474</code>，而且不留给其他部分使用，故不会回退。此时<code>[a-z]</code>不能够找到匹配，所以此次匹配失败。在余下的子串中也找不到能匹配成功的子串。所以整个正则表达式是找不到匹配结果的！</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>正则表达式的作用在我看来是：匹配、查找、替换三种。使用正则表达式也算是粗粗入门了，至少已经可以写一些简单的表达式来进行字符串的匹配了，而且也会从网络上拷贝别人的一些比较复杂的表达式……那么就学习一些进阶的东西吧。包括 捕获组和非捕获组，匹配模式解析。（本文中的正则表达式均是Java中可以使用的格式，<code>\\</code>表示普通正则表达式中的<code>\</code>）]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux系统中的进程状态]]></title>
    <link href="http://luoyuan800.github.io/2015/07/11/Linux-progress-status/"/>
    <id>http://luoyuan800.github.io/2015/07/11/Linux-progress-status/</id>
    <published>2015-07-11T09:21:15.000Z</published>
    <updated>2016-07-26T03:46:26.003Z</updated>
    <content type="html"><![CDATA[<p>Linux系统进程状态注解<a id="more"></a></p>
<h2 id="Deep_Sleep">Deep Sleep</h2><p>D Uninterruptible sleep (usually IO)<br>不可中断的深度睡眠，一般由IO引起，同步IO在做读或写操作时，此进程不能做其它事情，只能等待，这时进程处于这种状态，如果程序采用异步IO，这种状态应该就很少见到了</p>
<h2 id="Running">Running</h2><p>R Running or runnable (on run queue)<br>进程处于运行或就绪状态</p>
<h2 id="Interrupt">Interrupt</h2><p>S Interruptible sleep (waiting for an event to complete)<br>可接收信号的睡眠状态，sleep函数可演示这种状态</p>
<h2 id="Stop">Stop</h2><p>T Stopped, either by a job control signal or because it is being traced.<br>被ctrl+z中断或被trace</p>
<h2 id="Paging">Paging</h2><p>W paging (not valid since the 2.6.xx kernel) </p>
<h2 id="Dead">Dead</h2><p>X dead (should never be seen)<br>进程已经完全死掉，不可能看见这种状态的</p>
<h2 id="Zombie">Zombie</h2><p>Z Defunct (“zombie”) process, terminated but not reaped by its parent.<br>进程已经终止，但是其父进程没有来及处理它，多进程写不好的话，这种状态是常见的</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Linux系统进程状态注解]]>
    
    </summary>
    
      <category term="编程-Linux/Unix" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux-Unix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux的分区]]></title>
    <link href="http://luoyuan800.github.io/2015/07/10/Linux-partition/"/>
    <id>http://luoyuan800.github.io/2015/07/10/Linux-partition/</id>
    <published>2015-07-10T08:47:16.000Z</published>
    <updated>2016-07-26T03:46:31.766Z</updated>
    <content type="html"><![CDATA[<p>简单了解Linux文件系统的管理（磁盘管理）。<a id="more"></a></p>
<h2 id="设备管理">设备管理</h2><p>在 Linux 中，每一个硬件设备都映射到一个系统的文件，对于硬盘、光驱等 IDE 或 SCSI 设备也不例外。Linux把各种 IDE 设备分配了一个由 hd 前缀组成的文件；而对于各种 SCSI 设备，则分配了一个由 sd 前缀组成的文件。<br>对于ide硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指ide硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“~”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个ide硬盘上的第三个主分区或扩展分区,hdb2表示为第二个ide硬盘上的第二个主分区或扩展分区。对于scsi硬盘则标识为“sdx~”，scsi硬盘是用“sd”来表示分区所在设备的类型的，其余则和ide硬盘的表示方法一样，不在多说。<br>例如，第一个 IDE 设备，Linux 就定义为 hda；第二个 IDE 设备就定义为 hdb；下面以此类推。而 SCSI 设备就应该是 sda、sdb、sdc 等。</p>
<h2 id="分区编号">分区编号</h2><p>要进行分区就必须针对每一个硬件设备进行操作，这就有可能是一块IDE硬盘或是一块SCSI硬盘。对于每一个硬盘（IDE 或 SCSI）设备，Linux 分配了一个 1 到 16 的序列号码，这就代表了这块硬盘上面的分区号码。</p>
<ul>
<li>例如，第一个 IDE 硬盘的第一个分区，在 Linux 下面映射的就是 hda1，第二个分区就称作是 hda2。</li>
<li>对于SCSI 硬盘则是 sda1、sdb1 等。</li>
</ul>
<h2 id="分区的作用">分区的作用</h2><p>在 Linux 中规定，每一个硬盘设备最多能有 4个主分区（其中包含扩展分区）构成，任何一个扩展分区都要占用一个主分区号码，也就是在一个硬盘中，主分区和扩展分区一共最多是 4 个。</p>
<blockquote>
<p>对于早期的 DOS 和 Windows（Windows 2000 以前的版本），系统只承认一个主分区，可以通过在扩展分区上增加逻辑盘符（逻辑分区&gt;&gt;的方法，进一步地细化分区。</p>
</blockquote>
<h3 id="主分区">主分区</h3><p>主分区的作用就是计算机用来进行启动操作系统的，因此每一个操作系统的启动，或者称作是引导程序，都应该存放在主分区上。这就是主分区和扩展分区及逻辑分区的最大区别。我们在指定安装引导 Linux 的 bootloader 的时候，都要指定在主分区上，就是最好的例证。<br>Linux 规定了主分区（或者扩展分区）占用 1 至 16 号码中的前 4 个号码。以第一个 IDE 硬盘为例说明，主分区（或者扩展分区）占用了 hda1、hda2、hda3、hda4，而逻辑分区占用了 hda5 到 hda16 等 12 个号码。因此，Linux 下面每一个硬盘总共最多有 16 个分区。</p>
<h3 id="扩展分区">扩展分区</h3><p>除了主分区占用的空间，余下的空间划分出来的分区都被称为扩展分区。</p>
<h3 id="逻辑分区">逻辑分区</h3><p>对于逻辑分区，Linux 规定它们必须建立在扩展分区上（在 DOS 和 Windows 系统上也是如此规定），而不是主分区上。因此，我们可以看到扩展分区能够提供更加灵活的分区模式，但不能用来作为 操作系统 的引导。 除去上面这些各种分区的差别，我们就可以简单地把它们一视同仁了。</p>
<h2 id="分区指标">分区指标　　</h2><p>对于每一个 Linux 分区来讲，分区的大小和分区的类型是最主要的指标。分区的类型规定了这个分区上面的文件系统的格式。<br>Linux 支持多种的文件系统格式，其中包含了我们熟悉的FAT32、FAT16、NTFS、HP-UX，以及各种 Linux 特有的 Linux Native和 Linux Swap分区类型。在 Linux 系统中，可以通过分区类型号码来区别这些不同类型的分区。可以参考我的另外一篇博文来了解Linux分区的类型（也可以称为文件系统类型）<a href="/2015/07/01/linux-filesystem-types/" title="Linux文件系统类型">Linux文件系统类型</a>。</p>
<h2 id="常用分区介绍">常用分区介绍</h2><ul>
<li>/boot分区，它包含了操作系统的内核和在启动系统过程中所要用到的文件，建这个 分区是有必要的，因为目前大多数的pc机要受到bios的限制,况且如果有了一个单独的/boot启动分区，即使主要的根分区出现了问题，计算机依然能够 启动。这个分区的大小约在50mb—100mb之间。但是如果想用lilo启动red hat linux系统的话，含有/boot的分区必须完全在柱面1023以下。又由于8gb后的数据lilo不能读取，所以red hat - linux要安装在8gb的区域以内。</li>
<li>/usr分区，是red hat linux系统存放软件的地方，如有可能应将最大空间分给它。</li>
<li>/home分区，是用户的home目录所在地，这个分区的大小取决于有多少用户。如 果是多用户共同使用一台电脑的话，这个分区是完全有必要的，况且根用户也可以很好地控制普通用户使用计算机，如对用户或者用户组实行硬盘限量使用，限制普 通用户访问哪些文件等。其实单用户也有建立这个分区的必要，因为没这个分区的话，那么你只能以根用户的身份登陆系统，这样做是危险的，因为根用户对系统有 绝对的使用权，可一旦你对系统进行了误操作，麻烦也就来了。</li>
<li>/var/log分区，是系统日志记录分区，如果设立了这一单独的分区，这样即使系统的日志文件出现了问题，它们也不会影响到操作系统的主分区。</li>
<li>/tmp分区，用来存放临时文件。这对于多用户系统或者网络服务器来说是有必要的。 这样即使程序运行时生成大量的临时文件，或者用户对系统进行了错误的操作，文件系统的其它部分仍然是安全的。因为文件系统的这一部分仍然还承受着读写操 作，所以它通常会比其它的部分更快地发生问题。</li>
<li>/bin分区，存放标准系统实用程序。</li>
<li>/dev分区，存放设备文件。</li>
<li>/opt分区，存放可选的安装的软件。</li>
<li>/sbin分区，存放标准系统管理文件。</li>
</ul>
<p>上面介绍了几个常用的分区，一般来说我们需要一个swap分区，一个/boot分区，一个/usr分区，一个/home 分区，一个/var/log分区。当然这没有什么规定，完全是依照你个人来定的。但记住至少要有两个分区，一个swap分区，一个/分区。</p>
<h2 id="查看分区的常用命令">查看分区的常用命令</h2><h3 id="mount">mount</h3><p>mount命令用来查看那些已经分配了mountpoint的文件系统</p>
<pre><code>:~$ mount
/dev/sda1 on / <span class="keyword">type</span> ext4 (rw,errors=remount-ro,user_xattr)
<span class="keyword">proc</span> on /<span class="keyword">proc</span> <span class="keyword">type</span> <span class="keyword">proc</span> (rw,noexec,nosuid,nodev)
none on /sys <span class="keyword">type</span> sysfs (rw,noexec,nosuid,nodev)
none on /sys/fs/fuse/connections <span class="keyword">type</span> fusectl (rw)
none on /sys/kernel/debugtype debugfs (rw)
none on /sys/kernel/security <span class="keyword">type</span> securityfs (rw)
none on /dev <span class="keyword">type</span> devtmpfs (rw,mode=<span class="number">0755</span>)
none on /dev/pts <span class="keyword">type</span> devpts (rw,noexec,nosuid,gid=<span class="number">5</span>,mode=<span class="number">0620</span>)
none on /dev/shm <span class="keyword">type</span> tmpfs (rw,nosuid,nodev)
none on /<span class="keyword">var</span>/runtype tmpfs (rw,nosuid,mode=<span class="number">0755</span>)
none on /<span class="keyword">var</span>/lock <span class="keyword">type</span> tmpfs (rw,noexec,nosuid,nodev)
none on /lib/init/rw <span class="keyword">type</span> tmpfs (rw,nosuid,mode=<span class="number">0755</span>)
none on /<span class="keyword">var</span>/lib/ureadahead/debugfs <span class="keyword">type</span> debugfs (rw,relatime)
none on /<span class="keyword">proc</span>/fs/vmblock/mountPoint <span class="keyword">type</span> vmblock (rw)
binfmt_misc on /<span class="keyword">proc</span>/sys/fs/binfmt_misc <span class="keyword">type</span> binfmt_misc (rw,noexec,nosuid,nodev)
gvfs-fuse-daemon on /home/kysnail/.gvfs <span class="keyword">type</span> fuse.gvfs-fuse-daemon (rw,nosuid,nodev,user=kysnail)
</code></pre><h3 id="df">df</h3><p>df命令可以查看文件系统的分区大小， 使用-l参数可以只参看本地文件系统。</p>
<pre><code>:~$ df -lhT
文件系统      类型    容量  已用 可用 已用% 挂载点
/dev/sda1     ext4     19G   11G  <span class="number">7</span>.8G  <span class="number">57</span>% /
<span class="keyword">none</span>      devtmpfs    498M  248K  497M   <span class="number">1</span>% /dev
<span class="keyword">none</span>         tmpfs    502M  252K  501M   <span class="number">1</span>% /dev/shm
<span class="keyword">none</span>         tmpfs    502M   96K  502M   <span class="number">1</span>% /<span class="keyword">var</span>/run
<span class="keyword">none</span>         tmpfs    502M     <span class="number">0</span>  502M   <span class="number">0</span>% /<span class="keyword">var</span>/lock
<span class="keyword">none</span>         tmpfs    502M     <span class="number">0</span>  502M   <span class="number">0</span>% /lib/<span class="keyword">init</span>/rw
<span class="keyword">none</span>       debugfs     19G   11G  <span class="number">7</span>.8G  <span class="number">57</span>% /<span class="keyword">var</span>/lib/ureadahead/debugfs
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>简单了解Linux文件系统的管理（磁盘管理）。]]>
    
    </summary>
    
      <category term="编程-Linux/Unix" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Linux-Unix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown 语法说明]]></title>
    <link href="http://luoyuan800.github.io/2015/07/07/Markdown/"/>
    <id>http://luoyuan800.github.io/2015/07/07/Markdown/</id>
    <published>2015-07-07T02:51:34.000Z</published>
    <updated>2015-07-07T07:14:19.327Z</updated>
    <content type="html"><![CDATA[<p>Markdown是一种标记语言，主要用于网页上文本格式设置。它的使得我们可以使用普通的文本编辑器编辑网页文本。在页面显示用Markdown语法的文本，需要先转换为HTML格式再进行显示。Markdown使得普通文本和网页文本通过一种简单的格式关联了起来，文本编辑者不在需要了解复杂的HTML标签。同时，你也可以在Markdown格式的文本中使用HTML标签，这样可以补全一些Markdown语法不具备的功能，比如文字的显示颜色。<br>本文中不会对Markdown语法转换原理和转换后的HTML标签进行说明，只会列举Markdown的格式显示效果。<br><a id="more"></a></p>
<h2 id="我为什么要用Markdown">我为什么要用Markdown</h2><p>因为我搭建的博客支持使用Markdown来构建博文，并且Markdown作为一种标记语言学习简单，而且作为程序员，使用标记语言来写作会更加符合那种高逼格与众不同的形象~</p>
<h2 id="标题">标题</h2><p>Markdown中的标题使用<code>#</code>进行标识， Markdown支持六级标题，标题1可以作为文本题目的显示，标题2后会跟一个下划线（HEXO搭建的博客支持Markdown语法写的文本，并且会根据标题格式生成博文目录，不过只会支持从标题2开始的标题）。</p>
<pre><code><span class="preprocessor"># 标题1</span>
<span class="preprocessor">## 标题2</span>
<span class="preprocessor">### 标题3</span>
<span class="preprocessor">#### 标题4</span>
<span class="preprocessor">##### 标题5</span>
<span class="preprocessor">###### 标题6</span>
</code></pre><p>以上文本的显示效果为</p>
<p><img src="http://7xk7ce.com1.z0.glb.clouddn.com/head.png" alt=""></p>
<h2 id="文字格式">文字格式</h2><ul>
<li><p>斜体。<code>*斜体*</code> 显示为 <em>斜体</em></p>
</li>
<li><p>粗体。<code>**粗体**</code> 显示为 <strong>粗体</strong></p>
</li>
</ul>
<h2 id="文本块">文本块</h2><h3 id="引用文本块">引用文本块</h3><p>强调引用的文本格式是一个文本块，使用>开头的文本会被显示为文本块</p>
<pre><code>&gt;这是一个
&gt;引用的文本
</code></pre><p>会被显示为</p>
<blockquote>
<p>这是一个<br>引用的文本</p>
</blockquote>
<h3 id="代码块">代码块</h3><p>代码块有三种</p>
<ul>
<li><p>一种是插入到文本中的<code>这是一小节代码</code>，使用的格式为</p>
<pre><code><span class="escape">`这</span>是一小节代码`
</code></pre></li>
<li><p>一种是一整段的代码，这个整段代码的格式和特殊字符都会保留而不会被转换。每一行的文本前面增加缩进可以实现代码块的显示，可以缩进一个，也可以缩进两个。</p>
<pre><code><span class="variable">&lt;Tab缩进&gt;</span>public CmdLineDiskMetrics(AbstractUnixCollector execWrapper, LogService <span class="keyword">log</span>Service,
<span class="variable">&lt;Tab缩进&gt;</span>                          UnixAgentPropertyWrapper properties) {
<span class="variable">&lt;Tab缩进&gt;</span>mExecWrapper = execWrapper;
<span class="variable">&lt;Tab缩进&gt;</span>mLogger = <span class="keyword">log</span>Service.getLogger(CmdLineDiskMetrics.class);
<span class="variable">&lt;Tab缩进&gt;</span>mStringUtils = new StringUtils(<span class="keyword">log</span>Service, CmdLineDiskMetrics.class.getName());
<span class="variable">&lt;Tab缩进&gt;</span>mProperties = properties;
<span class="variable">&lt;Tab缩进&gt;</span>mIsDebugEnable = mLogger.getDebugLevel() &gt;= <span class="number">1</span>;
<span class="variable">&lt;Tab缩进&gt;</span>
<span class="variable">&lt;Tab缩进&gt;</span>mHostResolver = new HostNameResolver(<span class="keyword">log</span>Service, execWrapper.getServices().getResolverService());
<span class="variable">&lt;Tab缩进&gt;</span>}
</code></pre><p>会被显示成</p>
<pre><code>public <span class="type">CmdLineDiskMetrics</span>(<span class="type">AbstractUnixCollector</span> execWrapper, <span class="type">LogService</span> logService,
                      <span class="type">UnixAgentPropertyWrapper</span> properties) {
mExecWrapper = execWrapper;
mLogger = logService.getLogger(<span class="type">CmdLineDiskMetrics</span>.<span class="keyword">class</span>);
mStringUtils = <span class="keyword">new</span> <span class="type">StringUtils</span>(logService, <span class="type">CmdLineDiskMetrics</span>.<span class="keyword">class</span>.getName<span class="literal">()</span>);
mProperties = properties;
mIsDebugEnable = mLogger.getDebugLevel<span class="literal">()</span> &gt;= <span class="number">1</span>;

mHostResolver = <span class="keyword">new</span> <span class="type">HostNameResolver</span>(logService, execWrapper.getServices<span class="literal">()</span>.getResolverService<span class="literal">()</span>);
}
</code></pre></li>
<li><p>命令行格式的代码需要使用bash格式来显示，这样的格式会在每一条命令前面加上序号</p>
<p>  ````bash<br>  $ commond1<br>  $ commond2<br>  ````<br>会显示成</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ commond1</span><br><span class="line">$ commond2</span><br></pre></td></tr></table></figure>
<h2 id="表格">表格</h2><p>Markdown中使用形象的格式来表示表格（表格和上一个文本之间需要有一个空行分隔）</p>
<pre><code>|<span class="string">标题1</span>|<span class="string">标题2</span>|
|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">    #这一行是用来定义表格的对齐方式的        
</span>|<span class="string">第一格</span>|<span class="string">第二格</span>|
|<span class="string">第三格</span>|<span class="string">第四格</span>|
</code></pre><p>会显示一个如下的表格</p>
<table>
<thead>
<tr>
<th>标题1</th>
<th>标题2</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一格</td>
<td>第二格</td>
</tr>
<tr>
<td>第三格</td>
<td>第四格</td>
</tr>
</tbody>
</table>
<p>表格的对齐方式是通过表格标题下方的第二行|——|——-|来定义的</p>
<ul>
<li><code>----</code>表示左对齐</li>
<li><code>-----：</code>表示右对齐</li>
<li><code>：----：</code>表示居中对齐</li>
</ul>
<h2 id="超链接">超链接</h2><p>定义一个超链接使用一下格式</p>
<pre><code>[<span class="link_label">Yuan</span>](<span class="link_url">http://luoyuan800.github.io "Yuan-Blog"</span>)
</code></pre><p>[]内的是要显示的文本，而()的前半部分是连接的地址，后半部分则是鼠标移动到链接上面要显示的内容。<br>最后的显示结果为 <a href="http://luoyuan800.github.io" title="Yuan-Blog">Yuan</a></p>
<h2 id="图片">图片</h2><p>图片的格式和超链接是一样的，不同的地方是，在[]要留空，之后的()中只需要填入图片的网址即可</p>
<pre><code>!<span class="attr_selector">[]</span>(<span class="attribute">http</span>:<span class="comment">//7xk7ce.com1.z0.glb.clouddn.com/head.png)</span>
</code></pre><h2 id="特殊字符">特殊字符</h2><p>如果要正常显示特殊字符，需要在其前面使用<code>\</code>标识，这样的话特殊字符就不会被转换。特殊字符包括：</p>
<pre><code><span class="change">!</span>
`
&gt;
\
&lt;
[
]
(
)
*
<span class="addition">+</span>
<span class="deletion">-</span>
_
.
</code></pre><p>如果是要同时显示括号的话只需要在后一个括号前面加上<code>\</code> 如：</p>
<pre><code>(<span class="string">\)</span>  [<span class="string">\]</span> &lt;<span class="string">\&gt;</span> 
</code></pre><p>会显示成<br>() [] &lt;></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Markdown是一种标记语言，主要用于网页上文本格式设置。它的使得我们可以使用普通的文本编辑器编辑网页文本。在页面显示用Markdown语法的文本，需要先转换为HTML格式再进行显示。Markdown使得普通文本和网页文本通过一种简单的格式关联了起来，文本编辑者不在需要了解复杂的HTML标签。同时，你也可以在Markdown格式的文本中使用HTML标签，这样可以补全一些Markdown语法不具备的功能，比如文字的显示颜色。<br>本文中不会对Markdown语法转换原理和转换后的HTML标签进行说明，只会列举Markdown的格式显示效果。<br>]]>
    
    </summary>
    
      <category term="网站-语言" scheme="http://luoyuan800.github.io/categories/%E7%BD%91%E7%AB%99-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SNMP框架介绍（基于snmp4j）]]></title>
    <link href="http://luoyuan800.github.io/2015/07/06/SNMP-snmp4j/"/>
    <id>http://luoyuan800.github.io/2015/07/06/SNMP-snmp4j/</id>
    <published>2015-07-06T09:58:14.000Z</published>
    <updated>2015-07-10T01:31:41.012Z</updated>
    <content type="html"><![CDATA[<p>基于snmp4j实现的一个SNMP框架，目的是简化snmp的开发流程，只需要使用几个简单的类就可以实现通过snmp协议收集数据，也可以作为一个snmp4j的使用范例进行参考。基于Apache2.0协议开放源代码。<br><a id="more"></a></p>
<h2 id="项目介绍">项目介绍</h2><h3 id="源码地址">源码地址</h3><p><a href="https://github.com/luoyuan800/SNMP" target="_blank" rel="external">https://github.com/luoyuan800/SNMP</a></p>
<h3 id="jar包下载">jar包下载</h3><p>暂无，请下载源码后自行构建。</p>
<h3 id="Javadoc地址">Javadoc地址</h3><p><a href="http://luoyuan800.github.io/javadocs/snmp/">http://luoyuan800.github.io/javadocs/snmp/</a></p>
<h3 id="项目解析">项目解析</h3><pre><code>SNMPCore
    ├── build<span class="class">.gradle</span>
    └── src
        └── ly
            └── snmp
                └── core
                    │── model -----------------------------------------<span class="id">#A</span>
                    │── monitor ---------------------------------------<span class="id">#B</span>   
                    │── policy  ---------------------------------------<span class="id">#C</span>
                    │── sample ----------------------------------------<span class="id">#D</span>
                    │── service ---------------------------------------<span class="id">#E</span>
                    │── snmputil --------------------------------------<span class="id">#F</span>
                    └── tool ------------------------------------------<span class="id">#G</span>
SNMPUI ----------------------------------------------------------------#H
</code></pre><p>#A 基本的数据结构定义在这个包里面<br>#B OID集合定义在这个包里面， OID的集合是指要一起收集的一组OID，比如要收集CPU或者Network相关的数据，需要一组OID同时收集回来然后进行计算。<br>#C 对数据进行管理的策略定义（当整合数据库之后可以用，用来减少数据的存储量，目前暂未实现）<br>#D 范例代码<br>#E 管理类定义在这个包中，用来管理数据对象<br>#F SNMP的底层基本组件实现<br>#G 一些通用的工具类<br>#H 一个网页版的使用范例（构建中）</p>
<h3 id="构建jar包与javadoc">构建jar包与javadoc</h3><p>该项目使用gradle进行编译和构建，下载源代码之后需要先安装<a href="/2015/07/03/gradle/" title="Gradle使用入门">Gradle</a>，然后在项目的根目录下执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradle build</span><br><span class="line">gradle javaDoces</span><br></pre></td></tr></table></figure>
<p>生成的jar包存放在build/libs目录下<br>生成的javadoc存放在build/doces/javadoc目录下。</p>
<h2 id="如何使用">如何使用</h2><h3 id="开发环境构建">开发环境构建</h3><p>将构建好的SNMPCore-1.0.0.jar引入你的工程Class-path，就可以直接使用相关的代码了。</p>
<h3 id="初始化代码">初始化代码</h3><pre><code>SNMPParameter parameter = new SNMPParameter<span class="params">()</span>;<span class="comment">//初始化SNMP的参数</span>
parameter.setCommunity<span class="params">(<span class="string">"public"</span>)</span>;
parameter.setVersion<span class="params">(SNMPVersion.V1)</span>;
parameter.setPort<span class="params">(<span class="number">163</span>)</span>;
</code></pre><h3 id="构建监控对象">构建监控对象</h3><pre><code>Device device = new Device<span class="params">(<span class="string">"127.0.0.1"</span>)</span>;<span class="comment">//Device对象就是监控对象的一个实现</span>
Oid oid = new Oid<span class="params">(<span class="string">"1.3.6.1.2.1.2.1"</span>)</span>;<span class="comment">// 这里是构建需要收集数据的OID对象</span>
device.addOids<span class="params">(oid)</span>;
device.initDevice<span class="params">(parameter)</span>; <span class="comment">//使用init方法初始化这个监控对象</span>
</code></pre><h3 id="获取SNMP数据">获取SNMP数据</h3><pre><code>device.doCollection<span class="params">()</span>;<span class="comment">//调用这个方法之后就会触发SNMP的收集过程</span>
</code></pre><p>在<code>doCollection</code>方法执行完成后就可以从Device对象中读取采集回来的结果了</p>
<ul>
<li>如果是要获取特定OID对象的数值，收集结果完成之后，对应的OID对象中就会有收集回来的数值了，可以直接从OID通过<code>OID.getValue()</code>获取采集到的结果</li>
<li>如果是使用数据集合，也是可以直接从那个数据集合中直接获取到结果（参见范例）。</li>
</ul>
<h3 id="采集table_oid对象">采集table oid对象</h3><pre><code>TableOid table = new TableOid<span class="params">(<span class="string">"1.3.6.1.2.1.2.2"</span>, <span class="string">"1.3.6.1.2.1.2.2.1.2"</span>,<span class="string">"1.3.6.1.2.1.2.2.1.5"</span>,<span class="string">"1.3.6.1.2.1.2.2.1.3"</span>)</span>;
device.addOids<span class="params">(table)</span>;
device.doCollection<span class="params">()</span>;
<span class="keyword">for</span><span class="params">(TableColumnOid column : table.getColumns<span class="params">()</span>)</span>{
    <span class="keyword">for</span><span class="params">(String index : column.getIndex<span class="params">()</span>)</span>{
        System.out.println<span class="params">(column.getValue<span class="params">(index)</span>)</span>;
    }
}
</code></pre><p>因为table结构的特殊性，需要使用index来标识column中的一个单元格数据。所以在采集了table的数据之后，我们需要首先获取到colum（一行）的对象，然后根据这个对象中的index来获取具体单元格的数据。</p>
<h3 id="snmpv3数据采集">snmpv3数据采集</h3><pre><code>Device device = new Device<span class="params">(<span class="string">"127.0.0.1"</span>)</span>;
Oid oid = new Oid<span class="params">(<span class="string">"1.3.6.1.2.1.2.1"</span>)</span>;
device.addOids<span class="params">(oid)</span>;
SNMPParameter parameter = new SNMPParameter<span class="params">()</span>;
parameter.setUserName<span class="params">(<span class="string">"shaDes"</span>)</span>;
parameter.setVersion<span class="params">(SNMPVersion.V3)</span>;
parameter.setAuthentication<span class="params">(<span class="string">"1234567890"</span>)</span>;
parameter.setPrivacy<span class="params">(<span class="string">"1234567890"</span>)</span>;
parameter.setAuthProtocol<span class="params">(Protocol.AuthSHA)</span>;
parameter.setPrivacyProtocol<span class="params">(Protocol.PrivDES)</span>;
device.initDevice<span class="params">(parameter)</span>;
device.doCollection<span class="params">()</span>;
System.out.print<span class="params">(device.getOids<span class="params">()</span>)</span>;
</code></pre><h3 id="自定义采集Oid集合">自定义采集Oid集合</h3><p>有些监控数据的采集需要集合多个OID对象一起通过计算获取，那么我们可以使用数据集合对象<code>Monitor</code>来组织这些OID。在你的项目代码中实现一个<code>Monitor</code>的子类，然后其中实现计算过程，最后，对于最上层的用户来说可以完全屏蔽掉OID，只需要直接获取计算的结果展示就可以了。<br>内置实现了CPU, Memory, Network, Disk，SystemInfo可以直接使用或者作为实现其他集合的参考范例。当然，如果需要扩展内置的几个基本监控集合，可以实现相应集合的子类，从而实现扩展的目的。</p>
<pre><code>device.addMonitor(<span class="keyword">new</span> <span class="type">CPU</span><span class="literal">()</span>);
device.addMonitor(<span class="keyword">new</span> <span class="type">Disk</span><span class="literal">()</span>);
device.addMonitor(<span class="keyword">new</span> <span class="type">Memory</span><span class="literal">()</span>);
device.addMonitor(<span class="keyword">new</span> <span class="type">Network</span><span class="literal">()</span>);
device.addMonitor(<span class="keyword">new</span> <span class="type">SystemInfo</span><span class="literal">()</span>);
device.doCollection<span class="literal">()</span>;
<span class="type">CPU</span> cpu = device.getMonitor(<span class="type">CPU</span>.<span class="keyword">class</span>);
<span class="type">Memory</span> memory = device.getMonitor(<span class="type">Memory</span>.<span class="keyword">class</span>);
<span class="type">Disk</span> disk = device.getMonitor(<span class="type">Disk</span>.<span class="keyword">class</span>);
...
</code></pre><h2 id="一个简单的范例">一个简单的范例</h2><pre><code><span class="comment">/*
 * DeviceSample.java
 * Date: 5/21/2015
 * Time: 2:18 PM
 * 
 * Copyright 2015 luoyuan.
 * ALL RIGHTS RESERVED.
*/</span>

package ly.snmp.core.sample;

<span class="keyword">import</span> ly.snmp.core.model.Device;
<span class="keyword">import</span> ly.snmp.core.model.Oid;
<span class="keyword">import</span> ly.snmp.core.model.SNMPParameter;
<span class="keyword">import</span> ly.snmp.core.model.SNMPVersion;
<span class="keyword">import</span> ly.snmp.core.monitor.Memory;
<span class="keyword">import</span> ly.snmp.core.monitor.Monitor;

<span class="keyword">import</span> java.io.IOException;

<span class="comment">/**
 * This is a sample for how to use this snmp framework to collect snmp data
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">DeviceSample</span> </span>{
    public static final <span class="built_in">String</span> ip = <span class="string">"127.0.0.1"</span>;
    public static <span class="keyword">void</span> main(<span class="built_in">String</span>...args) throws IOException {
        Device device = <span class="keyword">new</span> Device(ip);
        SNMPParameter parameter = <span class="keyword">new</span> SNMPParameter();
        parameter.setVersion(SNMPVersion.V1);
        <span class="comment">//parameter.setPort(163);//Default is 163</span>
        parameter.setCommunity(<span class="string">"public"</span>);
        device.initDevice(parameter);
        <span class="comment">//Will collect memory data</span>
        Monitor monitor = <span class="keyword">new</span> Memory();
        device.addMonitor(monitor);
        <span class="comment">//Add special oid for collect</span>
        Oid oid = <span class="keyword">new</span> Oid(<span class="string">"1.3.6.1.2.1.1.1"</span>);
        device.addOids(oid);
        device.doCollection();
        <span class="comment">/*//Now we can get those snmp data from device
        Memory memory = device.getMonitor(Memory.class);
        System.out.println(memory.getTotalSize());
        System.out.println(memory.getUsed());
        System.out.println(oid.getValue());
        */</span>
    }
}
</code></pre><h2 id="谢谢使用">谢谢使用</h2><p>欢迎您的建议和修改</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>基于snmp4j实现的一个SNMP框架，目的是简化snmp的开发流程，只需要使用几个简单的类就可以实现通过snmp协议收集数据，也可以作为一个snmp4j的使用范例进行参考。基于Apache2.0协议开放源代码。<br>]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Log4J中的继承关系]]></title>
    <link href="http://luoyuan800.github.io/2015/07/06/Log4J-Inherit/"/>
    <id>http://luoyuan800.github.io/2015/07/06/Log4J-Inherit/</id>
    <published>2015-07-06T01:06:35.000Z</published>
    <updated>2015-07-06T01:30:42.264Z</updated>
    <content type="html"><![CDATA[<p>Java代码中可以通过继承关系来扩展类的功能，在Log4J也有类似的机制。<br><a id="more"></a></p>
<h2 id="Logger的理解">Logger的理解</h2><p>在log4j的使用中，我们是使用<code>Logger.getLogger(name)</code>来获取Logger实例，这里的Logger实例中的名字是有name来指定，这个那么就限定了我们这个logger会使用什么配置。个人的理解是，在log4j中的Logger的实例是根据名字来唯一存在的，一个名字只会存在一个Logger实例。大概可以这样理解，每一个<code>getLogger</code>返回的都是Logger的一个子类，这个子类是静态，每个子类之间是根据名字来区分的。</p>
<h2 id="继承关系">继承关系</h2><h3 id="父类">父类</h3><p>既然是继承，那么需要一个父类，Logger是不能直接实例化，而我们可以通过<code>Logger.getRootLogger()</code>方式来取一个名字标识为rootLogger的Logger子类，这个类我们可以看做其他Logger子类的父类，所有的Logger子类都会继承自它。</p>
<h3 id="用户自定义的Logger">用户自定义的Logger</h3><p>用户自定义的Logger其实际意义就是指定Log4J生成一个指定名称和配置的子类。<br>比如在<em>log4j.properties</em>文件中定义了这么一句</p>
<pre><code>log4j<span class="class">.logger</span><span class="class">.father</span>=DEBUG, fatherConfig
</code></pre><p>那么这句话的意思是说定义一个名字为father的logger类，在代码中可以通过<code>Logger.getLogger(“father”);</code> 来获取这个father对应Logger类。那如果我们需要定义一个这个father的子类就应该：</p>
<pre><code>log4j<span class="class">.logger</span><span class="class">.father</span><span class="class">.children</span>=INFO,childrenConfig
</code></pre><p>那么在定义上这个father.children就是一个子类，并且获取方式为：</p>
<pre><code><span class="tag">Logger</span><span class="class">.getLogger</span>(“<span class="tag">father</span><span class="class">.children</span>”);
</code></pre><h3 id="代码中直接定义子类">代码中直接定义子类</h3><p>即使没有在配置文件中显示的写出子类的定义，我们也可以在代码中通过名称来指定logger实例的继承关系：</p>
<pre><code><span class="tag">Logger</span><span class="class">.getLogger</span>(“<span class="tag">father</span><span class="class">.children</span><span class="class">.children</span>”);
</code></pre><p>上面这个语句就使得我们获得了一个继承自father.children的子类father.children.children。</p>
<h2 id="继承关系的用处">继承关系的用处</h2><p>继承的存在对我们最显著的影响是什么呢？</p>
<ul>
<li><p>个人理解是记录到子类上的log也会被父类接收！是的，正常情况，如果使用子类的实例记录一个log信息，那么这个子类的所有父类都会接收到log信息并且记录。如果我们把子类和父类的输出目的地都设置为一样，那么就会发现重复的log信息。<br>比如我们使用以下代码段，并且把<code>father，father.children</code>的输出<em>appender</em>都设置为控制台输出(org.apache.log4j.ConsoleAppender)</p>
<pre><code>Logger logger=Logger.getLogger(“father.children.children”)<span class="comment">;</span>
Logger.info(“这是一个子类的子类log信息”)<span class="comment">;</span>
</code></pre><p>我们可以在控制台看到3条log信息，分别是由<em>father.children.children、father.children、father</em>上log进行了输出。<br>这里要注意，father的级别被定义为DEBUG，但是我们输出的INFO信息页被father记录了，这个就表明了father接受到子类的log信息之后father的级别限定会被子类的覆盖掉。</p>
</li>
<li><p>其实我个人并不是很理解这个继承关系会给我们带来什么样的好处，或许是某些部分的信息我们希望不仅被自己的log记录，还希望能被其他的log接收到。另外一个好处就是我们使用名字限定的方式在代码中动态获得一个没有在配置文件中指定的logger实例的时候，这个logger会继承那个父类的log配置。</p>
</li>
</ul>
<h2 id="RootLogger">RootLogger</h2><p>还有需要注意的一点是，我们经常可以看到别人使用的配置文件里面会定义个：</p>
<pre><code>lo<span class="keyword">g4</span>j.rootLogger=DEBUG, appe<span class="label">nd1</span>, appe<span class="label">nd2</span>
</code></pre><ul>
<li>这里是对最高级的父类进行了<strong>rootLogger</strong>进行了配置限定，如果没有显式定义其他的Logger的话，那么所有代码中获取到的Logger实例都会继承这个配置。</li>
<li><p>如果同时定义了其他Logger，并且那个Logger有一个继承的子Logger，那么那个子类Logger的继承关系是：</p>
<pre><code>children-&gt; father -&gt;rootLogger
</code></pre></li>
<li><p>可以使用log4j.additivity.LOGNAME=false来屏蔽掉这种关系（注意LOGNAME是LOG的名称不是LOG的配置名）。</p>
</li>
</ul>
<h2 id="类实例Logger">类实例Logger</h2><p>我们经常使用的<code>Logg.getLoggger(class)</code>获取的Logger实例,如果需要配置这些Logger，在配置文件中定义其log规范使用class name来定位。</p>
<pre><code>Log4j<span class="class">.logger</span><span class="class">.className</span>= class_full_name
</code></pre><p>其含义就是使用class的全限定名来作为logger的名称，这样如果有需要的话我们可以对每个类都定义自己的log规范。<br>当然如果没有在配置文件里面配置这个全限定名字的logger，这个logger会继承rootLogger的配置，如果连rootLogger都没配置，那么log信息是无法被接收的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java代码中可以通过继承关系来扩展类的功能，在Log4J也有类似的机制。<br>]]>
    
    </summary>
    
      <category term="编程-Java" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gradle使用入门]]></title>
    <link href="http://luoyuan800.github.io/2015/07/03/gradle/"/>
    <id>http://luoyuan800.github.io/2015/07/03/gradle/</id>
    <published>2015-07-03T09:17:14.000Z</published>
    <updated>2015-12-22T02:01:49.110Z</updated>
    <content type="html"><![CDATA[<p>Gradle是一个基于Groovy实现的，类似于Ant工具的项目构建文件，其设计目标是用更简单的语法和方式来配置一个项目的构建，而不需要像Ant工具一样那么麻烦 。<a id="more"></a></p>
<h2 id="如何配置Gradle：">如何配置Gradle：</h2><ul>
<li>下载<a href="http://gradle.org/" target="_blank" rel="external">Gradle</a>解压到自定义文件夹</li>
<li>配置环境变量：GRADLE_HOME</li>
<li>添加%GRADLE_HOME%到Path中</li>
<li>测试 gradle -v 输出正常表示配置成功</li>
</ul>
<h2 id="用Gradle_打包项目">用Gradle 打包项目</h2><ul>
<li>构建 build.gradle 文件</li>
<li><p>一个简单的gradle build文件</p>
<pre><code>apply plugin: <span class="string">'java'</span>
version = <span class="string">'1.0.0'</span>

<span class="keyword">repositories</span> {
    mavenLocal()
    mavenCentral()
    maven{
        url <span class="string">"https://oosnmp.net/dist/release"</span>
    }
}

<span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="string">'org.snmp4j:snmp4j:2.3.3'</span>
}

jar {
    manifest{
    attributes <span class="string">'Title'</span>: <span class="string">'SNMPFramework'</span>, <span class="string">'Version'</span> : <span class="number">1.0</span>, <span class="string">'Author'</span>:<span class="string">'LuoYuan'</span>
}

metaInf {
    <span class="keyword">from</span>(<span class="string">'..'</span>) {
        <span class="keyword">include</span> <span class="string">'*.md'</span>
    }
    includeEmptyDirs = <span class="keyword">false</span>
    }
}

<span class="keyword">sourceSets</span>{
    main {
        java{
            srcDir <span class="string">'src'</span>
        }
    }
}

<span class="keyword">task</span> javaDoces(type: Javadoc){
    <span class="keyword">source</span> = <span class="keyword">sourceSets</span>.main.allJava
}
</code></pre></li>
</ul>
<p>这个build文件表示这个项目的依赖关系，还有从什么地方获取依赖包。</p>
<p><strong>dependencies</strong> 标签定义编译代码的时候要依赖的jar包</p>
<p>Gradle会尝试从<strong>repositories</strong>获取依赖的jar包 ，然后放到user/.gradle的文件目录下缓存，下次build的时候直接从这个地方获取。</p>
<p><strong>task</strong> 标签定义一个新的task， 可以通过gradle <task\> 运行。</task\></p>
<p><strong>sourceSet</strong>标签指定项目的源代码结果，如果不配置的话会是用默认的结构 src/main/java作为源文件的存放位置。</p>
<p><strong>jar</strong> 标签定义执行build之后生成的jar包目录结构，可以配置jar包中manifest文件的内容。</p>
<p><strong>metaInf</strong> 标签定义在生产的jar包中 META-INF 目录要放入的文件。</p>
<h2 id="Gradle_构建war项目：">Gradle 构建war项目：</h2><h3 id="默认的项目结构：">默认的项目结构：</h3><pre><code>.
├── build<span class="class">.gradle</span>
└── src
    └── main
        ├── java
        │   └── com
        │       └── todo
        │           └── ToDoServlet<span class="class">.java</span>
        │                   
        └── webapp-------------------------------------------------<span class="id">#A</span>
            ├── WEB-INF
            │   └── web.xml----------------------------------------<span class="id">#B</span>
            ├── css------------------------------------------------<span class="id">#C</span>
            │   ├── base<span class="class">.css</span>
            │   └── bg<span class="class">.png</span>
            └── jsp------------------------------------------------<span class="id">#D</span>
                ├── index<span class="class">.jsp</span>
                └── todo-list.jsp
</code></pre><p>#A Web源文件默认目录</p>
<p>#B Web应用描述符文件</p>
<p>#C 存储描述如何展现HTML元素的样式单文件的目录</p>
<p>#D 存放JSP形式的动态脚本化视图组件</p>
<h3 id="一个简单脚本示例：">一个简单脚本示例：</h3><pre><code><span class="tag">apply</span> <span class="rule"><span class="attribute">plugin</span>:<span class="value"> <span class="string">'war'</span>
version = <span class="string">'1.0.0'</span>
apply plugin: <span class="string">'jetty'</span>
httpPort = <span class="number">8888</span>
repositories {
    <span class="function">mavenLocal</span>()
    <span class="function">mavenCentral</span>()
}

war {
    manifest{
        attributes <span class="string">'Title'</span>: <span class="string">'SNMPFrameworkUI'</span>, <span class="string">'Version'</span> : <span class="number">1.0</span>, <span class="string">'Author'</span>:<span class="string">'LuoYuan'</span>
    }
    metaInf {
        <span class="function">from</span>(<span class="string">'.'</span>) {
            include <span class="string">'**/*.md'</span>
        }
        includeEmptyDirs = false
    }
}</span></span>
</code></pre><h3 id="标签含义介绍">标签含义介绍</h3><p><strong>apply plugin:’jetty’</strong> 指定是用jetty作为运行war的容器，当运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle jettyRun</span><br></pre></td></tr></table></figure></p>
<p>可以启动jetty 然后自动部署当前的war包进行测试。</p>
<p><strong>httpPort</strong> 这个属性指定jetty运行的时候使用的端口，默认为8080。</p>
<h2 id="使用gradle关联本地的jar包">使用gradle关联本地的jar包</h2><ul>
<li><p>首先定义repositories</p>
<pre><code><span class="xml">repositories </span><span class="expression">{
   <span class="variable">flatDir</span>{
        <span class="variable">dirs</span> '<span class="variable">src</span><span class="end-block">/main</span><span class="end-block">/webapp</span><span class="end-block">/WEB-INF</span><span class="end-block">/lib</span>'
    }</span><span class="xml">
}</span>
</code></pre></li>
<li><p>然后需要将jar包放到对应的目录，并且在build文件中增加</p>
<pre><code>dependencies {
    compile ([':<span class="property">name</span>:<span class="property">version</span>'],[':<span class="property">name</span>:<span class="property">version</span>'])
}
</code></pre></li>
</ul>
<h2 id="Build_Fat_Jar">Build Fat Jar</h2><p>gradle默认build出来的jar是不包含其他的关联jar包的，所以可能会出现build出来的jar包无法直接运行。如果我们考虑移植的方便性，并且不考虑的jar容量大小的话，可以直接build一个包含输油关联第三方jar的FatJar出来，在gradle的build文件中定义：</p>
<pre><code><span class="keyword">task</span> fatJar(type: Jar) {
    manifest {
    <span class="comment">//这里可以定义jar包中的manifest的内容</span>
    }
    baseName = <span class="keyword">project</span>.name + <span class="string">'-all'</span>
    <span class="keyword">from</span> { <span class="keyword">configurations</span>.<span class="keyword">compile</span>.<span class="keyword">collect</span> { it.isDirectory() ? it : zipTree(it) } }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Gradle是一个基于Groovy实现的，类似于Ant工具的项目构建文件，其设计目标是用更简单的语法和方式来配置一个项目的构建，而不需要像Ant工具一样那么麻烦 。]]>
    
    </summary>
    
      <category term="编程-工具" scheme="http://luoyuan800.github.io/categories/%E7%BC%96%E7%A8%8B-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>